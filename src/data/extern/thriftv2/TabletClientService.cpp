/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data/extern/thriftv2/TabletClientService.h"

namespace org { namespace apache { namespace accumulov2 { namespace core { namespace tabletserver { namespace thrift {


TabletClientService_startScan_args::~TabletClientService_startScan_args() throw() {
}


uint32_t TabletClientService_startScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range.read(iprot);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->columns.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->columns[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ssiList.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _etype126;
            xfer += iprot->readListBegin(_etype126, _size123);
            this->ssiList.resize(_size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              xfer += this->ssiList[_i127].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ssiList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ssio.clear();
            uint32_t _size128;
            ::apache::thrift::protocol::TType _ktype129;
            ::apache::thrift::protocol::TType _vtype130;
            xfer += iprot->readMapBegin(_ktype129, _vtype130, _size128);
            uint32_t _i132;
            for (_i132 = 0; _i132 < _size128; ++_i132)
            {
              std::string _key133;
              xfer += iprot->readString(_key133);
              std::map<std::string, std::string> & _val134 = this->ssio[_key133];
              {
                _val134.clear();
                uint32_t _size135;
                ::apache::thrift::protocol::TType _ktype136;
                ::apache::thrift::protocol::TType _vtype137;
                xfer += iprot->readMapBegin(_ktype136, _vtype137, _size135);
                uint32_t _i139;
                for (_i139 = 0; _i139 < _size135; ++_i139)
                {
                  std::string _key140;
                  xfer += iprot->readString(_key140);
                  std::string& _val141 = _val134[_key140];
                  xfer += iprot->readString(_val141);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ssio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readListBegin(_etype145, _size142);
            this->authorizations.resize(_size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              xfer += iprot->readBinary(this->authorizations[_i146]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->waitForWrites);
          this->__isset.waitForWrites = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isolated);
          this->__isset.isolated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->readaheadThreshold);
          this->__isset.readaheadThreshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->samplerConfig.read(iprot);
          this->__isset.samplerConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->batchTimeOut);
          this->__isset.batchTimeOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classLoaderContext);
          this->__isset.classLoaderContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->executionHints.clear();
            uint32_t _size147;
            ::apache::thrift::protocol::TType _ktype148;
            ::apache::thrift::protocol::TType _vtype149;
            xfer += iprot->readMapBegin(_ktype148, _vtype149, _size147);
            uint32_t _i151;
            for (_i151 = 0; _i151 < _size147; ++_i151)
            {
              std::string _key152;
              xfer += iprot->readString(_key152);
              std::string& _val153 = this->executionHints[_key152];
              xfer += iprot->readString(_val153);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.executionHints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startScan_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->range.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> ::const_iterator _iter154;
    for (_iter154 = this->columns.begin(); _iter154 != this->columns.end(); ++_iter154)
    {
      xfer += (*_iter154).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->batchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ssiList.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter155;
    for (_iter155 = this->ssiList.begin(); _iter155 != this->ssiList.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->ssio.size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter156;
    for (_iter156 = this->ssio.begin(); _iter156 != this->ssio.end(); ++_iter156)
    {
      xfer += oprot->writeString(_iter156->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter156->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter157;
        for (_iter157 = _iter156->second.begin(); _iter157 != _iter156->second.end(); ++_iter157)
        {
          xfer += oprot->writeString(_iter157->first);
          xfer += oprot->writeString(_iter157->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter158;
    for (_iter158 = this->authorizations.begin(); _iter158 != this->authorizations.end(); ++_iter158)
    {
      xfer += oprot->writeBinary((*_iter158));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitForWrites", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->waitForWrites);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolated", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->isolated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readaheadThreshold", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->readaheadThreshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samplerConfig", ::apache::thrift::protocol::T_STRUCT, 13);
  xfer += this->samplerConfig.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchTimeOut", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->batchTimeOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->classLoaderContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionHints", ::apache::thrift::protocol::T_MAP, 16);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->executionHints.size()));
    std::map<std::string, std::string> ::const_iterator _iter159;
    for (_iter159 = this->executionHints.begin(); _iter159 != this->executionHints.end(); ++_iter159)
    {
      xfer += oprot->writeString(_iter159->first);
      xfer += oprot->writeString(_iter159->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startScan_pargs::~TabletClientService_startScan_pargs() throw() {
}


uint32_t TabletClientService_startScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startScan_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->range)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->columns)).size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> ::const_iterator _iter160;
    for (_iter160 = (*(this->columns)).begin(); _iter160 != (*(this->columns)).end(); ++_iter160)
    {
      xfer += (*_iter160).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->batchSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->ssiList)).size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter161;
    for (_iter161 = (*(this->ssiList)).begin(); _iter161 != (*(this->ssiList)).end(); ++_iter161)
    {
      xfer += (*_iter161).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->ssio)).size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter162;
    for (_iter162 = (*(this->ssio)).begin(); _iter162 != (*(this->ssio)).end(); ++_iter162)
    {
      xfer += oprot->writeString(_iter162->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter162->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter163;
        for (_iter163 = _iter162->second.begin(); _iter163 != _iter162->second.end(); ++_iter163)
        {
          xfer += oprot->writeString(_iter163->first);
          xfer += oprot->writeString(_iter163->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->authorizations)).size()));
    std::vector<std::string> ::const_iterator _iter164;
    for (_iter164 = (*(this->authorizations)).begin(); _iter164 != (*(this->authorizations)).end(); ++_iter164)
    {
      xfer += oprot->writeBinary((*_iter164));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitForWrites", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool((*(this->waitForWrites)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolated", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool((*(this->isolated)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readaheadThreshold", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64((*(this->readaheadThreshold)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samplerConfig", ::apache::thrift::protocol::T_STRUCT, 13);
  xfer += (*(this->samplerConfig)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchTimeOut", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64((*(this->batchTimeOut)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString((*(this->classLoaderContext)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionHints", ::apache::thrift::protocol::T_MAP, 16);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->executionHints)).size()));
    std::map<std::string, std::string> ::const_iterator _iter165;
    for (_iter165 = (*(this->executionHints)).begin(); _iter165 != (*(this->executionHints)).end(); ++_iter165)
    {
      xfer += oprot->writeString(_iter165->first);
      xfer += oprot->writeString(_iter165->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startScan_result::~TabletClientService_startScan_result() throw() {
}


uint32_t TabletClientService_startScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tmfe.read(iprot);
          this->__isset.tmfe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startScan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nste) {
    xfer += oprot->writeFieldBegin("nste", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->nste.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tmfe) {
    xfer += oprot->writeFieldBegin("tmfe", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->tmfe.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tsnpe) {
    xfer += oprot->writeFieldBegin("tsnpe", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->tsnpe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startScan_presult::~TabletClientService_startScan_presult() throw() {
}


uint32_t TabletClientService_startScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tmfe.read(iprot);
          this->__isset.tmfe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_continueScan_args::~TabletClientService_continueScan_args() throw() {
}


uint32_t TabletClientService_continueScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_continueScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_continueScan_args");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueScan_pargs::~TabletClientService_continueScan_pargs() throw() {
}


uint32_t TabletClientService_continueScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_continueScan_pargs");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scanID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueScan_result::~TabletClientService_continueScan_result() throw() {
}


uint32_t TabletClientService_continueScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tmfe.read(iprot);
          this->__isset.tmfe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_continueScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_continueScan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nste) {
    xfer += oprot->writeFieldBegin("nste", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->nste.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tmfe) {
    xfer += oprot->writeFieldBegin("tmfe", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->tmfe.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tsnpe) {
    xfer += oprot->writeFieldBegin("tsnpe", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->tsnpe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueScan_presult::~TabletClientService_continueScan_presult() throw() {
}


uint32_t TabletClientService_continueScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tmfe.read(iprot);
          this->__isset.tmfe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_closeScan_args::~TabletClientService_closeScan_args() throw() {
}


uint32_t TabletClientService_closeScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeScan_args");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeScan_pargs::~TabletClientService_closeScan_pargs() throw() {
}


uint32_t TabletClientService_closeScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeScan_pargs");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scanID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startMultiScan_args::~TabletClientService_startMultiScan_args() throw() {
}


uint32_t TabletClientService_startMultiScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->batch.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _ktype167;
            ::apache::thrift::protocol::TType _vtype168;
            xfer += iprot->readMapBegin(_ktype167, _vtype168, _size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
               ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent _key171;
              xfer += _key171.read(iprot);
              std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRange> & _val172 = this->batch[_key171];
              {
                _val172.clear();
                uint32_t _size173;
                ::apache::thrift::protocol::TType _etype176;
                xfer += iprot->readListBegin(_etype176, _size173);
                _val172.resize(_size173);
                uint32_t _i177;
                for (_i177 = 0; _i177 < _size173; ++_i177)
                {
                  xfer += _val172[_i177].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->columns.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += this->columns[_i182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ssiList.clear();
            uint32_t _size183;
            ::apache::thrift::protocol::TType _etype186;
            xfer += iprot->readListBegin(_etype186, _size183);
            this->ssiList.resize(_size183);
            uint32_t _i187;
            for (_i187 = 0; _i187 < _size183; ++_i187)
            {
              xfer += this->ssiList[_i187].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ssiList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ssio.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _ktype189;
            ::apache::thrift::protocol::TType _vtype190;
            xfer += iprot->readMapBegin(_ktype189, _vtype190, _size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              std::string _key193;
              xfer += iprot->readString(_key193);
              std::map<std::string, std::string> & _val194 = this->ssio[_key193];
              {
                _val194.clear();
                uint32_t _size195;
                ::apache::thrift::protocol::TType _ktype196;
                ::apache::thrift::protocol::TType _vtype197;
                xfer += iprot->readMapBegin(_ktype196, _vtype197, _size195);
                uint32_t _i199;
                for (_i199 = 0; _i199 < _size195; ++_i199)
                {
                  std::string _key200;
                  xfer += iprot->readString(_key200);
                  std::string& _val201 = _val194[_key200];
                  xfer += iprot->readString(_val201);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ssio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _etype205;
            xfer += iprot->readListBegin(_etype205, _size202);
            this->authorizations.resize(_size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              xfer += iprot->readBinary(this->authorizations[_i206]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->waitForWrites);
          this->__isset.waitForWrites = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->samplerConfig.read(iprot);
          this->__isset.samplerConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->batchTimeOut);
          this->__isset.batchTimeOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classLoaderContext);
          this->__isset.classLoaderContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->executionHints.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _ktype208;
            ::apache::thrift::protocol::TType _vtype209;
            xfer += iprot->readMapBegin(_ktype208, _vtype209, _size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              std::string _key212;
              xfer += iprot->readString(_key212);
              std::string& _val213 = this->executionHints[_key212];
              xfer += iprot->readString(_val213);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.executionHints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startMultiScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startMultiScan_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batch", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->batch.size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRange> > ::const_iterator _iter214;
    for (_iter214 = this->batch.begin(); _iter214 != this->batch.end(); ++_iter214)
    {
      xfer += _iter214->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter214->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRange> ::const_iterator _iter215;
        for (_iter215 = _iter214->second.begin(); _iter215 != _iter214->second.end(); ++_iter215)
        {
          xfer += (*_iter215).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> ::const_iterator _iter216;
    for (_iter216 = this->columns.begin(); _iter216 != this->columns.end(); ++_iter216)
    {
      xfer += (*_iter216).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ssiList.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter217;
    for (_iter217 = this->ssiList.begin(); _iter217 != this->ssiList.end(); ++_iter217)
    {
      xfer += (*_iter217).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->ssio.size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter218;
    for (_iter218 = this->ssio.begin(); _iter218 != this->ssio.end(); ++_iter218)
    {
      xfer += oprot->writeString(_iter218->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter218->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter219;
        for (_iter219 = _iter218->second.begin(); _iter219 != _iter218->second.end(); ++_iter219)
        {
          xfer += oprot->writeString(_iter219->first);
          xfer += oprot->writeString(_iter219->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter220;
    for (_iter220 = this->authorizations.begin(); _iter220 != this->authorizations.end(); ++_iter220)
    {
      xfer += oprot->writeBinary((*_iter220));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitForWrites", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->waitForWrites);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samplerConfig", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->samplerConfig.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchTimeOut", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->batchTimeOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->classLoaderContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionHints", ::apache::thrift::protocol::T_MAP, 12);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->executionHints.size()));
    std::map<std::string, std::string> ::const_iterator _iter221;
    for (_iter221 = this->executionHints.begin(); _iter221 != this->executionHints.end(); ++_iter221)
    {
      xfer += oprot->writeString(_iter221->first);
      xfer += oprot->writeString(_iter221->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startMultiScan_pargs::~TabletClientService_startMultiScan_pargs() throw() {
}


uint32_t TabletClientService_startMultiScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startMultiScan_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batch", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->batch)).size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRange> > ::const_iterator _iter222;
    for (_iter222 = (*(this->batch)).begin(); _iter222 != (*(this->batch)).end(); ++_iter222)
    {
      xfer += _iter222->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter222->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRange> ::const_iterator _iter223;
        for (_iter223 = _iter222->second.begin(); _iter223 != _iter222->second.end(); ++_iter223)
        {
          xfer += (*_iter223).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->columns)).size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> ::const_iterator _iter224;
    for (_iter224 = (*(this->columns)).begin(); _iter224 != (*(this->columns)).end(); ++_iter224)
    {
      xfer += (*_iter224).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->ssiList)).size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter225;
    for (_iter225 = (*(this->ssiList)).begin(); _iter225 != (*(this->ssiList)).end(); ++_iter225)
    {
      xfer += (*_iter225).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->ssio)).size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter226;
    for (_iter226 = (*(this->ssio)).begin(); _iter226 != (*(this->ssio)).end(); ++_iter226)
    {
      xfer += oprot->writeString(_iter226->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter226->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter227;
        for (_iter227 = _iter226->second.begin(); _iter227 != _iter226->second.end(); ++_iter227)
        {
          xfer += oprot->writeString(_iter227->first);
          xfer += oprot->writeString(_iter227->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->authorizations)).size()));
    std::vector<std::string> ::const_iterator _iter228;
    for (_iter228 = (*(this->authorizations)).begin(); _iter228 != (*(this->authorizations)).end(); ++_iter228)
    {
      xfer += oprot->writeBinary((*_iter228));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waitForWrites", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool((*(this->waitForWrites)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samplerConfig", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += (*(this->samplerConfig)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("batchTimeOut", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64((*(this->batchTimeOut)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString((*(this->classLoaderContext)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionHints", ::apache::thrift::protocol::T_MAP, 12);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->executionHints)).size()));
    std::map<std::string, std::string> ::const_iterator _iter229;
    for (_iter229 = (*(this->executionHints)).begin(); _iter229 != (*(this->executionHints)).end(); ++_iter229)
    {
      xfer += oprot->writeString(_iter229->first);
      xfer += oprot->writeString(_iter229->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startMultiScan_result::~TabletClientService_startMultiScan_result() throw() {
}


uint32_t TabletClientService_startMultiScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startMultiScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startMultiScan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tsnpe) {
    xfer += oprot->writeFieldBegin("tsnpe", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tsnpe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startMultiScan_presult::~TabletClientService_startMultiScan_presult() throw() {
}


uint32_t TabletClientService_startMultiScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_continueMultiScan_args::~TabletClientService_continueMultiScan_args() throw() {
}


uint32_t TabletClientService_continueMultiScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_continueMultiScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_continueMultiScan_args");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueMultiScan_pargs::~TabletClientService_continueMultiScan_pargs() throw() {
}


uint32_t TabletClientService_continueMultiScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_continueMultiScan_pargs");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scanID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueMultiScan_result::~TabletClientService_continueMultiScan_result() throw() {
}


uint32_t TabletClientService_continueMultiScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_continueMultiScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_continueMultiScan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tsnpe) {
    xfer += oprot->writeFieldBegin("tsnpe", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tsnpe.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_continueMultiScan_presult::~TabletClientService_continueMultiScan_presult() throw() {
}


uint32_t TabletClientService_continueMultiScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tsnpe.read(iprot);
          this->__isset.tsnpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_closeMultiScan_args::~TabletClientService_closeMultiScan_args() throw() {
}


uint32_t TabletClientService_closeMultiScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeMultiScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeMultiScan_args");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeMultiScan_pargs::~TabletClientService_closeMultiScan_pargs() throw() {
}


uint32_t TabletClientService_closeMultiScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeMultiScan_pargs");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scanID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeMultiScan_result::~TabletClientService_closeMultiScan_result() throw() {
}


uint32_t TabletClientService_closeMultiScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeMultiScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_closeMultiScan_result");

  if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeMultiScan_presult::~TabletClientService_closeMultiScan_presult() throw() {
}


uint32_t TabletClientService_closeMultiScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_startUpdate_args::~TabletClientService_startUpdate_args() throw() {
}


uint32_t TabletClientService_startUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast230;
          xfer += iprot->readI32(ecast230);
          this->durability = (TDurability::type)ecast230;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startUpdate_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->durability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startUpdate_pargs::~TabletClientService_startUpdate_pargs() throw() {
}


uint32_t TabletClientService_startUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startUpdate_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->durability)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startUpdate_result::~TabletClientService_startUpdate_result() throw() {
}


uint32_t TabletClientService_startUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startUpdate_presult::~TabletClientService_startUpdate_presult() throw() {
}


uint32_t TabletClientService_startUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_applyUpdates_args::~TabletClientService_applyUpdates_args() throw() {
}


uint32_t TabletClientService_applyUpdates_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updateID);
          this->__isset.updateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyExtent.read(iprot);
          this->__isset.keyExtent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size231;
            ::apache::thrift::protocol::TType _etype234;
            xfer += iprot->readListBegin(_etype234, _size231);
            this->mutations.resize(_size231);
            uint32_t _i235;
            for (_i235 = 0; _i235 < _size231; ++_i235)
            {
              xfer += this->mutations[_i235].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_applyUpdates_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_applyUpdates_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->updateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyExtent", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->keyExtent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> ::const_iterator _iter236;
    for (_iter236 = this->mutations.begin(); _iter236 != this->mutations.end(); ++_iter236)
    {
      xfer += (*_iter236).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_applyUpdates_pargs::~TabletClientService_applyUpdates_pargs() throw() {
}


uint32_t TabletClientService_applyUpdates_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_applyUpdates_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->updateID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyExtent", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->keyExtent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->mutations)).size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> ::const_iterator _iter237;
    for (_iter237 = (*(this->mutations)).begin(); _iter237 != (*(this->mutations)).end(); ++_iter237)
    {
      xfer += (*_iter237).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeUpdate_args::~TabletClientService_closeUpdate_args() throw() {
}


uint32_t TabletClientService_closeUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updateID);
          this->__isset.updateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeUpdate_args");

  xfer += oprot->writeFieldBegin("updateID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->updateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeUpdate_pargs::~TabletClientService_closeUpdate_pargs() throw() {
}


uint32_t TabletClientService_closeUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeUpdate_pargs");

  xfer += oprot->writeFieldBegin("updateID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->updateID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeUpdate_result::~TabletClientService_closeUpdate_result() throw() {
}


uint32_t TabletClientService_closeUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_closeUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeUpdate_presult::~TabletClientService_closeUpdate_presult() throw() {
}


uint32_t TabletClientService_closeUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_update_args::~TabletClientService_update_args() throw() {
}


uint32_t TabletClientService_update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyExtent.read(iprot);
          this->__isset.keyExtent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mutation.read(iprot);
          this->__isset.mutation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast238;
          xfer += iprot->readI32(ecast238);
          this->durability = (TDurability::type)ecast238;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_update_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyExtent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->keyExtent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->mutation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->durability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_update_pargs::~TabletClientService_update_pargs() throw() {
}


uint32_t TabletClientService_update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_update_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keyExtent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->keyExtent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->mutation)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)(*(this->durability)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_update_result::~TabletClientService_update_result() throw() {
}


uint32_t TabletClientService_update_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cve.read(iprot);
          this->__isset.cve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_update_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_update_result");

  if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nste) {
    xfer += oprot->writeFieldBegin("nste", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->nste.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.cve) {
    xfer += oprot->writeFieldBegin("cve", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->cve.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_update_presult::~TabletClientService_update_presult() throw() {
}


uint32_t TabletClientService_update_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cve.read(iprot);
          this->__isset.cve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_startConditionalUpdate_args::~TabletClientService_startConditionalUpdate_args() throw() {
}


uint32_t TabletClientService_startConditionalUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->authorizations.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += iprot->readBinary(this->authorizations[_i243]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableID);
          this->__isset.tableID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast244;
          xfer += iprot->readI32(ecast244);
          this->durability = (TDurability::type)ecast244;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classLoaderContext);
          this->__isset.classLoaderContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startConditionalUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startConditionalUpdate_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter245;
    for (_iter245 = this->authorizations.begin(); _iter245 != this->authorizations.end(); ++_iter245)
    {
      xfer += oprot->writeBinary((*_iter245));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableID", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tableID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->durability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->classLoaderContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startConditionalUpdate_pargs::~TabletClientService_startConditionalUpdate_pargs() throw() {
}


uint32_t TabletClientService_startConditionalUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startConditionalUpdate_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->authorizations)).size()));
    std::vector<std::string> ::const_iterator _iter246;
    for (_iter246 = (*(this->authorizations)).begin(); _iter246 != (*(this->authorizations)).end(); ++_iter246)
    {
      xfer += oprot->writeBinary((*_iter246));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableID", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->tableID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)(*(this->durability)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->classLoaderContext)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startConditionalUpdate_result::~TabletClientService_startConditionalUpdate_result() throw() {
}


uint32_t TabletClientService_startConditionalUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startConditionalUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startConditionalUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startConditionalUpdate_presult::~TabletClientService_startConditionalUpdate_presult() throw() {
}


uint32_t TabletClientService_startConditionalUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_conditionalUpdate_args::~TabletClientService_conditionalUpdate_args() throw() {
}


uint32_t TabletClientService_conditionalUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessID);
          this->__isset.sessID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->mutations.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _ktype248;
            ::apache::thrift::protocol::TType _vtype249;
            xfer += iprot->readMapBegin(_ktype248, _vtype249, _size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
               ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent _key252;
              xfer += _key252.read(iprot);
              std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalMutation> & _val253 = this->mutations[_key252];
              {
                _val253.clear();
                uint32_t _size254;
                ::apache::thrift::protocol::TType _etype257;
                xfer += iprot->readListBegin(_etype257, _size254);
                _val253.resize(_size254);
                uint32_t _i258;
                for (_i258 = 0; _i258 < _size254; ++_i258)
                {
                  xfer += _val253[_i258].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->symbols.clear();
            uint32_t _size259;
            ::apache::thrift::protocol::TType _etype262;
            xfer += iprot->readListBegin(_etype262, _size259);
            this->symbols.resize(_size259);
            uint32_t _i263;
            for (_i263 = 0; _i263 < _size259; ++_i263)
            {
              xfer += iprot->readString(this->symbols[_i263]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.symbols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_conditionalUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_conditionalUpdate_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->mutations.size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalMutation> > ::const_iterator _iter264;
    for (_iter264 = this->mutations.begin(); _iter264 != this->mutations.end(); ++_iter264)
    {
      xfer += _iter264->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter264->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalMutation> ::const_iterator _iter265;
        for (_iter265 = _iter264->second.begin(); _iter265 != _iter264->second.end(); ++_iter265)
        {
          xfer += (*_iter265).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbols", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->symbols.size()));
    std::vector<std::string> ::const_iterator _iter266;
    for (_iter266 = this->symbols.begin(); _iter266 != this->symbols.end(); ++_iter266)
    {
      xfer += oprot->writeString((*_iter266));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_conditionalUpdate_pargs::~TabletClientService_conditionalUpdate_pargs() throw() {
}


uint32_t TabletClientService_conditionalUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_conditionalUpdate_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->sessID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->mutations)).size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalMutation> > ::const_iterator _iter267;
    for (_iter267 = (*(this->mutations)).begin(); _iter267 != (*(this->mutations)).end(); ++_iter267)
    {
      xfer += _iter267->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter267->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalMutation> ::const_iterator _iter268;
        for (_iter268 = _iter267->second.begin(); _iter268 != _iter267->second.end(); ++_iter268)
        {
          xfer += (*_iter268).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbols", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->symbols)).size()));
    std::vector<std::string> ::const_iterator _iter269;
    for (_iter269 = (*(this->symbols)).begin(); _iter269 != (*(this->symbols)).end(); ++_iter269)
    {
      xfer += oprot->writeString((*_iter269));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_conditionalUpdate_result::~TabletClientService_conditionalUpdate_result() throw() {
}


uint32_t TabletClientService_conditionalUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size270;
            ::apache::thrift::protocol::TType _etype273;
            xfer += iprot->readListBegin(_etype273, _size270);
            this->success.resize(_size270);
            uint32_t _i274;
            for (_i274 = 0; _i274 < _size270; ++_i274)
            {
              xfer += this->success[_i274].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_conditionalUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_conditionalUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TCMResult> ::const_iterator _iter275;
      for (_iter275 = this->success.begin(); _iter275 != this->success.end(); ++_iter275)
      {
        xfer += (*_iter275).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_conditionalUpdate_presult::~TabletClientService_conditionalUpdate_presult() throw() {
}


uint32_t TabletClientService_conditionalUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            (*(this->success)).resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += (*(this->success))[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_invalidateConditionalUpdate_args::~TabletClientService_invalidateConditionalUpdate_args() throw() {
}


uint32_t TabletClientService_invalidateConditionalUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessID);
          this->__isset.sessID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_invalidateConditionalUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_invalidateConditionalUpdate_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_invalidateConditionalUpdate_pargs::~TabletClientService_invalidateConditionalUpdate_pargs() throw() {
}


uint32_t TabletClientService_invalidateConditionalUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_invalidateConditionalUpdate_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->sessID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_invalidateConditionalUpdate_result::~TabletClientService_invalidateConditionalUpdate_result() throw() {
}


uint32_t TabletClientService_invalidateConditionalUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_invalidateConditionalUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_invalidateConditionalUpdate_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_invalidateConditionalUpdate_presult::~TabletClientService_invalidateConditionalUpdate_presult() throw() {
}


uint32_t TabletClientService_invalidateConditionalUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_closeConditionalUpdate_args::~TabletClientService_closeConditionalUpdate_args() throw() {
}


uint32_t TabletClientService_closeConditionalUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessID);
          this->__isset.sessID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_closeConditionalUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeConditionalUpdate_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_closeConditionalUpdate_pargs::~TabletClientService_closeConditionalUpdate_pargs() throw() {
}


uint32_t TabletClientService_closeConditionalUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_closeConditionalUpdate_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->sessID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_bulkImport_args::~TabletClientService_bulkImport_args() throw() {
}


uint32_t TabletClientService_bulkImport_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tid);
          this->__isset.tid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->files.clear();
            uint32_t _size281;
            ::apache::thrift::protocol::TType _ktype282;
            ::apache::thrift::protocol::TType _vtype283;
            xfer += iprot->readMapBegin(_ktype282, _vtype283, _size281);
            uint32_t _i285;
            for (_i285 = 0; _i285 < _size281; ++_i285)
            {
               ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent _key286;
              xfer += _key286.read(iprot);
              std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> & _val287 = this->files[_key286];
              {
                _val287.clear();
                uint32_t _size288;
                ::apache::thrift::protocol::TType _ktype289;
                ::apache::thrift::protocol::TType _vtype290;
                xfer += iprot->readMapBegin(_ktype289, _vtype290, _size288);
                uint32_t _i292;
                for (_i292 = 0; _i292 < _size288; ++_i292)
                {
                  std::string _key293;
                  xfer += iprot->readString(_key293);
                   ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo& _val294 = _val287[_key293];
                  xfer += _val294.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->setTime);
          this->__isset.setTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_bulkImport_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_bulkImport_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->files.size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > ::const_iterator _iter295;
    for (_iter295 = this->files.begin(); _iter295 != this->files.end(); ++_iter295)
    {
      xfer += _iter295->first.write(oprot);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter295->second.size()));
        std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> ::const_iterator _iter296;
        for (_iter296 = _iter295->second.begin(); _iter296 != _iter295->second.end(); ++_iter296)
        {
          xfer += oprot->writeString(_iter296->first);
          xfer += _iter296->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->tid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->setTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_bulkImport_pargs::~TabletClientService_bulkImport_pargs() throw() {
}


uint32_t TabletClientService_bulkImport_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_bulkImport_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->files)).size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > ::const_iterator _iter297;
    for (_iter297 = (*(this->files)).begin(); _iter297 != (*(this->files)).end(); ++_iter297)
    {
      xfer += _iter297->first.write(oprot);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter297->second.size()));
        std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> ::const_iterator _iter298;
        for (_iter298 = _iter297->second.begin(); _iter298 != _iter297->second.end(); ++_iter298)
        {
          xfer += oprot->writeString(_iter298->first);
          xfer += _iter298->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->tid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->setTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_bulkImport_result::~TabletClientService_bulkImport_result() throw() {
}


uint32_t TabletClientService_bulkImport_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size299;
            ::apache::thrift::protocol::TType _etype302;
            xfer += iprot->readListBegin(_etype302, _size299);
            this->success.resize(_size299);
            uint32_t _i303;
            for (_i303 = 0; _i303 < _size299; ++_i303)
            {
              xfer += this->success[_i303].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_bulkImport_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_bulkImport_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> ::const_iterator _iter304;
      for (_iter304 = this->success.begin(); _iter304 != this->success.end(); ++_iter304)
      {
        xfer += (*_iter304).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_bulkImport_presult::~TabletClientService_bulkImport_presult() throw() {
}


uint32_t TabletClientService_bulkImport_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            (*(this->success)).resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += (*(this->success))[_i309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_loadFiles_args::~TabletClientService_loadFiles_args() throw() {
}


uint32_t TabletClientService_loadFiles_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tid);
          this->__isset.tid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dir);
          this->__isset.dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->files.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _ktype311;
            ::apache::thrift::protocol::TType _vtype312;
            xfer += iprot->readMapBegin(_ktype311, _vtype312, _size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
               ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent _key315;
              xfer += _key315.read(iprot);
              std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> & _val316 = this->files[_key315];
              {
                _val316.clear();
                uint32_t _size317;
                ::apache::thrift::protocol::TType _ktype318;
                ::apache::thrift::protocol::TType _vtype319;
                xfer += iprot->readMapBegin(_ktype318, _vtype319, _size317);
                uint32_t _i321;
                for (_i321 = 0; _i321 < _size317; ++_i321)
                {
                  std::string _key322;
                  xfer += iprot->readString(_key322);
                   ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo& _val323 = _val316[_key322];
                  xfer += _val323.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->setTime);
          this->__isset.setTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_loadFiles_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_loadFiles_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->tid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->files.size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > ::const_iterator _iter324;
    for (_iter324 = this->files.begin(); _iter324 != this->files.end(); ++_iter324)
    {
      xfer += _iter324->first.write(oprot);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter324->second.size()));
        std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> ::const_iterator _iter325;
        for (_iter325 = _iter324->second.begin(); _iter325 != _iter324->second.end(); ++_iter325)
        {
          xfer += oprot->writeString(_iter325->first);
          xfer += _iter325->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->setTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_loadFiles_pargs::~TabletClientService_loadFiles_pargs() throw() {
}


uint32_t TabletClientService_loadFiles_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_loadFiles_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->tid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->dir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->files)).size()));
    std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > ::const_iterator _iter326;
    for (_iter326 = (*(this->files)).begin(); _iter326 != (*(this->files)).end(); ++_iter326)
    {
      xfer += _iter326->first.write(oprot);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter326->second.size()));
        std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> ::const_iterator _iter327;
        for (_iter327 = _iter326->second.begin(); _iter327 != _iter326->second.end(); ++_iter327)
        {
          xfer += oprot->writeString(_iter327->first);
          xfer += _iter327->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setTime", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool((*(this->setTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_splitTablet_args::~TabletClientService_splitTablet_args() throw() {
}


uint32_t TabletClientService_splitTablet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->splitPoint);
          this->__isset.splitPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_splitTablet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_splitTablet_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splitPoint", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->splitPoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_splitTablet_pargs::~TabletClientService_splitTablet_pargs() throw() {
}


uint32_t TabletClientService_splitTablet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_splitTablet_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splitPoint", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->splitPoint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_splitTablet_result::~TabletClientService_splitTablet_result() throw() {
}


uint32_t TabletClientService_splitTablet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_splitTablet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_splitTablet_result");

  if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nste) {
    xfer += oprot->writeFieldBegin("nste", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->nste.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_splitTablet_presult::~TabletClientService_splitTablet_presult() throw() {
}


uint32_t TabletClientService_splitTablet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nste.read(iprot);
          this->__isset.nste = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_loadTablet_args::~TabletClientService_loadTablet_args() throw() {
}


uint32_t TabletClientService_loadTablet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_loadTablet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_loadTablet_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_loadTablet_pargs::~TabletClientService_loadTablet_pargs() throw() {
}


uint32_t TabletClientService_loadTablet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_loadTablet_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_unloadTablet_args::~TabletClientService_unloadTablet_args() throw() {
}


uint32_t TabletClientService_unloadTablet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast328;
          xfer += iprot->readI32(ecast328);
          this->goal = (TUnloadTabletGoal::type)ecast328;
          this->__isset.goal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->requestTime);
          this->__isset.requestTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_unloadTablet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_unloadTablet_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goal", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->goal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->requestTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_unloadTablet_pargs::~TabletClientService_unloadTablet_pargs() throw() {
}


uint32_t TabletClientService_unloadTablet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_unloadTablet_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goal", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)(*(this->goal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64((*(this->requestTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_flush_args::~TabletClientService_flush_args() throw() {
}


uint32_t TabletClientService_flush_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_flush_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_flush_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_flush_pargs::~TabletClientService_flush_pargs() throw() {
}


uint32_t TabletClientService_flush_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_flush_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_flushTablet_args::~TabletClientService_flushTablet_args() throw() {
}


uint32_t TabletClientService_flushTablet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_flushTablet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_flushTablet_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_flushTablet_pargs::~TabletClientService_flushTablet_pargs() throw() {
}


uint32_t TabletClientService_flushTablet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_flushTablet_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_chop_args::~TabletClientService_chop_args() throw() {
}


uint32_t TabletClientService_chop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_chop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_chop_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_chop_pargs::~TabletClientService_chop_pargs() throw() {
}


uint32_t TabletClientService_chop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_chop_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->extent)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_compact_args::~TabletClientService_compact_args() throw() {
}


uint32_t TabletClientService_compact_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_compact_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_compact_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_compact_pargs::~TabletClientService_compact_pargs() throw() {
}


uint32_t TabletClientService_compact_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_compact_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->tableId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->startRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->endRow)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletServerStatus_args::~TabletClientService_getTabletServerStatus_args() throw() {
}


uint32_t TabletClientService_getTabletServerStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getTabletServerStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getTabletServerStatus_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletServerStatus_pargs::~TabletClientService_getTabletServerStatus_pargs() throw() {
}


uint32_t TabletClientService_getTabletServerStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getTabletServerStatus_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletServerStatus_result::~TabletClientService_getTabletServerStatus_result() throw() {
}


uint32_t TabletClientService_getTabletServerStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getTabletServerStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getTabletServerStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletServerStatus_presult::~TabletClientService_getTabletServerStatus_presult() throw() {
}


uint32_t TabletClientService_getTabletServerStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_getTabletStats_args::~TabletClientService_getTabletStats_args() throw() {
}


uint32_t TabletClientService_getTabletStats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getTabletStats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getTabletStats_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletStats_pargs::~TabletClientService_getTabletStats_pargs() throw() {
}


uint32_t TabletClientService_getTabletStats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getTabletStats_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->tableId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletStats_result::~TabletClientService_getTabletStats_result() throw() {
}


uint32_t TabletClientService_getTabletStats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size329;
            ::apache::thrift::protocol::TType _etype332;
            xfer += iprot->readListBegin(_etype332, _size329);
            this->success.resize(_size329);
            uint32_t _i333;
            for (_i333 = 0; _i333 < _size329; ++_i333)
            {
              xfer += this->success[_i333].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getTabletStats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getTabletStats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<TabletStats> ::const_iterator _iter334;
      for (_iter334 = this->success.begin(); _iter334 != this->success.end(); ++_iter334)
      {
        xfer += (*_iter334).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getTabletStats_presult::~TabletClientService_getTabletStats_presult() throw() {
}


uint32_t TabletClientService_getTabletStats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readListBegin(_etype338, _size335);
            (*(this->success)).resize(_size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              xfer += (*(this->success))[_i339].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_getHistoricalStats_args::~TabletClientService_getHistoricalStats_args() throw() {
}


uint32_t TabletClientService_getHistoricalStats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getHistoricalStats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getHistoricalStats_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getHistoricalStats_pargs::~TabletClientService_getHistoricalStats_pargs() throw() {
}


uint32_t TabletClientService_getHistoricalStats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getHistoricalStats_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getHistoricalStats_result::~TabletClientService_getHistoricalStats_result() throw() {
}


uint32_t TabletClientService_getHistoricalStats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getHistoricalStats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getHistoricalStats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getHistoricalStats_presult::~TabletClientService_getHistoricalStats_presult() throw() {
}


uint32_t TabletClientService_getHistoricalStats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_halt_args::~TabletClientService_halt_args() throw() {
}


uint32_t TabletClientService_halt_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_halt_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_halt_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_halt_pargs::~TabletClientService_halt_pargs() throw() {
}


uint32_t TabletClientService_halt_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_halt_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_halt_result::~TabletClientService_halt_result() throw() {
}


uint32_t TabletClientService_halt_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_halt_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_halt_result");

  if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_halt_presult::~TabletClientService_halt_presult() throw() {
}


uint32_t TabletClientService_halt_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_fastHalt_args::~TabletClientService_fastHalt_args() throw() {
}


uint32_t TabletClientService_fastHalt_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lock);
          this->__isset.lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_fastHalt_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_fastHalt_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_fastHalt_pargs::~TabletClientService_fastHalt_pargs() throw() {
}


uint32_t TabletClientService_fastHalt_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_fastHalt_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lock", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->lock)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveScans_args::~TabletClientService_getActiveScans_args() throw() {
}


uint32_t TabletClientService_getActiveScans_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveScans_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveScans_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveScans_pargs::~TabletClientService_getActiveScans_pargs() throw() {
}


uint32_t TabletClientService_getActiveScans_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveScans_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveScans_result::~TabletClientService_getActiveScans_result() throw() {
}


uint32_t TabletClientService_getActiveScans_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size340;
            ::apache::thrift::protocol::TType _etype343;
            xfer += iprot->readListBegin(_etype343, _size340);
            this->success.resize(_size340);
            uint32_t _i344;
            for (_i344 = 0; _i344 < _size340; ++_i344)
            {
              xfer += this->success[_i344].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveScans_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getActiveScans_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ActiveScan> ::const_iterator _iter345;
      for (_iter345 = this->success.begin(); _iter345 != this->success.end(); ++_iter345)
      {
        xfer += (*_iter345).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveScans_presult::~TabletClientService_getActiveScans_presult() throw() {
}


uint32_t TabletClientService_getActiveScans_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            (*(this->success)).resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += (*(this->success))[_i350].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_getActiveCompactions_args::~TabletClientService_getActiveCompactions_args() throw() {
}


uint32_t TabletClientService_getActiveCompactions_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveCompactions_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveCompactions_args");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveCompactions_pargs::~TabletClientService_getActiveCompactions_pargs() throw() {
}


uint32_t TabletClientService_getActiveCompactions_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveCompactions_pargs");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveCompactions_result::~TabletClientService_getActiveCompactions_result() throw() {
}


uint32_t TabletClientService_getActiveCompactions_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->success.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += this->success[_i355].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveCompactions_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getActiveCompactions_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ActiveCompaction> ::const_iterator _iter356;
      for (_iter356 = this->success.begin(); _iter356 != this->success.end(); ++_iter356)
      {
        xfer += (*_iter356).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveCompactions_presult::~TabletClientService_getActiveCompactions_presult() throw() {
}


uint32_t TabletClientService_getActiveCompactions_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size357;
            ::apache::thrift::protocol::TType _etype360;
            xfer += iprot->readListBegin(_etype360, _size357);
            (*(this->success)).resize(_size357);
            uint32_t _i361;
            for (_i361 = 0; _i361 < _size357; ++_i361)
            {
              xfer += (*(this->success))[_i361].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_removeLogs_args::~TabletClientService_removeLogs_args() throw() {
}


uint32_t TabletClientService_removeLogs_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filenames.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->filenames.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += iprot->readString(this->filenames[_i366]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filenames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_removeLogs_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_removeLogs_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filenames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filenames.size()));
    std::vector<std::string> ::const_iterator _iter367;
    for (_iter367 = this->filenames.begin(); _iter367 != this->filenames.end(); ++_iter367)
    {
      xfer += oprot->writeString((*_iter367));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_removeLogs_pargs::~TabletClientService_removeLogs_pargs() throw() {
}


uint32_t TabletClientService_removeLogs_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_removeLogs_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filenames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->filenames)).size()));
    std::vector<std::string> ::const_iterator _iter368;
    for (_iter368 = (*(this->filenames)).begin(); _iter368 != (*(this->filenames)).end(); ++_iter368)
    {
      xfer += oprot->writeString((*_iter368));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveLogs_args::~TabletClientService_getActiveLogs_args() throw() {
}


uint32_t TabletClientService_getActiveLogs_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveLogs_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveLogs_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveLogs_pargs::~TabletClientService_getActiveLogs_pargs() throw() {
}


uint32_t TabletClientService_getActiveLogs_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_getActiveLogs_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveLogs_result::~TabletClientService_getActiveLogs_result() throw() {
}


uint32_t TabletClientService_getActiveLogs_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size369;
            ::apache::thrift::protocol::TType _etype372;
            xfer += iprot->readListBegin(_etype372, _size369);
            this->success.resize(_size369);
            uint32_t _i373;
            for (_i373 = 0; _i373 < _size369; ++_i373)
            {
              xfer += iprot->readString(this->success[_i373]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_getActiveLogs_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_getActiveLogs_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter374;
      for (_iter374 = this->success.begin(); _iter374 != this->success.end(); ++_iter374)
      {
        xfer += oprot->writeString((*_iter374));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_getActiveLogs_presult::~TabletClientService_getActiveLogs_presult() throw() {
}


uint32_t TabletClientService_getActiveLogs_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _etype378;
            xfer += iprot->readListBegin(_etype378, _size375);
            (*(this->success)).resize(_size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              xfer += iprot->readString((*(this->success))[_i379]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_startGetSummaries_args::~TabletClientService_startGetSummaries_args() throw() {
}


uint32_t TabletClientService_startGetSummaries_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummaries_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummaries_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummaries_pargs::~TabletClientService_startGetSummaries_pargs() throw() {
}


uint32_t TabletClientService_startGetSummaries_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummaries_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummaries_result::~TabletClientService_startGetSummaries_result() throw() {
}


uint32_t TabletClientService_startGetSummaries_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tope.read(iprot);
          this->__isset.tope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummaries_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startGetSummaries_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.tope) {
    xfer += oprot->writeFieldBegin("tope", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tope.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummaries_presult::~TabletClientService_startGetSummaries_presult() throw() {
}


uint32_t TabletClientService_startGetSummaries_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tope.read(iprot);
          this->__isset.tope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_startGetSummariesForPartition_args::~TabletClientService_startGetSummariesForPartition_args() throw() {
}


uint32_t TabletClientService_startGetSummariesForPartition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modulus);
          this->__isset.modulus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->remainder);
          this->__isset.remainder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummariesForPartition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesForPartition_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modulus", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->modulus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remainder", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->remainder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesForPartition_pargs::~TabletClientService_startGetSummariesForPartition_pargs() throw() {
}


uint32_t TabletClientService_startGetSummariesForPartition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesForPartition_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modulus", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->modulus)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remainder", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->remainder)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesForPartition_result::~TabletClientService_startGetSummariesForPartition_result() throw() {
}


uint32_t TabletClientService_startGetSummariesForPartition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummariesForPartition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesForPartition_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesForPartition_presult::~TabletClientService_startGetSummariesForPartition_presult() throw() {
}


uint32_t TabletClientService_startGetSummariesForPartition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_startGetSummariesFromFiles_args::~TabletClientService_startGetSummariesFromFiles_args() throw() {
}


uint32_t TabletClientService_startGetSummariesFromFiles_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->credentials.read(iprot);
          this->__isset.credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->files.clear();
            uint32_t _size380;
            ::apache::thrift::protocol::TType _ktype381;
            ::apache::thrift::protocol::TType _vtype382;
            xfer += iprot->readMapBegin(_ktype381, _vtype382, _size380);
            uint32_t _i384;
            for (_i384 = 0; _i384 < _size380; ++_i384)
            {
              std::string _key385;
              xfer += iprot->readString(_key385);
              std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> & _val386 = this->files[_key385];
              {
                _val386.clear();
                uint32_t _size387;
                ::apache::thrift::protocol::TType _etype390;
                xfer += iprot->readListBegin(_etype390, _size387);
                _val386.resize(_size387);
                uint32_t _i391;
                for (_i391 = 0; _i391 < _size387; ++_i391)
                {
                  xfer += _val386[_i391].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummariesFromFiles_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesFromFiles_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->credentials.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->files.size()));
    std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > ::const_iterator _iter392;
    for (_iter392 = this->files.begin(); _iter392 != this->files.end(); ++_iter392)
    {
      xfer += oprot->writeString(_iter392->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter392->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> ::const_iterator _iter393;
        for (_iter393 = _iter392->second.begin(); _iter393 != _iter392->second.end(); ++_iter393)
        {
          xfer += (*_iter393).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesFromFiles_pargs::~TabletClientService_startGetSummariesFromFiles_pargs() throw() {
}


uint32_t TabletClientService_startGetSummariesFromFiles_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesFromFiles_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->credentials)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->files)).size()));
    std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > ::const_iterator _iter394;
    for (_iter394 = (*(this->files)).begin(); _iter394 != (*(this->files)).end(); ++_iter394)
    {
      xfer += oprot->writeString(_iter394->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter394->second.size()));
        std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> ::const_iterator _iter395;
        for (_iter395 = _iter394->second.begin(); _iter395 != _iter394->second.end(); ++_iter395)
        {
          xfer += (*_iter395).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesFromFiles_result::~TabletClientService_startGetSummariesFromFiles_result() throw() {
}


uint32_t TabletClientService_startGetSummariesFromFiles_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_startGetSummariesFromFiles_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_startGetSummariesFromFiles_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.sec) {
    xfer += oprot->writeFieldBegin("sec", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->sec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_startGetSummariesFromFiles_presult::~TabletClientService_startGetSummariesFromFiles_presult() throw() {
}


uint32_t TabletClientService_startGetSummariesFromFiles_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sec.read(iprot);
          this->__isset.sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TabletClientService_contiuneGetSummaries_args::~TabletClientService_contiuneGetSummaries_args() throw() {
}


uint32_t TabletClientService_contiuneGetSummaries_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tinfo.read(iprot);
          this->__isset.tinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_contiuneGetSummaries_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_contiuneGetSummaries_args");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_contiuneGetSummaries_pargs::~TabletClientService_contiuneGetSummaries_pargs() throw() {
}


uint32_t TabletClientService_contiuneGetSummaries_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletClientService_contiuneGetSummaries_pargs");

  xfer += oprot->writeFieldBegin("tinfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tinfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->sessionId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_contiuneGetSummaries_result::~TabletClientService_contiuneGetSummaries_result() throw() {
}


uint32_t TabletClientService_contiuneGetSummaries_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletClientService_contiuneGetSummaries_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TabletClientService_contiuneGetSummaries_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.nssi) {
    xfer += oprot->writeFieldBegin("nssi", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->nssi.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TabletClientService_contiuneGetSummaries_presult::~TabletClientService_contiuneGetSummaries_presult() throw() {
}


uint32_t TabletClientService_contiuneGetSummaries_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nssi.read(iprot);
          this->__isset.nssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void TabletClientServiceClient::startScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialScan& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TRange& range, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const int32_t batchSize, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated, const int64_t readaheadThreshold, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  send_startScan(tinfo, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations, waitForWrites, isolated, readaheadThreshold, samplerConfig, batchTimeOut, classLoaderContext, executionHints);
  recv_startScan(_return);
}

void TabletClientServiceClient::send_startScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TRange& range, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const int32_t batchSize, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated, const int64_t readaheadThreshold, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startScan_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.extent = &extent;
  args.range = &range;
  args.columns = &columns;
  args.batchSize = &batchSize;
  args.ssiList = &ssiList;
  args.ssio = &ssio;
  args.authorizations = &authorizations;
  args.waitForWrites = &waitForWrites;
  args.isolated = &isolated;
  args.readaheadThreshold = &readaheadThreshold;
  args.samplerConfig = &samplerConfig;
  args.batchTimeOut = &batchTimeOut;
  args.classLoaderContext = &classLoaderContext;
  args.executionHints = &executionHints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialScan& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startScan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  if (result.__isset.nste) {
    throw result.nste;
  }
  if (result.__isset.tmfe) {
    throw result.tmfe;
  }
  if (result.__isset.tsnpe) {
    throw result.tsnpe;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startScan failed: unknown result");
}

void TabletClientServiceClient::continueScan( ::org::apache::accumulov2::core::dataImpl::thrift::ScanResult& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  send_continueScan(tinfo, scanID);
  recv_continueScan(_return);
}

void TabletClientServiceClient::send_continueScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("continueScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_continueScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_continueScan( ::org::apache::accumulov2::core::dataImpl::thrift::ScanResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("continueScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_continueScan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.nssi) {
    throw result.nssi;
  }
  if (result.__isset.nste) {
    throw result.nste;
  }
  if (result.__isset.tmfe) {
    throw result.tmfe;
  }
  if (result.__isset.tsnpe) {
    throw result.tsnpe;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "continueScan failed: unknown result");
}

void TabletClientServiceClient::closeScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  send_closeScan(tinfo, scanID);
}

void TabletClientServiceClient::send_closeScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeScan", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_closeScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::startMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialMultiScan& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanBatch& batch, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  send_startMultiScan(tinfo, credentials, batch, columns, ssiList, ssio, authorizations, waitForWrites, samplerConfig, batchTimeOut, classLoaderContext, executionHints);
  recv_startMultiScan(_return);
}

void TabletClientServiceClient::send_startMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanBatch& batch, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.batch = &batch;
  args.columns = &columns;
  args.ssiList = &ssiList;
  args.ssio = &ssio;
  args.authorizations = &authorizations;
  args.waitForWrites = &waitForWrites;
  args.samplerConfig = &samplerConfig;
  args.batchTimeOut = &batchTimeOut;
  args.classLoaderContext = &classLoaderContext;
  args.executionHints = &executionHints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialMultiScan& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startMultiScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startMultiScan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  if (result.__isset.tsnpe) {
    throw result.tsnpe;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startMultiScan failed: unknown result");
}

void TabletClientServiceClient::continueMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::MultiScanResult& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  send_continueMultiScan(tinfo, scanID);
  recv_continueMultiScan(_return);
}

void TabletClientServiceClient::send_continueMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("continueMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_continueMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_continueMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::MultiScanResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("continueMultiScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_continueMultiScan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.nssi) {
    throw result.nssi;
  }
  if (result.__isset.tsnpe) {
    throw result.tsnpe;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "continueMultiScan failed: unknown result");
}

void TabletClientServiceClient::closeMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  send_closeMultiScan(tinfo, scanID);
  recv_closeMultiScan();
}

void TabletClientServiceClient::send_closeMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_closeMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_closeMultiScan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeMultiScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_closeMultiScan_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.nssi) {
    throw result.nssi;
  }
  return;
}

 ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID TabletClientServiceClient::startUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const TDurability::type durability)
{
  send_startUpdate(tinfo, credentials, durability);
  return recv_startUpdate();
}

void TabletClientServiceClient::send_startUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const TDurability::type durability)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startUpdate_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.durability = &durability;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID TabletClientServiceClient::recv_startUpdate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID _return;
  TabletClientService_startUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startUpdate failed: unknown result");
}

void TabletClientServiceClient::applyUpdates(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> & mutations)
{
  send_applyUpdates(tinfo, updateID, keyExtent, mutations);
}

void TabletClientServiceClient::send_applyUpdates(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> & mutations)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("applyUpdates", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_applyUpdates_pargs args;
  args.tinfo = &tinfo;
  args.updateID = &updateID;
  args.keyExtent = &keyExtent;
  args.mutations = &mutations;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::closeUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::UpdateErrors& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID)
{
  send_closeUpdate(tinfo, updateID);
  recv_closeUpdate(_return);
}

void TabletClientServiceClient::send_closeUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_closeUpdate_pargs args;
  args.tinfo = &tinfo;
  args.updateID = &updateID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_closeUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::UpdateErrors& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_closeUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.nssi) {
    throw result.nssi;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "closeUpdate failed: unknown result");
}

void TabletClientServiceClient::update(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TMutation& mutation, const TDurability::type durability)
{
  send_update(tinfo, credentials, keyExtent, mutation, durability);
  recv_update();
}

void TabletClientServiceClient::send_update(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TMutation& mutation, const TDurability::type durability)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("update", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_update_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.keyExtent = &keyExtent;
  args.mutation = &mutation;
  args.durability = &durability;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_update()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("update") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_update_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.sec) {
    throw result.sec;
  }
  if (result.__isset.nste) {
    throw result.nste;
  }
  if (result.__isset.cve) {
    throw result.cve;
  }
  return;
}

void TabletClientServiceClient::startConditionalUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalSession& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & authorizations, const std::string& tableID, const TDurability::type durability, const std::string& classLoaderContext)
{
  send_startConditionalUpdate(tinfo, credentials, authorizations, tableID, durability, classLoaderContext);
  recv_startConditionalUpdate(_return);
}

void TabletClientServiceClient::send_startConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & authorizations, const std::string& tableID, const TDurability::type durability, const std::string& classLoaderContext)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startConditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.authorizations = &authorizations;
  args.tableID = &tableID;
  args.durability = &durability;
  args.classLoaderContext = &classLoaderContext;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startConditionalUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalSession& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startConditionalUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startConditionalUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startConditionalUpdate failed: unknown result");
}

void TabletClientServiceClient::conditionalUpdate(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TCMResult> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID, const  ::org::apache::accumulov2::core::dataImpl::thrift::CMBatch& mutations, const std::vector<std::string> & symbols)
{
  send_conditionalUpdate(tinfo, sessID, mutations, symbols);
  recv_conditionalUpdate(_return);
}

void TabletClientServiceClient::send_conditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID, const  ::org::apache::accumulov2::core::dataImpl::thrift::CMBatch& mutations, const std::vector<std::string> & symbols)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("conditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_conditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.mutations = &mutations;
  args.symbols = &symbols;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_conditionalUpdate(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TCMResult> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("conditionalUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_conditionalUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.nssi) {
    throw result.nssi;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "conditionalUpdate failed: unknown result");
}

void TabletClientServiceClient::invalidateConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  send_invalidateConditionalUpdate(tinfo, sessID);
  recv_invalidateConditionalUpdate();
}

void TabletClientServiceClient::send_invalidateConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("invalidateConditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_invalidateConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_invalidateConditionalUpdate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("invalidateConditionalUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_invalidateConditionalUpdate_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void TabletClientServiceClient::closeConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  send_closeConditionalUpdate(tinfo, sessID);
}

void TabletClientServiceClient::send_closeConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeConditionalUpdate", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_closeConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::bulkImport(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const  ::org::apache::accumulov2::core::dataImpl::thrift::TabletFiles& files, const bool setTime)
{
  send_bulkImport(tinfo, credentials, tid, files, setTime);
  recv_bulkImport(_return);
}

void TabletClientServiceClient::send_bulkImport(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const  ::org::apache::accumulov2::core::dataImpl::thrift::TabletFiles& files, const bool setTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bulkImport", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_bulkImport_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tid = &tid;
  args.files = &files;
  args.setTime = &setTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_bulkImport(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bulkImport") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_bulkImport_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bulkImport failed: unknown result");
}

void TabletClientServiceClient::loadFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const std::string& dir, const std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > & files, const bool setTime)
{
  send_loadFiles(tinfo, credentials, tid, dir, files, setTime);
}

void TabletClientServiceClient::send_loadFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const std::string& dir, const std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > & files, const bool setTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("loadFiles", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_loadFiles_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tid = &tid;
  args.dir = &dir;
  args.files = &files;
  args.setTime = &setTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::splitTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const std::string& splitPoint)
{
  send_splitTablet(tinfo, credentials, extent, splitPoint);
  recv_splitTablet();
}

void TabletClientServiceClient::send_splitTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const std::string& splitPoint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("splitTablet", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_splitTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.extent = &extent;
  args.splitPoint = &splitPoint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_splitTablet()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("splitTablet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_splitTablet_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.sec) {
    throw result.sec;
  }
  if (result.__isset.nste) {
    throw result.nste;
  }
  return;
}

void TabletClientServiceClient::loadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_loadTablet(tinfo, credentials, lock, extent);
}

void TabletClientServiceClient::send_loadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("loadTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_loadTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::unloadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const TUnloadTabletGoal::type goal, const int64_t requestTime)
{
  send_unloadTablet(tinfo, credentials, lock, extent, goal, requestTime);
}

void TabletClientServiceClient::send_unloadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const TUnloadTabletGoal::type goal, const int64_t requestTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("unloadTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_unloadTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.goal = &goal;
  args.requestTime = &requestTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::flush(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  send_flush(tinfo, credentials, lock, tableId, startRow, endRow);
}

void TabletClientServiceClient::send_flush(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("flush", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_flush_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.tableId = &tableId;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::flushTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_flushTablet(tinfo, credentials, lock, extent);
}

void TabletClientServiceClient::send_flushTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("flushTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_flushTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::chop(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_chop(tinfo, credentials, lock, extent);
}

void TabletClientServiceClient::send_chop(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("chop", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_chop_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::compact(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  send_compact(tinfo, credentials, lock, tableId, startRow, endRow);
}

void TabletClientServiceClient::send_compact(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("compact", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_compact_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.tableId = &tableId;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::getTabletServerStatus( ::org::apache::accumulov2::core::master::thrift::TabletServerStatus& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  send_getTabletServerStatus(tinfo, credentials);
  recv_getTabletServerStatus(_return);
}

void TabletClientServiceClient::send_getTabletServerStatus(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTabletServerStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getTabletServerStatus_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getTabletServerStatus( ::org::apache::accumulov2::core::master::thrift::TabletServerStatus& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTabletServerStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getTabletServerStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTabletServerStatus failed: unknown result");
}

void TabletClientServiceClient::getTabletStats(std::vector<TabletStats> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& tableId)
{
  send_getTabletStats(tinfo, credentials, tableId);
  recv_getTabletStats(_return);
}

void TabletClientServiceClient::send_getTabletStats(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& tableId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTabletStats", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getTabletStats_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tableId = &tableId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getTabletStats(std::vector<TabletStats> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTabletStats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getTabletStats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTabletStats failed: unknown result");
}

void TabletClientServiceClient::getHistoricalStats(TabletStats& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  send_getHistoricalStats(tinfo, credentials);
  recv_getHistoricalStats(_return);
}

void TabletClientServiceClient::send_getHistoricalStats(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getHistoricalStats", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getHistoricalStats_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getHistoricalStats(TabletStats& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getHistoricalStats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getHistoricalStats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getHistoricalStats failed: unknown result");
}

void TabletClientServiceClient::halt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  send_halt(tinfo, credentials, lock);
  recv_halt();
}

void TabletClientServiceClient::send_halt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("halt", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_halt_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_halt()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("halt") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_halt_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.sec) {
    throw result.sec;
  }
  return;
}

void TabletClientServiceClient::fastHalt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  send_fastHalt(tinfo, credentials, lock);
}

void TabletClientServiceClient::send_fastHalt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("fastHalt", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_fastHalt_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::getActiveScans(std::vector<ActiveScan> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  send_getActiveScans(tinfo, credentials);
  recv_getActiveScans(_return);
}

void TabletClientServiceClient::send_getActiveScans(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveScans_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getActiveScans(std::vector<ActiveScan> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getActiveScans") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getActiveScans_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveScans failed: unknown result");
}

void TabletClientServiceClient::getActiveCompactions(std::vector<ActiveCompaction> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  send_getActiveCompactions(tinfo, credentials);
  recv_getActiveCompactions(_return);
}

void TabletClientServiceClient::send_getActiveCompactions(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveCompactions_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getActiveCompactions(std::vector<ActiveCompaction> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getActiveCompactions") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getActiveCompactions_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveCompactions failed: unknown result");
}

void TabletClientServiceClient::removeLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & filenames)
{
  send_removeLogs(tinfo, credentials, filenames);
}

void TabletClientServiceClient::send_removeLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & filenames)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeLogs", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_removeLogs_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.filenames = &filenames;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::getActiveLogs(std::vector<std::string> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  send_getActiveLogs(tinfo, credentials);
  recv_getActiveLogs(_return);
}

void TabletClientServiceClient::send_getActiveLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getActiveLogs", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveLogs_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_getActiveLogs(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getActiveLogs") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_getActiveLogs_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveLogs failed: unknown result");
}

void TabletClientServiceClient::startGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request)
{
  send_startGetSummaries(tinfo, credentials, request);
  recv_startGetSummaries(_return);
}

void TabletClientServiceClient::send_startGetSummaries(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startGetSummaries", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummaries_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startGetSummaries") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startGetSummaries_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  if (result.__isset.tope) {
    throw result.tope;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummaries failed: unknown result");
}

void TabletClientServiceClient::startGetSummariesForPartition( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const int32_t modulus, const int32_t remainder)
{
  send_startGetSummariesForPartition(tinfo, credentials, request, modulus, remainder);
  recv_startGetSummariesForPartition(_return);
}

void TabletClientServiceClient::send_startGetSummariesForPartition(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const int32_t modulus, const int32_t remainder)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startGetSummariesForPartition", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummariesForPartition_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.modulus = &modulus;
  args.remainder = &remainder;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startGetSummariesForPartition( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startGetSummariesForPartition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startGetSummariesForPartition_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummariesForPartition failed: unknown result");
}

void TabletClientServiceClient::startGetSummariesFromFiles( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > & files)
{
  send_startGetSummariesFromFiles(tinfo, credentials, request, files);
  recv_startGetSummariesFromFiles(_return);
}

void TabletClientServiceClient::send_startGetSummariesFromFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > & files)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("startGetSummariesFromFiles", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummariesFromFiles_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.files = &files;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_startGetSummariesFromFiles( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("startGetSummariesFromFiles") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_startGetSummariesFromFiles_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.sec) {
    throw result.sec;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummariesFromFiles failed: unknown result");
}

void TabletClientServiceClient::contiuneGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const int64_t sessionId)
{
  send_contiuneGetSummaries(tinfo, sessionId);
  recv_contiuneGetSummaries(_return);
}

void TabletClientServiceClient::send_contiuneGetSummaries(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const int64_t sessionId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("contiuneGetSummaries", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_contiuneGetSummaries_pargs args;
  args.tinfo = &tinfo;
  args.sessionId = &sessionId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TabletClientServiceClient::recv_contiuneGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("contiuneGetSummaries") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TabletClientService_contiuneGetSummaries_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.nssi) {
    throw result.nssi;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "contiuneGetSummaries failed: unknown result");
}

bool TabletClientServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return  ::org::apache::accumulov2::core::clientImpl::thrift::ClientServiceProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void TabletClientServiceProcessor::process_startScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startScan");
  }

  TabletClientService_startScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startScan", bytes);
  }

  TabletClientService_startScan_result result;
  try {
    iface_->startScan(result.success, args.tinfo, args.credentials, args.extent, args.range, args.columns, args.batchSize, args.ssiList, args.ssio, args.authorizations, args.waitForWrites, args.isolated, args.readaheadThreshold, args.samplerConfig, args.batchTimeOut, args.classLoaderContext, args.executionHints);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (NotServingTabletException &nste) {
    result.nste = nste;
    result.__isset.nste = true;
  } catch (TooManyFilesException &tmfe) {
    result.tmfe = tmfe;
    result.__isset.tmfe = true;
  } catch (TSampleNotPresentException &tsnpe) {
    result.tsnpe = tsnpe;
    result.__isset.tsnpe = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startScan");
  }

  oprot->writeMessageBegin("startScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startScan", bytes);
  }
}

void TabletClientServiceProcessor::process_continueScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.continueScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.continueScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.continueScan");
  }

  TabletClientService_continueScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.continueScan", bytes);
  }

  TabletClientService_continueScan_result result;
  try {
    iface_->continueScan(result.success, args.tinfo, args.scanID);
    result.__isset.success = true;
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (NotServingTabletException &nste) {
    result.nste = nste;
    result.__isset.nste = true;
  } catch (TooManyFilesException &tmfe) {
    result.tmfe = tmfe;
    result.__isset.tmfe = true;
  } catch (TSampleNotPresentException &tsnpe) {
    result.tsnpe = tsnpe;
    result.__isset.tsnpe = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.continueScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("continueScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.continueScan");
  }

  oprot->writeMessageBegin("continueScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.continueScan", bytes);
  }
}

void TabletClientServiceProcessor::process_closeScan(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.closeScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.closeScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.closeScan");
  }

  TabletClientService_closeScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.closeScan", bytes);
  }

  try {
    iface_->closeScan(args.tinfo, args.scanID);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.closeScan");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.closeScan");
  }

  return;
}

void TabletClientServiceProcessor::process_startMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startMultiScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startMultiScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startMultiScan");
  }

  TabletClientService_startMultiScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startMultiScan", bytes);
  }

  TabletClientService_startMultiScan_result result;
  try {
    iface_->startMultiScan(result.success, args.tinfo, args.credentials, args.batch, args.columns, args.ssiList, args.ssio, args.authorizations, args.waitForWrites, args.samplerConfig, args.batchTimeOut, args.classLoaderContext, args.executionHints);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (TSampleNotPresentException &tsnpe) {
    result.tsnpe = tsnpe;
    result.__isset.tsnpe = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startMultiScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startMultiScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startMultiScan");
  }

  oprot->writeMessageBegin("startMultiScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startMultiScan", bytes);
  }
}

void TabletClientServiceProcessor::process_continueMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.continueMultiScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.continueMultiScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.continueMultiScan");
  }

  TabletClientService_continueMultiScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.continueMultiScan", bytes);
  }

  TabletClientService_continueMultiScan_result result;
  try {
    iface_->continueMultiScan(result.success, args.tinfo, args.scanID);
    result.__isset.success = true;
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (TSampleNotPresentException &tsnpe) {
    result.tsnpe = tsnpe;
    result.__isset.tsnpe = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.continueMultiScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("continueMultiScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.continueMultiScan");
  }

  oprot->writeMessageBegin("continueMultiScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.continueMultiScan", bytes);
  }
}

void TabletClientServiceProcessor::process_closeMultiScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.closeMultiScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.closeMultiScan");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.closeMultiScan");
  }

  TabletClientService_closeMultiScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.closeMultiScan", bytes);
  }

  TabletClientService_closeMultiScan_result result;
  try {
    iface_->closeMultiScan(args.tinfo, args.scanID);
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.closeMultiScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeMultiScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.closeMultiScan");
  }

  oprot->writeMessageBegin("closeMultiScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.closeMultiScan", bytes);
  }
}

void TabletClientServiceProcessor::process_startUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startUpdate");
  }

  TabletClientService_startUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startUpdate", bytes);
  }

  TabletClientService_startUpdate_result result;
  try {
    result.success = iface_->startUpdate(args.tinfo, args.credentials, args.durability);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startUpdate");
  }

  oprot->writeMessageBegin("startUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startUpdate", bytes);
  }
}

void TabletClientServiceProcessor::process_applyUpdates(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.applyUpdates", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.applyUpdates");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.applyUpdates");
  }

  TabletClientService_applyUpdates_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.applyUpdates", bytes);
  }

  try {
    iface_->applyUpdates(args.tinfo, args.updateID, args.keyExtent, args.mutations);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.applyUpdates");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.applyUpdates");
  }

  return;
}

void TabletClientServiceProcessor::process_closeUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.closeUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.closeUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.closeUpdate");
  }

  TabletClientService_closeUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.closeUpdate", bytes);
  }

  TabletClientService_closeUpdate_result result;
  try {
    iface_->closeUpdate(result.success, args.tinfo, args.updateID);
    result.__isset.success = true;
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.closeUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.closeUpdate");
  }

  oprot->writeMessageBegin("closeUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.closeUpdate", bytes);
  }
}

void TabletClientServiceProcessor::process_update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.update");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.update");
  }

  TabletClientService_update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.update", bytes);
  }

  TabletClientService_update_result result;
  try {
    iface_->update(args.tinfo, args.credentials, args.keyExtent, args.mutation, args.durability);
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (NotServingTabletException &nste) {
    result.nste = nste;
    result.__isset.nste = true;
  } catch (ConstraintViolationException &cve) {
    result.cve = cve;
    result.__isset.cve = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.update");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("update", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.update");
  }

  oprot->writeMessageBegin("update", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.update", bytes);
  }
}

void TabletClientServiceProcessor::process_startConditionalUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startConditionalUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startConditionalUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startConditionalUpdate");
  }

  TabletClientService_startConditionalUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startConditionalUpdate", bytes);
  }

  TabletClientService_startConditionalUpdate_result result;
  try {
    iface_->startConditionalUpdate(result.success, args.tinfo, args.credentials, args.authorizations, args.tableID, args.durability, args.classLoaderContext);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startConditionalUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startConditionalUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startConditionalUpdate");
  }

  oprot->writeMessageBegin("startConditionalUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startConditionalUpdate", bytes);
  }
}

void TabletClientServiceProcessor::process_conditionalUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.conditionalUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.conditionalUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.conditionalUpdate");
  }

  TabletClientService_conditionalUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.conditionalUpdate", bytes);
  }

  TabletClientService_conditionalUpdate_result result;
  try {
    iface_->conditionalUpdate(result.success, args.tinfo, args.sessID, args.mutations, args.symbols);
    result.__isset.success = true;
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.conditionalUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("conditionalUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.conditionalUpdate");
  }

  oprot->writeMessageBegin("conditionalUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.conditionalUpdate", bytes);
  }
}

void TabletClientServiceProcessor::process_invalidateConditionalUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.invalidateConditionalUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.invalidateConditionalUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.invalidateConditionalUpdate");
  }

  TabletClientService_invalidateConditionalUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.invalidateConditionalUpdate", bytes);
  }

  TabletClientService_invalidateConditionalUpdate_result result;
  try {
    iface_->invalidateConditionalUpdate(args.tinfo, args.sessID);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.invalidateConditionalUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("invalidateConditionalUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.invalidateConditionalUpdate");
  }

  oprot->writeMessageBegin("invalidateConditionalUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.invalidateConditionalUpdate", bytes);
  }
}

void TabletClientServiceProcessor::process_closeConditionalUpdate(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.closeConditionalUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.closeConditionalUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.closeConditionalUpdate");
  }

  TabletClientService_closeConditionalUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.closeConditionalUpdate", bytes);
  }

  try {
    iface_->closeConditionalUpdate(args.tinfo, args.sessID);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.closeConditionalUpdate");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.closeConditionalUpdate");
  }

  return;
}

void TabletClientServiceProcessor::process_bulkImport(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.bulkImport", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.bulkImport");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.bulkImport");
  }

  TabletClientService_bulkImport_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.bulkImport", bytes);
  }

  TabletClientService_bulkImport_result result;
  try {
    iface_->bulkImport(result.success, args.tinfo, args.credentials, args.tid, args.files, args.setTime);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.bulkImport");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bulkImport", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.bulkImport");
  }

  oprot->writeMessageBegin("bulkImport", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.bulkImport", bytes);
  }
}

void TabletClientServiceProcessor::process_loadFiles(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.loadFiles", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.loadFiles");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.loadFiles");
  }

  TabletClientService_loadFiles_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.loadFiles", bytes);
  }

  try {
    iface_->loadFiles(args.tinfo, args.credentials, args.tid, args.dir, args.files, args.setTime);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.loadFiles");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.loadFiles");
  }

  return;
}

void TabletClientServiceProcessor::process_splitTablet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.splitTablet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.splitTablet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.splitTablet");
  }

  TabletClientService_splitTablet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.splitTablet", bytes);
  }

  TabletClientService_splitTablet_result result;
  try {
    iface_->splitTablet(args.tinfo, args.credentials, args.extent, args.splitPoint);
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (NotServingTabletException &nste) {
    result.nste = nste;
    result.__isset.nste = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.splitTablet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("splitTablet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.splitTablet");
  }

  oprot->writeMessageBegin("splitTablet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.splitTablet", bytes);
  }
}

void TabletClientServiceProcessor::process_loadTablet(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.loadTablet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.loadTablet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.loadTablet");
  }

  TabletClientService_loadTablet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.loadTablet", bytes);
  }

  try {
    iface_->loadTablet(args.tinfo, args.credentials, args.lock, args.extent);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.loadTablet");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.loadTablet");
  }

  return;
}

void TabletClientServiceProcessor::process_unloadTablet(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.unloadTablet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.unloadTablet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.unloadTablet");
  }

  TabletClientService_unloadTablet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.unloadTablet", bytes);
  }

  try {
    iface_->unloadTablet(args.tinfo, args.credentials, args.lock, args.extent, args.goal, args.requestTime);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.unloadTablet");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.unloadTablet");
  }

  return;
}

void TabletClientServiceProcessor::process_flush(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.flush", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.flush");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.flush");
  }

  TabletClientService_flush_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.flush", bytes);
  }

  try {
    iface_->flush(args.tinfo, args.credentials, args.lock, args.tableId, args.startRow, args.endRow);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.flush");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.flush");
  }

  return;
}

void TabletClientServiceProcessor::process_flushTablet(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.flushTablet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.flushTablet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.flushTablet");
  }

  TabletClientService_flushTablet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.flushTablet", bytes);
  }

  try {
    iface_->flushTablet(args.tinfo, args.credentials, args.lock, args.extent);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.flushTablet");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.flushTablet");
  }

  return;
}

void TabletClientServiceProcessor::process_chop(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.chop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.chop");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.chop");
  }

  TabletClientService_chop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.chop", bytes);
  }

  try {
    iface_->chop(args.tinfo, args.credentials, args.lock, args.extent);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.chop");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.chop");
  }

  return;
}

void TabletClientServiceProcessor::process_compact(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.compact", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.compact");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.compact");
  }

  TabletClientService_compact_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.compact", bytes);
  }

  try {
    iface_->compact(args.tinfo, args.credentials, args.lock, args.tableId, args.startRow, args.endRow);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.compact");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.compact");
  }

  return;
}

void TabletClientServiceProcessor::process_getTabletServerStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getTabletServerStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getTabletServerStatus");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getTabletServerStatus");
  }

  TabletClientService_getTabletServerStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getTabletServerStatus", bytes);
  }

  TabletClientService_getTabletServerStatus_result result;
  try {
    iface_->getTabletServerStatus(result.success, args.tinfo, args.credentials);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getTabletServerStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTabletServerStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getTabletServerStatus");
  }

  oprot->writeMessageBegin("getTabletServerStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getTabletServerStatus", bytes);
  }
}

void TabletClientServiceProcessor::process_getTabletStats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getTabletStats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getTabletStats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getTabletStats");
  }

  TabletClientService_getTabletStats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getTabletStats", bytes);
  }

  TabletClientService_getTabletStats_result result;
  try {
    iface_->getTabletStats(result.success, args.tinfo, args.credentials, args.tableId);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getTabletStats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTabletStats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getTabletStats");
  }

  oprot->writeMessageBegin("getTabletStats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getTabletStats", bytes);
  }
}

void TabletClientServiceProcessor::process_getHistoricalStats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getHistoricalStats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getHistoricalStats");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getHistoricalStats");
  }

  TabletClientService_getHistoricalStats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getHistoricalStats", bytes);
  }

  TabletClientService_getHistoricalStats_result result;
  try {
    iface_->getHistoricalStats(result.success, args.tinfo, args.credentials);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getHistoricalStats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getHistoricalStats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getHistoricalStats");
  }

  oprot->writeMessageBegin("getHistoricalStats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getHistoricalStats", bytes);
  }
}

void TabletClientServiceProcessor::process_halt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.halt", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.halt");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.halt");
  }

  TabletClientService_halt_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.halt", bytes);
  }

  TabletClientService_halt_result result;
  try {
    iface_->halt(args.tinfo, args.credentials, args.lock);
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.halt");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("halt", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.halt");
  }

  oprot->writeMessageBegin("halt", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.halt", bytes);
  }
}

void TabletClientServiceProcessor::process_fastHalt(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.fastHalt", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.fastHalt");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.fastHalt");
  }

  TabletClientService_fastHalt_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.fastHalt", bytes);
  }

  try {
    iface_->fastHalt(args.tinfo, args.credentials, args.lock);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.fastHalt");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.fastHalt");
  }

  return;
}

void TabletClientServiceProcessor::process_getActiveScans(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getActiveScans", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getActiveScans");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getActiveScans");
  }

  TabletClientService_getActiveScans_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getActiveScans", bytes);
  }

  TabletClientService_getActiveScans_result result;
  try {
    iface_->getActiveScans(result.success, args.tinfo, args.credentials);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getActiveScans");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getActiveScans");
  }

  oprot->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getActiveScans", bytes);
  }
}

void TabletClientServiceProcessor::process_getActiveCompactions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getActiveCompactions", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getActiveCompactions");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getActiveCompactions");
  }

  TabletClientService_getActiveCompactions_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getActiveCompactions", bytes);
  }

  TabletClientService_getActiveCompactions_result result;
  try {
    iface_->getActiveCompactions(result.success, args.tinfo, args.credentials);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getActiveCompactions");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getActiveCompactions");
  }

  oprot->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getActiveCompactions", bytes);
  }
}

void TabletClientServiceProcessor::process_removeLogs(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.removeLogs", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.removeLogs");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.removeLogs");
  }

  TabletClientService_removeLogs_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.removeLogs", bytes);
  }

  try {
    iface_->removeLogs(args.tinfo, args.credentials, args.filenames);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.removeLogs");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "TabletClientService.removeLogs");
  }

  return;
}

void TabletClientServiceProcessor::process_getActiveLogs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.getActiveLogs", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.getActiveLogs");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.getActiveLogs");
  }

  TabletClientService_getActiveLogs_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.getActiveLogs", bytes);
  }

  TabletClientService_getActiveLogs_result result;
  try {
    iface_->getActiveLogs(result.success, args.tinfo, args.credentials);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.getActiveLogs");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getActiveLogs", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.getActiveLogs");
  }

  oprot->writeMessageBegin("getActiveLogs", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.getActiveLogs", bytes);
  }
}

void TabletClientServiceProcessor::process_startGetSummaries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startGetSummaries", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startGetSummaries");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startGetSummaries");
  }

  TabletClientService_startGetSummaries_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startGetSummaries", bytes);
  }

  TabletClientService_startGetSummaries_result result;
  try {
    iface_->startGetSummaries(result.success, args.tinfo, args.credentials, args.request);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftTableOperationException &tope) {
    result.tope = tope;
    result.__isset.tope = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startGetSummaries");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startGetSummaries", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startGetSummaries");
  }

  oprot->writeMessageBegin("startGetSummaries", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startGetSummaries", bytes);
  }
}

void TabletClientServiceProcessor::process_startGetSummariesForPartition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startGetSummariesForPartition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startGetSummariesForPartition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startGetSummariesForPartition");
  }

  TabletClientService_startGetSummariesForPartition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startGetSummariesForPartition", bytes);
  }

  TabletClientService_startGetSummariesForPartition_result result;
  try {
    iface_->startGetSummariesForPartition(result.success, args.tinfo, args.credentials, args.request, args.modulus, args.remainder);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startGetSummariesForPartition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startGetSummariesForPartition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startGetSummariesForPartition");
  }

  oprot->writeMessageBegin("startGetSummariesForPartition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startGetSummariesForPartition", bytes);
  }
}

void TabletClientServiceProcessor::process_startGetSummariesFromFiles(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.startGetSummariesFromFiles", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.startGetSummariesFromFiles");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.startGetSummariesFromFiles");
  }

  TabletClientService_startGetSummariesFromFiles_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.startGetSummariesFromFiles", bytes);
  }

  TabletClientService_startGetSummariesFromFiles_result result;
  try {
    iface_->startGetSummariesFromFiles(result.success, args.tinfo, args.credentials, args.request, args.files);
    result.__isset.success = true;
  } catch ( ::org::apache::accumulov2::core::clientImpl::thrift::ThriftSecurityException &sec) {
    result.sec = sec;
    result.__isset.sec = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.startGetSummariesFromFiles");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("startGetSummariesFromFiles", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.startGetSummariesFromFiles");
  }

  oprot->writeMessageBegin("startGetSummariesFromFiles", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.startGetSummariesFromFiles", bytes);
  }
}

void TabletClientServiceProcessor::process_contiuneGetSummaries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TabletClientService.contiuneGetSummaries", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TabletClientService.contiuneGetSummaries");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TabletClientService.contiuneGetSummaries");
  }

  TabletClientService_contiuneGetSummaries_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TabletClientService.contiuneGetSummaries", bytes);
  }

  TabletClientService_contiuneGetSummaries_result result;
  try {
    iface_->contiuneGetSummaries(result.success, args.tinfo, args.sessionId);
    result.__isset.success = true;
  } catch (NoSuchScanIDException &nssi) {
    result.nssi = nssi;
    result.__isset.nssi = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TabletClientService.contiuneGetSummaries");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("contiuneGetSummaries", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TabletClientService.contiuneGetSummaries");
  }

  oprot->writeMessageBegin("contiuneGetSummaries", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TabletClientService.contiuneGetSummaries", bytes);
  }
}

std::shared_ptr< ::apache::thrift::TProcessor > TabletClientServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< TabletClientServiceIfFactory > cleanup(handlerFactory_);
  std::shared_ptr< TabletClientServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  std::shared_ptr< ::apache::thrift::TProcessor > processor(new TabletClientServiceProcessor(handler));
  return processor;
}

void TabletClientServiceConcurrentClient::startScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialScan& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TRange& range, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const int32_t batchSize, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated, const int64_t readaheadThreshold, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t seqid = send_startScan(tinfo, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations, waitForWrites, isolated, readaheadThreshold, samplerConfig, batchTimeOut, classLoaderContext, executionHints);
  recv_startScan(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TRange& range, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const int32_t batchSize, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const bool isolated, const int64_t readaheadThreshold, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startScan_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.extent = &extent;
  args.range = &range;
  args.columns = &columns;
  args.batchSize = &batchSize;
  args.ssiList = &ssiList;
  args.ssio = &ssio;
  args.authorizations = &authorizations;
  args.waitForWrites = &waitForWrites;
  args.isolated = &isolated;
  args.readaheadThreshold = &readaheadThreshold;
  args.samplerConfig = &samplerConfig;
  args.batchTimeOut = &batchTimeOut;
  args.classLoaderContext = &classLoaderContext;
  args.executionHints = &executionHints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialScan& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startScan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      if (result.__isset.nste) {
        sentry.commit();
        throw result.nste;
      }
      if (result.__isset.tmfe) {
        sentry.commit();
        throw result.tmfe;
      }
      if (result.__isset.tsnpe) {
        sentry.commit();
        throw result.tsnpe;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startScan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::continueScan( ::org::apache::accumulov2::core::dataImpl::thrift::ScanResult& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t seqid = send_continueScan(tinfo, scanID);
  recv_continueScan(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_continueScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("continueScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_continueScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_continueScan( ::org::apache::accumulov2::core::dataImpl::thrift::ScanResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("continueScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_continueScan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      if (result.__isset.nste) {
        sentry.commit();
        throw result.nste;
      }
      if (result.__isset.tmfe) {
        sentry.commit();
        throw result.tmfe;
      }
      if (result.__isset.tsnpe) {
        sentry.commit();
        throw result.tsnpe;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "continueScan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::closeScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  send_closeScan(tinfo, scanID);
}

void TabletClientServiceConcurrentClient::send_closeScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("closeScan", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_closeScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::startMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialMultiScan& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanBatch& batch, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t seqid = send_startMultiScan(tinfo, credentials, batch, columns, ssiList, ssio, authorizations, waitForWrites, samplerConfig, batchTimeOut, classLoaderContext, executionHints);
  recv_startMultiScan(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanBatch& batch, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & columns, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & ssiList, const std::map<std::string, std::map<std::string, std::string> > & ssio, const std::vector<std::string> & authorizations, const bool waitForWrites, const TSamplerConfiguration& samplerConfig, const int64_t batchTimeOut, const std::string& classLoaderContext, const std::map<std::string, std::string> & executionHints)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.batch = &batch;
  args.columns = &columns;
  args.ssiList = &ssiList;
  args.ssio = &ssio;
  args.authorizations = &authorizations;
  args.waitForWrites = &waitForWrites;
  args.samplerConfig = &samplerConfig;
  args.batchTimeOut = &batchTimeOut;
  args.classLoaderContext = &classLoaderContext;
  args.executionHints = &executionHints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::InitialMultiScan& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startMultiScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startMultiScan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      if (result.__isset.tsnpe) {
        sentry.commit();
        throw result.tsnpe;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startMultiScan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::continueMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::MultiScanResult& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t seqid = send_continueMultiScan(tinfo, scanID);
  recv_continueMultiScan(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_continueMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("continueMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_continueMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_continueMultiScan( ::org::apache::accumulov2::core::dataImpl::thrift::MultiScanResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("continueMultiScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_continueMultiScan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      if (result.__isset.tsnpe) {
        sentry.commit();
        throw result.tsnpe;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "continueMultiScan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::closeMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t seqid = send_closeMultiScan(tinfo, scanID);
  recv_closeMultiScan(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_closeMultiScan(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::ScanID scanID)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("closeMultiScan", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_closeMultiScan_pargs args;
  args.tinfo = &tinfo;
  args.scanID = &scanID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_closeMultiScan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("closeMultiScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_closeMultiScan_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID TabletClientServiceConcurrentClient::startUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const TDurability::type durability)
{
  int32_t seqid = send_startUpdate(tinfo, credentials, durability);
  return recv_startUpdate(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const TDurability::type durability)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startUpdate_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.durability = &durability;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID TabletClientServiceConcurrentClient::recv_startUpdate(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startUpdate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID _return;
      TabletClientService_startUpdate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startUpdate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::applyUpdates(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> & mutations)
{
  send_applyUpdates(tinfo, updateID, keyExtent, mutations);
}

void TabletClientServiceConcurrentClient::send_applyUpdates(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TMutation> & mutations)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("applyUpdates", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_applyUpdates_pargs args;
  args.tinfo = &tinfo;
  args.updateID = &updateID;
  args.keyExtent = &keyExtent;
  args.mutations = &mutations;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::closeUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::UpdateErrors& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID)
{
  int32_t seqid = send_closeUpdate(tinfo, updateID);
  recv_closeUpdate(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_closeUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID updateID)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("closeUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_closeUpdate_pargs args;
  args.tinfo = &tinfo;
  args.updateID = &updateID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_closeUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::UpdateErrors& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("closeUpdate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_closeUpdate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "closeUpdate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::update(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TMutation& mutation, const TDurability::type durability)
{
  int32_t seqid = send_update(tinfo, credentials, keyExtent, mutation, durability);
  recv_update(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_update(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& keyExtent, const  ::org::apache::accumulov2::core::dataImpl::thrift::TMutation& mutation, const TDurability::type durability)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("update", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_update_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.keyExtent = &keyExtent;
  args.mutation = &mutation;
  args.durability = &durability;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_update(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("update") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_update_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      if (result.__isset.nste) {
        sentry.commit();
        throw result.nste;
      }
      if (result.__isset.cve) {
        sentry.commit();
        throw result.cve;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::startConditionalUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalSession& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & authorizations, const std::string& tableID, const TDurability::type durability, const std::string& classLoaderContext)
{
  int32_t seqid = send_startConditionalUpdate(tinfo, credentials, authorizations, tableID, durability, classLoaderContext);
  recv_startConditionalUpdate(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & authorizations, const std::string& tableID, const TDurability::type durability, const std::string& classLoaderContext)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startConditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.authorizations = &authorizations;
  args.tableID = &tableID;
  args.durability = &durability;
  args.classLoaderContext = &classLoaderContext;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startConditionalUpdate( ::org::apache::accumulov2::core::dataImpl::thrift::TConditionalSession& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startConditionalUpdate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startConditionalUpdate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startConditionalUpdate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::conditionalUpdate(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TCMResult> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID, const  ::org::apache::accumulov2::core::dataImpl::thrift::CMBatch& mutations, const std::vector<std::string> & symbols)
{
  int32_t seqid = send_conditionalUpdate(tinfo, sessID, mutations, symbols);
  recv_conditionalUpdate(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_conditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID, const  ::org::apache::accumulov2::core::dataImpl::thrift::CMBatch& mutations, const std::vector<std::string> & symbols)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("conditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_conditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.mutations = &mutations;
  args.symbols = &symbols;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_conditionalUpdate(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TCMResult> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("conditionalUpdate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_conditionalUpdate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "conditionalUpdate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::invalidateConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  int32_t seqid = send_invalidateConditionalUpdate(tinfo, sessID);
  recv_invalidateConditionalUpdate(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_invalidateConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("invalidateConditionalUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_invalidateConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_invalidateConditionalUpdate(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("invalidateConditionalUpdate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_invalidateConditionalUpdate_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::closeConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  send_closeConditionalUpdate(tinfo, sessID);
}

void TabletClientServiceConcurrentClient::send_closeConditionalUpdate(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::dataImpl::thrift::UpdateID sessID)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("closeConditionalUpdate", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_closeConditionalUpdate_pargs args;
  args.tinfo = &tinfo;
  args.sessID = &sessID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::bulkImport(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const  ::org::apache::accumulov2::core::dataImpl::thrift::TabletFiles& files, const bool setTime)
{
  int32_t seqid = send_bulkImport(tinfo, credentials, tid, files, setTime);
  recv_bulkImport(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_bulkImport(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const  ::org::apache::accumulov2::core::dataImpl::thrift::TabletFiles& files, const bool setTime)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("bulkImport", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_bulkImport_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tid = &tid;
  args.files = &files;
  args.setTime = &setTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_bulkImport(std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bulkImport") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_bulkImport_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bulkImport failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::loadFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const std::string& dir, const std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > & files, const bool setTime)
{
  send_loadFiles(tinfo, credentials, tid, dir, files, setTime);
}

void TabletClientServiceConcurrentClient::send_loadFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const int64_t tid, const std::string& dir, const std::map< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent, std::map<std::string,  ::org::apache::accumulov2::core::dataImpl::thrift::MapFileInfo> > & files, const bool setTime)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("loadFiles", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_loadFiles_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tid = &tid;
  args.dir = &dir;
  args.files = &files;
  args.setTime = &setTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::splitTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const std::string& splitPoint)
{
  int32_t seqid = send_splitTablet(tinfo, credentials, extent, splitPoint);
  recv_splitTablet(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_splitTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const std::string& splitPoint)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("splitTablet", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_splitTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.extent = &extent;
  args.splitPoint = &splitPoint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_splitTablet(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("splitTablet") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_splitTablet_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      if (result.__isset.nste) {
        sentry.commit();
        throw result.nste;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::loadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_loadTablet(tinfo, credentials, lock, extent);
}

void TabletClientServiceConcurrentClient::send_loadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("loadTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_loadTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::unloadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const TUnloadTabletGoal::type goal, const int64_t requestTime)
{
  send_unloadTablet(tinfo, credentials, lock, extent, goal, requestTime);
}

void TabletClientServiceConcurrentClient::send_unloadTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent, const TUnloadTabletGoal::type goal, const int64_t requestTime)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("unloadTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_unloadTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.goal = &goal;
  args.requestTime = &requestTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::flush(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  send_flush(tinfo, credentials, lock, tableId, startRow, endRow);
}

void TabletClientServiceConcurrentClient::send_flush(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("flush", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_flush_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.tableId = &tableId;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::flushTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_flushTablet(tinfo, credentials, lock, extent);
}

void TabletClientServiceConcurrentClient::send_flushTablet(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("flushTablet", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_flushTablet_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::chop(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  send_chop(tinfo, credentials, lock, extent);
}

void TabletClientServiceConcurrentClient::send_chop(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& extent)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("chop", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_chop_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.extent = &extent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::compact(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  send_compact(tinfo, credentials, lock, tableId, startRow, endRow);
}

void TabletClientServiceConcurrentClient::send_compact(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock, const std::string& tableId, const std::string& startRow, const std::string& endRow)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("compact", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_compact_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.tableId = &tableId;
  args.startRow = &startRow;
  args.endRow = &endRow;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::getTabletServerStatus( ::org::apache::accumulov2::core::master::thrift::TabletServerStatus& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t seqid = send_getTabletServerStatus(tinfo, credentials);
  recv_getTabletServerStatus(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getTabletServerStatus(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getTabletServerStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getTabletServerStatus_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getTabletServerStatus( ::org::apache::accumulov2::core::master::thrift::TabletServerStatus& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getTabletServerStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getTabletServerStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTabletServerStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::getTabletStats(std::vector<TabletStats> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& tableId)
{
  int32_t seqid = send_getTabletStats(tinfo, credentials, tableId);
  recv_getTabletStats(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getTabletStats(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& tableId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getTabletStats", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getTabletStats_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.tableId = &tableId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getTabletStats(std::vector<TabletStats> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getTabletStats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getTabletStats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTabletStats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::getHistoricalStats(TabletStats& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t seqid = send_getHistoricalStats(tinfo, credentials);
  recv_getHistoricalStats(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getHistoricalStats(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getHistoricalStats", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getHistoricalStats_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getHistoricalStats(TabletStats& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getHistoricalStats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getHistoricalStats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getHistoricalStats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::halt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  int32_t seqid = send_halt(tinfo, credentials, lock);
  recv_halt(seqid);
}

int32_t TabletClientServiceConcurrentClient::send_halt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("halt", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_halt_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_halt(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("halt") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_halt_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::fastHalt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  send_fastHalt(tinfo, credentials, lock);
}

void TabletClientServiceConcurrentClient::send_fastHalt(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::string& lock)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("fastHalt", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_fastHalt_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.lock = &lock;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::getActiveScans(std::vector<ActiveScan> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t seqid = send_getActiveScans(tinfo, credentials);
  recv_getActiveScans(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getActiveScans(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getActiveScans", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveScans_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getActiveScans(std::vector<ActiveScan> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getActiveScans") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getActiveScans_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveScans failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::getActiveCompactions(std::vector<ActiveCompaction> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t seqid = send_getActiveCompactions(tinfo, credentials);
  recv_getActiveCompactions(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getActiveCompactions(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getActiveCompactions", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveCompactions_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getActiveCompactions(std::vector<ActiveCompaction> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getActiveCompactions") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getActiveCompactions_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveCompactions failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::removeLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & filenames)
{
  send_removeLogs(tinfo, credentials, filenames);
}

void TabletClientServiceConcurrentClient::send_removeLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const std::vector<std::string> & filenames)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("removeLogs", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  TabletClientService_removeLogs_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.filenames = &filenames;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void TabletClientServiceConcurrentClient::getActiveLogs(std::vector<std::string> & _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t seqid = send_getActiveLogs(tinfo, credentials);
  recv_getActiveLogs(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_getActiveLogs(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getActiveLogs", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_getActiveLogs_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_getActiveLogs(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getActiveLogs") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_getActiveLogs_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getActiveLogs failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::startGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request)
{
  int32_t seqid = send_startGetSummaries(tinfo, credentials, request);
  recv_startGetSummaries(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startGetSummaries(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startGetSummaries", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummaries_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startGetSummaries") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startGetSummaries_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      if (result.__isset.tope) {
        sentry.commit();
        throw result.tope;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummaries failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::startGetSummariesForPartition( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const int32_t modulus, const int32_t remainder)
{
  int32_t seqid = send_startGetSummariesForPartition(tinfo, credentials, request, modulus, remainder);
  recv_startGetSummariesForPartition(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startGetSummariesForPartition(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const int32_t modulus, const int32_t remainder)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startGetSummariesForPartition", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummariesForPartition_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.modulus = &modulus;
  args.remainder = &remainder;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startGetSummariesForPartition( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startGetSummariesForPartition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startGetSummariesForPartition_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummariesForPartition failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::startGetSummariesFromFiles( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > & files)
{
  int32_t seqid = send_startGetSummariesFromFiles(tinfo, credentials, request, files);
  recv_startGetSummariesFromFiles(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_startGetSummariesFromFiles(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const  ::org::apache::accumulov2::core::securityImpl::thrift::TCredentials& credentials, const  ::org::apache::accumulov2::core::dataImpl::thrift::TSummaryRequest& request, const std::map<std::string, std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TRowRange> > & files)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("startGetSummariesFromFiles", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_startGetSummariesFromFiles_pargs args;
  args.tinfo = &tinfo;
  args.credentials = &credentials;
  args.request = &request;
  args.files = &files;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_startGetSummariesFromFiles( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("startGetSummariesFromFiles") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_startGetSummariesFromFiles_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.sec) {
        sentry.commit();
        throw result.sec;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "startGetSummariesFromFiles failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TabletClientServiceConcurrentClient::contiuneGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const int64_t sessionId)
{
  int32_t seqid = send_contiuneGetSummaries(tinfo, sessionId);
  recv_contiuneGetSummaries(_return, seqid);
}

int32_t TabletClientServiceConcurrentClient::send_contiuneGetSummaries(const  ::org::apache::accumulov2::core::trace::thrift::TInfo& tinfo, const int64_t sessionId)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("contiuneGetSummaries", ::apache::thrift::protocol::T_CALL, cseqid);

  TabletClientService_contiuneGetSummaries_pargs args;
  args.tinfo = &tinfo;
  args.sessionId = &sessionId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TabletClientServiceConcurrentClient::recv_contiuneGetSummaries( ::org::apache::accumulov2::core::dataImpl::thrift::TSummaries& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("contiuneGetSummaries") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TabletClientService_contiuneGetSummaries_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.nssi) {
        sentry.commit();
        throw result.nssi;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "contiuneGetSummaries failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

}}}}}} // namespace

