/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data/extern/thriftv2/tabletserver_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace org { namespace apache { namespace accumulov2 { namespace core { namespace tabletserver { namespace thrift {

int _kScanTypeValues[] = {
  ScanType::SINGLE,
  ScanType::BATCH
};
const char* _kScanTypeNames[] = {
  "SINGLE",
  "BATCH"
};
const std::map<int, const char*> _ScanType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kScanTypeValues, _kScanTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ScanType::type& val) {
  std::map<int, const char*>::const_iterator it = _ScanType_VALUES_TO_NAMES.find(val);
  if (it != _ScanType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kScanStateValues[] = {
  ScanState::IDLE,
  ScanState::RUNNING,
  ScanState::QUEUED
};
const char* _kScanStateNames[] = {
  "IDLE",
  "RUNNING",
  "QUEUED"
};
const std::map<int, const char*> _ScanState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kScanStateValues, _kScanStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ScanState::type& val) {
  std::map<int, const char*>::const_iterator it = _ScanState_VALUES_TO_NAMES.find(val);
  if (it != _ScanState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MERGE,
  CompactionType::MAJOR,
  CompactionType::FULL
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MERGE",
  "MAJOR",
  "FULL"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kCompactionReasonValues[] = {
  CompactionReason::USER,
  CompactionReason::SYSTEM,
  CompactionReason::CHOP,
  CompactionReason::IDLE,
  CompactionReason::CLOSE
};
const char* _kCompactionReasonNames[] = {
  "USER",
  "SYSTEM",
  "CHOP",
  "IDLE",
  "CLOSE"
};
const std::map<int, const char*> _CompactionReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCompactionReasonValues, _kCompactionReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CompactionReason::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionReason_VALUES_TO_NAMES.find(val);
  if (it != _CompactionReason_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDurabilityValues[] = {
  TDurability::DEFAULT,
  TDurability::SYNC,
  TDurability::FLUSH,
  TDurability::LOG,
  TDurability::NONE
};
const char* _kTDurabilityNames[] = {
  "DEFAULT",
  "SYNC",
  "FLUSH",
  "LOG",
  "NONE"
};
const std::map<int, const char*> _TDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDurabilityValues, _kTDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDurability::type& val) {
  std::map<int, const char*>::const_iterator it = _TDurability_VALUES_TO_NAMES.find(val);
  if (it != _TDurability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTUnloadTabletGoalValues[] = {
  TUnloadTabletGoal::UNKNOWN,
  TUnloadTabletGoal::UNASSIGNED,
  TUnloadTabletGoal::SUSPENDED,
  TUnloadTabletGoal::DELETED
};
const char* _kTUnloadTabletGoalNames[] = {
  "UNKNOWN",
  "UNASSIGNED",
  "SUSPENDED",
  "DELETED"
};
const std::map<int, const char*> _TUnloadTabletGoal_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTUnloadTabletGoalValues, _kTUnloadTabletGoalNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TUnloadTabletGoal::type& val) {
  std::map<int, const char*>::const_iterator it = _TUnloadTabletGoal_VALUES_TO_NAMES.find(val);
  if (it != _TUnloadTabletGoal_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


NotServingTabletException::~NotServingTabletException() throw() {
}


void NotServingTabletException::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}
std::ostream& operator<<(std::ostream& out, const NotServingTabletException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotServingTabletException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotServingTabletException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotServingTabletException");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotServingTabletException &a, NotServingTabletException &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.__isset, b.__isset);
}

NotServingTabletException::NotServingTabletException(const NotServingTabletException& other0) : TException() {
  extent = other0.extent;
  __isset = other0.__isset;
}
NotServingTabletException& NotServingTabletException::operator=(const NotServingTabletException& other1) {
  extent = other1.extent;
  __isset = other1.__isset;
  return *this;
}
void NotServingTabletException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotServingTabletException(";
  out << "extent=" << to_string(extent);
  out << ")";
}

const char* NotServingTabletException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NotServingTabletException";
  }
}


TooManyFilesException::~TooManyFilesException() throw() {
}


void TooManyFilesException::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}
std::ostream& operator<<(std::ostream& out, const TooManyFilesException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TooManyFilesException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TooManyFilesException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TooManyFilesException");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TooManyFilesException &a, TooManyFilesException &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.__isset, b.__isset);
}

TooManyFilesException::TooManyFilesException(const TooManyFilesException& other2) : TException() {
  extent = other2.extent;
  __isset = other2.__isset;
}
TooManyFilesException& TooManyFilesException::operator=(const TooManyFilesException& other3) {
  extent = other3.extent;
  __isset = other3.__isset;
  return *this;
}
void TooManyFilesException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TooManyFilesException(";
  out << "extent=" << to_string(extent);
  out << ")";
}

const char* TooManyFilesException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TooManyFilesException";
  }
}


TSampleNotPresentException::~TSampleNotPresentException() throw() {
}


void TSampleNotPresentException::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}
std::ostream& operator<<(std::ostream& out, const TSampleNotPresentException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSampleNotPresentException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSampleNotPresentException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSampleNotPresentException");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSampleNotPresentException &a, TSampleNotPresentException &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.__isset, b.__isset);
}

TSampleNotPresentException::TSampleNotPresentException(const TSampleNotPresentException& other4) : TException() {
  extent = other4.extent;
  __isset = other4.__isset;
}
TSampleNotPresentException& TSampleNotPresentException::operator=(const TSampleNotPresentException& other5) {
  extent = other5.extent;
  __isset = other5.__isset;
  return *this;
}
void TSampleNotPresentException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSampleNotPresentException(";
  out << "extent=" << to_string(extent);
  out << ")";
}

const char* TSampleNotPresentException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TSampleNotPresentException";
  }
}


NoSuchScanIDException::~NoSuchScanIDException() throw() {
}

std::ostream& operator<<(std::ostream& out, const NoSuchScanIDException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchScanIDException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchScanIDException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchScanIDException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchScanIDException &a, NoSuchScanIDException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NoSuchScanIDException::NoSuchScanIDException(const NoSuchScanIDException& other6) : TException() {
  (void) other6;
}
NoSuchScanIDException& NoSuchScanIDException::operator=(const NoSuchScanIDException& other7) {
  (void) other7;
  return *this;
}
void NoSuchScanIDException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchScanIDException(";
  out << ")";
}

const char* NoSuchScanIDException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchScanIDException";
  }
}


ConstraintViolationException::~ConstraintViolationException() throw() {
}


void ConstraintViolationException::__set_violationSummaries(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConstraintViolationSummary> & val) {
  this->violationSummaries = val;
}
std::ostream& operator<<(std::ostream& out, const ConstraintViolationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConstraintViolationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->violationSummaries.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->violationSummaries.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->violationSummaries[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.violationSummaries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConstraintViolationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConstraintViolationException");

  xfer += oprot->writeFieldBegin("violationSummaries", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->violationSummaries.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TConstraintViolationSummary> ::const_iterator _iter13;
    for (_iter13 = this->violationSummaries.begin(); _iter13 != this->violationSummaries.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConstraintViolationException &a, ConstraintViolationException &b) {
  using ::std::swap;
  swap(a.violationSummaries, b.violationSummaries);
  swap(a.__isset, b.__isset);
}

ConstraintViolationException::ConstraintViolationException(const ConstraintViolationException& other14) : TException() {
  violationSummaries = other14.violationSummaries;
  __isset = other14.__isset;
}
ConstraintViolationException& ConstraintViolationException::operator=(const ConstraintViolationException& other15) {
  violationSummaries = other15.violationSummaries;
  __isset = other15.__isset;
  return *this;
}
void ConstraintViolationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConstraintViolationException(";
  out << "violationSummaries=" << to_string(violationSummaries);
  out << ")";
}

const char* ConstraintViolationException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ConstraintViolationException";
  }
}


ActionStats::~ActionStats() throw() {
}


void ActionStats::__set_status(const int32_t val) {
  this->status = val;
}

void ActionStats::__set_elapsed(const double val) {
  this->elapsed = val;
}

void ActionStats::__set_num(const int32_t val) {
  this->num = val;
}

void ActionStats::__set_count(const int64_t val) {
  this->count = val;
}

void ActionStats::__set_sumDev(const double val) {
  this->sumDev = val;
}

void ActionStats::__set_fail(const int32_t val) {
  this->fail = val;
}

void ActionStats::__set_queueTime(const double val) {
  this->queueTime = val;
}

void ActionStats::__set_queueSumDev(const double val) {
  this->queueSumDev = val;
}
std::ostream& operator<<(std::ostream& out, const ActionStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ActionStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sumDev);
          this->__isset.sumDev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fail);
          this->__isset.fail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queueTime);
          this->__isset.queueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queueSumDev);
          this->__isset.queueSumDev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionStats");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sumDev", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->sumDev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fail", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->fail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueTime", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->queueTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueSumDev", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->queueSumDev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionStats &a, ActionStats &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.elapsed, b.elapsed);
  swap(a.num, b.num);
  swap(a.count, b.count);
  swap(a.sumDev, b.sumDev);
  swap(a.fail, b.fail);
  swap(a.queueTime, b.queueTime);
  swap(a.queueSumDev, b.queueSumDev);
  swap(a.__isset, b.__isset);
}

ActionStats::ActionStats(const ActionStats& other16) {
  status = other16.status;
  elapsed = other16.elapsed;
  num = other16.num;
  count = other16.count;
  sumDev = other16.sumDev;
  fail = other16.fail;
  queueTime = other16.queueTime;
  queueSumDev = other16.queueSumDev;
  __isset = other16.__isset;
}
ActionStats& ActionStats::operator=(const ActionStats& other17) {
  status = other17.status;
  elapsed = other17.elapsed;
  num = other17.num;
  count = other17.count;
  sumDev = other17.sumDev;
  fail = other17.fail;
  queueTime = other17.queueTime;
  queueSumDev = other17.queueSumDev;
  __isset = other17.__isset;
  return *this;
}
void ActionStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionStats(";
  out << "status=" << to_string(status);
  out << ", " << "elapsed=" << to_string(elapsed);
  out << ", " << "num=" << to_string(num);
  out << ", " << "count=" << to_string(count);
  out << ", " << "sumDev=" << to_string(sumDev);
  out << ", " << "fail=" << to_string(fail);
  out << ", " << "queueTime=" << to_string(queueTime);
  out << ", " << "queueSumDev=" << to_string(queueSumDev);
  out << ")";
}


TabletStats::~TabletStats() throw() {
}


void TabletStats::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}

void TabletStats::__set_majors(const ActionStats& val) {
  this->majors = val;
}

void TabletStats::__set_minors(const ActionStats& val) {
  this->minors = val;
}

void TabletStats::__set_splits(const ActionStats& val) {
  this->splits = val;
}

void TabletStats::__set_numEntries(const int64_t val) {
  this->numEntries = val;
}

void TabletStats::__set_ingestRate(const double val) {
  this->ingestRate = val;
}

void TabletStats::__set_queryRate(const double val) {
  this->queryRate = val;
}

void TabletStats::__set_splitCreationTime(const int64_t val) {
  this->splitCreationTime = val;
}
std::ostream& operator<<(std::ostream& out, const TabletStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TabletStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->majors.read(iprot);
          this->__isset.majors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->minors.read(iprot);
          this->__isset.minors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->splits.read(iprot);
          this->__isset.splits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numEntries);
          this->__isset.numEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ingestRate);
          this->__isset.ingestRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queryRate);
          this->__isset.queryRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->splitCreationTime);
          this->__isset.splitCreationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletStats");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("majors", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->majors.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minors", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->minors.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splits", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->splits.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numEntries", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->numEntries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ingestRate", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->ingestRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryRate", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->queryRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splitCreationTime", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->splitCreationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TabletStats &a, TabletStats &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.majors, b.majors);
  swap(a.minors, b.minors);
  swap(a.splits, b.splits);
  swap(a.numEntries, b.numEntries);
  swap(a.ingestRate, b.ingestRate);
  swap(a.queryRate, b.queryRate);
  swap(a.splitCreationTime, b.splitCreationTime);
  swap(a.__isset, b.__isset);
}

TabletStats::TabletStats(const TabletStats& other18) {
  extent = other18.extent;
  majors = other18.majors;
  minors = other18.minors;
  splits = other18.splits;
  numEntries = other18.numEntries;
  ingestRate = other18.ingestRate;
  queryRate = other18.queryRate;
  splitCreationTime = other18.splitCreationTime;
  __isset = other18.__isset;
}
TabletStats& TabletStats::operator=(const TabletStats& other19) {
  extent = other19.extent;
  majors = other19.majors;
  minors = other19.minors;
  splits = other19.splits;
  numEntries = other19.numEntries;
  ingestRate = other19.ingestRate;
  queryRate = other19.queryRate;
  splitCreationTime = other19.splitCreationTime;
  __isset = other19.__isset;
  return *this;
}
void TabletStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TabletStats(";
  out << "extent=" << to_string(extent);
  out << ", " << "majors=" << to_string(majors);
  out << ", " << "minors=" << to_string(minors);
  out << ", " << "splits=" << to_string(splits);
  out << ", " << "numEntries=" << to_string(numEntries);
  out << ", " << "ingestRate=" << to_string(ingestRate);
  out << ", " << "queryRate=" << to_string(queryRate);
  out << ", " << "splitCreationTime=" << to_string(splitCreationTime);
  out << ")";
}


ActiveScan::~ActiveScan() throw() {
}


void ActiveScan::__set_client(const std::string& val) {
  this->client = val;
}

void ActiveScan::__set_user(const std::string& val) {
  this->user = val;
}

void ActiveScan::__set_tableId(const std::string& val) {
  this->tableId = val;
}

void ActiveScan::__set_age(const int64_t val) {
  this->age = val;
}

void ActiveScan::__set_idleTime(const int64_t val) {
  this->idleTime = val;
}

void ActiveScan::__set_type(const ScanType::type val) {
  this->type = val;
}

void ActiveScan::__set_state(const ScanState::type val) {
  this->state = val;
}

void ActiveScan::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}

void ActiveScan::__set_columns(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> & val) {
  this->columns = val;
}

void ActiveScan::__set_ssiList(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & val) {
  this->ssiList = val;
}

void ActiveScan::__set_ssio(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->ssio = val;
}

void ActiveScan::__set_authorizations(const std::vector<std::string> & val) {
  this->authorizations = val;
}

void ActiveScan::__set_scanId(const int64_t val) {
  this->scanId = val;
__isset.scanId = true;
}

void ActiveScan::__set_classLoaderContext(const std::string& val) {
  this->classLoaderContext = val;
}
std::ostream& operator<<(std::ostream& out, const ActiveScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ActiveScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client);
          this->__isset.client = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->idleTime);
          this->__isset.idleTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->type = (ScanType::type)ecast20;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->state = (ScanState::type)ecast21;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->columns.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->columns[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ssiList.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->ssiList.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->ssiList[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ssiList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ssio.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              std::string _key37;
              xfer += iprot->readString(_key37);
              std::map<std::string, std::string> & _val38 = this->ssio[_key37];
              {
                _val38.clear();
                uint32_t _size39;
                ::apache::thrift::protocol::TType _ktype40;
                ::apache::thrift::protocol::TType _vtype41;
                xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
                uint32_t _i43;
                for (_i43 = 0; _i43 < _size39; ++_i43)
                {
                  std::string _key44;
                  xfer += iprot->readString(_key44);
                  std::string& _val45 = _val38[_key44];
                  xfer += iprot->readString(_val45);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ssio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->authorizations.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += iprot->readBinary(this->authorizations[_i50]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanId);
          this->__isset.scanId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classLoaderContext);
          this->__isset.classLoaderContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActiveScan");

  xfer += oprot->writeFieldBegin("client", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->client);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idleTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->idleTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TColumn> ::const_iterator _iter51;
    for (_iter51 = this->columns.begin(); _iter51 != this->columns.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ssiList.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter52;
    for (_iter52 = this->ssiList.begin(); _iter52 != this->ssiList.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 12);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->ssio.size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter53;
    for (_iter53 = this->ssio.begin(); _iter53 != this->ssio.end(); ++_iter53)
    {
      xfer += oprot->writeString(_iter53->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter53->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter54;
        for (_iter54 = _iter53->second.begin(); _iter54 != _iter53->second.end(); ++_iter54)
        {
          xfer += oprot->writeString(_iter54->first);
          xfer += oprot->writeString(_iter54->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter55;
    for (_iter55 = this->authorizations.begin(); _iter55 != this->authorizations.end(); ++_iter55)
    {
      xfer += oprot->writeBinary((*_iter55));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.scanId) {
    xfer += oprot->writeFieldBegin("scanId", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->scanId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("classLoaderContext", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->classLoaderContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveScan &a, ActiveScan &b) {
  using ::std::swap;
  swap(a.client, b.client);
  swap(a.user, b.user);
  swap(a.tableId, b.tableId);
  swap(a.age, b.age);
  swap(a.idleTime, b.idleTime);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.extent, b.extent);
  swap(a.columns, b.columns);
  swap(a.ssiList, b.ssiList);
  swap(a.ssio, b.ssio);
  swap(a.authorizations, b.authorizations);
  swap(a.scanId, b.scanId);
  swap(a.classLoaderContext, b.classLoaderContext);
  swap(a.__isset, b.__isset);
}

ActiveScan::ActiveScan(const ActiveScan& other56) {
  client = other56.client;
  user = other56.user;
  tableId = other56.tableId;
  age = other56.age;
  idleTime = other56.idleTime;
  type = other56.type;
  state = other56.state;
  extent = other56.extent;
  columns = other56.columns;
  ssiList = other56.ssiList;
  ssio = other56.ssio;
  authorizations = other56.authorizations;
  scanId = other56.scanId;
  classLoaderContext = other56.classLoaderContext;
  __isset = other56.__isset;
}
ActiveScan& ActiveScan::operator=(const ActiveScan& other57) {
  client = other57.client;
  user = other57.user;
  tableId = other57.tableId;
  age = other57.age;
  idleTime = other57.idleTime;
  type = other57.type;
  state = other57.state;
  extent = other57.extent;
  columns = other57.columns;
  ssiList = other57.ssiList;
  ssio = other57.ssio;
  authorizations = other57.authorizations;
  scanId = other57.scanId;
  classLoaderContext = other57.classLoaderContext;
  __isset = other57.__isset;
  return *this;
}
void ActiveScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActiveScan(";
  out << "client=" << to_string(client);
  out << ", " << "user=" << to_string(user);
  out << ", " << "tableId=" << to_string(tableId);
  out << ", " << "age=" << to_string(age);
  out << ", " << "idleTime=" << to_string(idleTime);
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "extent=" << to_string(extent);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "ssiList=" << to_string(ssiList);
  out << ", " << "ssio=" << to_string(ssio);
  out << ", " << "authorizations=" << to_string(authorizations);
  out << ", " << "scanId="; (__isset.scanId ? (out << to_string(scanId)) : (out << "<null>"));
  out << ", " << "classLoaderContext=" << to_string(classLoaderContext);
  out << ")";
}


ActiveCompaction::~ActiveCompaction() throw() {
}


void ActiveCompaction::__set_extent(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->extent = val;
}

void ActiveCompaction::__set_age(const int64_t val) {
  this->age = val;
}

void ActiveCompaction::__set_inputFiles(const std::vector<std::string> & val) {
  this->inputFiles = val;
}

void ActiveCompaction::__set_outputFile(const std::string& val) {
  this->outputFile = val;
}

void ActiveCompaction::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ActiveCompaction::__set_reason(const CompactionReason::type val) {
  this->reason = val;
}

void ActiveCompaction::__set_localityGroup(const std::string& val) {
  this->localityGroup = val;
}

void ActiveCompaction::__set_entriesRead(const int64_t val) {
  this->entriesRead = val;
}

void ActiveCompaction::__set_entriesWritten(const int64_t val) {
  this->entriesWritten = val;
}

void ActiveCompaction::__set_ssiList(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> & val) {
  this->ssiList = val;
}

void ActiveCompaction::__set_ssio(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->ssio = val;
}
std::ostream& operator<<(std::ostream& out, const ActiveCompaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ActiveCompaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputFiles.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->inputFiles.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readString(this->inputFiles[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFile);
          this->__isset.outputFile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->type = (CompactionType::type)ecast63;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->reason = (CompactionReason::type)ecast64;
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localityGroup);
          this->__isset.localityGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesRead);
          this->__isset.entriesRead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesWritten);
          this->__isset.entriesWritten = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ssiList.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->ssiList.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->ssiList[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ssiList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ssio.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _ktype71;
            ::apache::thrift::protocol::TType _vtype72;
            xfer += iprot->readMapBegin(_ktype71, _vtype72, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              std::string _key75;
              xfer += iprot->readString(_key75);
              std::map<std::string, std::string> & _val76 = this->ssio[_key75];
              {
                _val76.clear();
                uint32_t _size77;
                ::apache::thrift::protocol::TType _ktype78;
                ::apache::thrift::protocol::TType _vtype79;
                xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
                uint32_t _i81;
                for (_i81 = 0; _i81 < _size77; ++_i81)
                {
                  std::string _key82;
                  xfer += iprot->readString(_key82);
                  std::string& _val83 = _val76[_key82];
                  xfer += iprot->readString(_val83);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ssio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveCompaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActiveCompaction");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFiles", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->inputFiles.size()));
    std::vector<std::string> ::const_iterator _iter84;
    for (_iter84 = this->inputFiles.begin(); _iter84 != this->inputFiles.end(); ++_iter84)
    {
      xfer += oprot->writeString((*_iter84));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFile", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("localityGroup", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->localityGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesRead", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->entriesRead);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesWritten", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->entriesWritten);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssiList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ssiList.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::IterInfo> ::const_iterator _iter85;
    for (_iter85 = this->ssiList.begin(); _iter85 != this->ssiList.end(); ++_iter85)
    {
      xfer += (*_iter85).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssio", ::apache::thrift::protocol::T_MAP, 11);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->ssio.size()));
    std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter86;
    for (_iter86 = this->ssio.begin(); _iter86 != this->ssio.end(); ++_iter86)
    {
      xfer += oprot->writeString(_iter86->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter86->second.size()));
        std::map<std::string, std::string> ::const_iterator _iter87;
        for (_iter87 = _iter86->second.begin(); _iter87 != _iter86->second.end(); ++_iter87)
        {
          xfer += oprot->writeString(_iter87->first);
          xfer += oprot->writeString(_iter87->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveCompaction &a, ActiveCompaction &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.age, b.age);
  swap(a.inputFiles, b.inputFiles);
  swap(a.outputFile, b.outputFile);
  swap(a.type, b.type);
  swap(a.reason, b.reason);
  swap(a.localityGroup, b.localityGroup);
  swap(a.entriesRead, b.entriesRead);
  swap(a.entriesWritten, b.entriesWritten);
  swap(a.ssiList, b.ssiList);
  swap(a.ssio, b.ssio);
  swap(a.__isset, b.__isset);
}

ActiveCompaction::ActiveCompaction(const ActiveCompaction& other88) {
  extent = other88.extent;
  age = other88.age;
  inputFiles = other88.inputFiles;
  outputFile = other88.outputFile;
  type = other88.type;
  reason = other88.reason;
  localityGroup = other88.localityGroup;
  entriesRead = other88.entriesRead;
  entriesWritten = other88.entriesWritten;
  ssiList = other88.ssiList;
  ssio = other88.ssio;
  __isset = other88.__isset;
}
ActiveCompaction& ActiveCompaction::operator=(const ActiveCompaction& other89) {
  extent = other89.extent;
  age = other89.age;
  inputFiles = other89.inputFiles;
  outputFile = other89.outputFile;
  type = other89.type;
  reason = other89.reason;
  localityGroup = other89.localityGroup;
  entriesRead = other89.entriesRead;
  entriesWritten = other89.entriesWritten;
  ssiList = other89.ssiList;
  ssio = other89.ssio;
  __isset = other89.__isset;
  return *this;
}
void ActiveCompaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActiveCompaction(";
  out << "extent=" << to_string(extent);
  out << ", " << "age=" << to_string(age);
  out << ", " << "inputFiles=" << to_string(inputFiles);
  out << ", " << "outputFile=" << to_string(outputFile);
  out << ", " << "type=" << to_string(type);
  out << ", " << "reason=" << to_string(reason);
  out << ", " << "localityGroup=" << to_string(localityGroup);
  out << ", " << "entriesRead=" << to_string(entriesRead);
  out << ", " << "entriesWritten=" << to_string(entriesWritten);
  out << ", " << "ssiList=" << to_string(ssiList);
  out << ", " << "ssio=" << to_string(ssio);
  out << ")";
}


TIteratorSetting::~TIteratorSetting() throw() {
}


void TIteratorSetting::__set_priority(const int32_t val) {
  this->priority = val;
}

void TIteratorSetting::__set_name(const std::string& val) {
  this->name = val;
}

void TIteratorSetting::__set_iteratorClass(const std::string& val) {
  this->iteratorClass = val;
}

void TIteratorSetting::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const TIteratorSetting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIteratorSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iteratorClass);
          this->__isset.iteratorClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _ktype91;
            ::apache::thrift::protocol::TType _vtype92;
            xfer += iprot->readMapBegin(_ktype91, _vtype92, _size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              std::string _key95;
              xfer += iprot->readString(_key95);
              std::string& _val96 = this->properties[_key95];
              xfer += iprot->readString(_val96);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIteratorSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIteratorSetting");

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iteratorClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iteratorClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter97;
    for (_iter97 = this->properties.begin(); _iter97 != this->properties.end(); ++_iter97)
    {
      xfer += oprot->writeString(_iter97->first);
      xfer += oprot->writeString(_iter97->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIteratorSetting &a, TIteratorSetting &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.name, b.name);
  swap(a.iteratorClass, b.iteratorClass);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

TIteratorSetting::TIteratorSetting(const TIteratorSetting& other98) {
  priority = other98.priority;
  name = other98.name;
  iteratorClass = other98.iteratorClass;
  properties = other98.properties;
  __isset = other98.__isset;
}
TIteratorSetting& TIteratorSetting::operator=(const TIteratorSetting& other99) {
  priority = other99.priority;
  name = other99.name;
  iteratorClass = other99.iteratorClass;
  properties = other99.properties;
  __isset = other99.__isset;
  return *this;
}
void TIteratorSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIteratorSetting(";
  out << "priority=" << to_string(priority);
  out << ", " << "name=" << to_string(name);
  out << ", " << "iteratorClass=" << to_string(iteratorClass);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


IteratorConfig::~IteratorConfig() throw() {
}


void IteratorConfig::__set_iterators(const std::vector<TIteratorSetting> & val) {
  this->iterators = val;
}
std::ostream& operator<<(std::ostream& out, const IteratorConfig& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IteratorConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->iterators.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->iterators[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IteratorConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IteratorConfig");

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<TIteratorSetting> ::const_iterator _iter105;
    for (_iter105 = this->iterators.begin(); _iter105 != this->iterators.end(); ++_iter105)
    {
      xfer += (*_iter105).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IteratorConfig &a, IteratorConfig &b) {
  using ::std::swap;
  swap(a.iterators, b.iterators);
  swap(a.__isset, b.__isset);
}

IteratorConfig::IteratorConfig(const IteratorConfig& other106) {
  iterators = other106.iterators;
  __isset = other106.__isset;
}
IteratorConfig& IteratorConfig::operator=(const IteratorConfig& other107) {
  iterators = other107.iterators;
  __isset = other107.__isset;
  return *this;
}
void IteratorConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IteratorConfig(";
  out << "iterators=" << to_string(iterators);
  out << ")";
}


TSamplerConfiguration::~TSamplerConfiguration() throw() {
}


void TSamplerConfiguration::__set_className(const std::string& val) {
  this->className = val;
}

void TSamplerConfiguration::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
}
std::ostream& operator<<(std::ostream& out, const TSamplerConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSamplerConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _ktype109;
            ::apache::thrift::protocol::TType _vtype110;
            xfer += iprot->readMapBegin(_ktype109, _vtype110, _size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              std::string _key113;
              xfer += iprot->readString(_key113);
              std::string& _val114 = this->options[_key113];
              xfer += iprot->readString(_val114);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSamplerConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSamplerConfiguration");

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::map<std::string, std::string> ::const_iterator _iter115;
    for (_iter115 = this->options.begin(); _iter115 != this->options.end(); ++_iter115)
    {
      xfer += oprot->writeString(_iter115->first);
      xfer += oprot->writeString(_iter115->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSamplerConfiguration &a, TSamplerConfiguration &b) {
  using ::std::swap;
  swap(a.className, b.className);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

TSamplerConfiguration::TSamplerConfiguration(const TSamplerConfiguration& other116) {
  className = other116.className;
  options = other116.options;
  __isset = other116.__isset;
}
TSamplerConfiguration& TSamplerConfiguration::operator=(const TSamplerConfiguration& other117) {
  className = other117.className;
  options = other117.options;
  __isset = other117.__isset;
  return *this;
}
void TSamplerConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSamplerConfiguration(";
  out << "className=" << to_string(className);
  out << ", " << "options=" << to_string(options);
  out << ")";
}

}}}}}} // namespace
