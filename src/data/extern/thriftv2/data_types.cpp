/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data/extern/thriftv2/data_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace org { namespace apache { namespace accumulov2 { namespace core { namespace dataImpl { namespace thrift {

int _kTCMStatusValues[] = {
  TCMStatus::ACCEPTED,
  TCMStatus::REJECTED,
  TCMStatus::VIOLATED,
  TCMStatus::IGNORED
};
const char* _kTCMStatusNames[] = {
  "ACCEPTED",
  "REJECTED",
  "VIOLATED",
  "IGNORED"
};
const std::map<int, const char*> _TCMStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTCMStatusValues, _kTCMStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TCMStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TCMStatus_VALUES_TO_NAMES.find(val);
  if (it != _TCMStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TKey::~TKey() throw() {
}


void TKey::__set_row(const std::string& val) {
  this->row = val;
}

void TKey::__set_colFamily(const std::string& val) {
  this->colFamily = val;
}

void TKey::__set_colQualifier(const std::string& val) {
  this->colQualifier = val;
}

void TKey::__set_colVisibility(const std::string& val) {
  this->colVisibility = val;
}

void TKey::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const TKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKey");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->colVisibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKey &a, TKey &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TKey::TKey(const TKey& other0) {
  row = other0.row;
  colFamily = other0.colFamily;
  colQualifier = other0.colQualifier;
  colVisibility = other0.colVisibility;
  timestamp = other0.timestamp;
  __isset = other0.__isset;
}
TKey& TKey::operator=(const TKey& other1) {
  row = other1.row;
  colFamily = other1.colFamily;
  colQualifier = other1.colQualifier;
  colVisibility = other1.colVisibility;
  timestamp = other1.timestamp;
  __isset = other1.__isset;
  return *this;
}
void TKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKey(";
  out << "row=" << to_string(row);
  out << ", " << "colFamily=" << to_string(colFamily);
  out << ", " << "colQualifier=" << to_string(colQualifier);
  out << ", " << "colVisibility=" << to_string(colVisibility);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_columnFamily(const std::string& val) {
  this->columnFamily = val;
}

void TColumn::__set_columnQualifier(const std::string& val) {
  this->columnQualifier = val;
}

void TColumn::__set_columnVisibility(const std::string& val) {
  this->columnVisibility = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->columnFamily);
          this->__isset.columnFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->columnQualifier);
          this->__isset.columnQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->columnVisibility);
          this->__isset.columnVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  if (!this->columnFamily.empty()){
    xfer += oprot->writeFieldBegin("columnFamily", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->columnFamily);
    xfer += oprot->writeFieldEnd();
  }

  if (!this->columnQualifier.empty()){
    xfer += oprot->writeFieldBegin("columnQualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->columnQualifier);
    xfer += oprot->writeFieldEnd();
  }

  if (!this->columnVisibility.empty()){
    xfer += oprot->writeFieldBegin("columnVisibility", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->columnVisibility);
    xfer += oprot->writeFieldEnd();
  }

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.columnFamily, b.columnFamily);
  swap(a.columnQualifier, b.columnQualifier);
  swap(a.columnVisibility, b.columnVisibility);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other2) {
  columnFamily = other2.columnFamily;
  columnQualifier = other2.columnQualifier;
  columnVisibility = other2.columnVisibility;
  __isset = other2.__isset;
}
TColumn& TColumn::operator=(const TColumn& other3) {
  columnFamily = other3.columnFamily;
  columnQualifier = other3.columnQualifier;
  columnVisibility = other3.columnVisibility;
  __isset = other3.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "columnFamily=" << to_string(columnFamily);
  out << ", " << "columnQualifier=" << to_string(columnQualifier);
  out << ", " << "columnVisibility=" << to_string(columnVisibility);
  out << ")";
}


TMutation::~TMutation() throw() {
}


void TMutation::__set_row(const std::string& val) {
  this->row = val;
}

void TMutation::__set_data(const std::string& val) {
  this->data = val;
}

void TMutation::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TMutation::__set_entries(const int32_t val) {
  this->entries = val;
}

void TMutation::__set_sources(const std::vector<std::string> & val) {
  this->sources = val;
__isset.sources = true;
}
std::ostream& operator<<(std::ostream& out, const TMutation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->values.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readBinary(this->values[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->entries);
          this->__isset.entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sources.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->sources.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += iprot->readString(this->sources[_i13]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMutation");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter14;
    for (_iter14 = this->values.begin(); _iter14 != this->values.end(); ++_iter14)
    {
      xfer += oprot->writeBinary((*_iter14));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->entries);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sources) {
    xfer += oprot->writeFieldBegin("sources", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sources.size()));
      std::vector<std::string> ::const_iterator _iter15;
      for (_iter15 = this->sources.begin(); _iter15 != this->sources.end(); ++_iter15)
      {
        xfer += oprot->writeString((*_iter15));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.data, b.data);
  swap(a.values, b.values);
  swap(a.entries, b.entries);
  swap(a.sources, b.sources);
  swap(a.__isset, b.__isset);
}

TMutation::TMutation(const TMutation& other16) {
  row = other16.row;
  data = other16.data;
  values = other16.values;
  entries = other16.entries;
  sources = other16.sources;
  __isset = other16.__isset;
}
TMutation& TMutation::operator=(const TMutation& other17) {
  row = other17.row;
  data = other17.data;
  values = other17.values;
  entries = other17.entries;
  sources = other17.sources;
  __isset = other17.__isset;
  return *this;
}
void TMutation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMutation(";
  out << "row=" << to_string(row);
  out << ", " << "data=" << to_string(data);
  out << ", " << "values=" << to_string(values);
  out << ", " << "entries=" << to_string(entries);
  out << ", " << "sources="; (__isset.sources ? (out << to_string(sources)) : (out << "<null>"));
  out << ")";
}


TKeyExtent::~TKeyExtent() throw() {
}


void TKeyExtent::__set_table(const std::string& val) {
  this->table = val;
}

void TKeyExtent::__set_endRow(const std::string& val) {
  this->endRow = val;
}

void TKeyExtent::__set_prevEndRow(const std::string& val) {
  this->prevEndRow = val;
}
std::ostream& operator<<(std::ostream& out, const TKeyExtent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TKeyExtent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->prevEndRow);
          this->__isset.prevEndRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKeyExtent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKeyExtent");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->table);
  xfer += oprot->writeFieldEnd();

  if (!this->endRow.empty()){
    xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->endRow);
    xfer += oprot->writeFieldEnd();
  }

  if (!this->prevEndRow.empty()){
    xfer += oprot->writeFieldBegin("prevEndRow", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->prevEndRow);
    xfer += oprot->writeFieldEnd();
  }

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKeyExtent &a, TKeyExtent &b) {
  using ::std::swap;
  swap(a.table, b.table);
  swap(a.endRow, b.endRow);
  swap(a.prevEndRow, b.prevEndRow);
  swap(a.__isset, b.__isset);
}

TKeyExtent::TKeyExtent(const TKeyExtent& other18) {
  table = other18.table;
  endRow = other18.endRow;
  prevEndRow = other18.prevEndRow;
  __isset = other18.__isset;
}
TKeyExtent& TKeyExtent::operator=(const TKeyExtent& other19) {
  table = other19.table;
  endRow = other19.endRow;
  prevEndRow = other19.prevEndRow;
  __isset = other19.__isset;
  return *this;
}
void TKeyExtent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKeyExtent(";
  out << "table=" << to_string(table);
  out << ", " << "endRow=" << to_string(endRow);
  out << ", " << "prevEndRow=" << to_string(prevEndRow);
  out << ")";
}


TKeyValue::~TKeyValue() throw() {
}


void TKeyValue::__set_key(const TKey& val) {
  this->key = val;
}

void TKeyValue::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TKeyValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKeyValue");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKeyValue &a, TKeyValue &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TKeyValue::TKeyValue(const TKeyValue& other20) {
  key = other20.key;
  value = other20.value;
  __isset = other20.__isset;
}
TKeyValue& TKeyValue::operator=(const TKeyValue& other21) {
  key = other21.key;
  value = other21.value;
  __isset = other21.__isset;
  return *this;
}
void TKeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKeyValue(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


ScanResult::~ScanResult() throw() {
}


void ScanResult::__set_results(const std::vector<TKeyValue> & val) {
  this->results = val;
}

void ScanResult::__set_more(const bool val) {
  this->more = val;
}
std::ostream& operator<<(std::ostream& out, const ScanResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->results.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->results[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->more);
          this->__isset.more = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<TKeyValue> ::const_iterator _iter27;
    for (_iter27 = this->results.begin(); _iter27 != this->results.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->more);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanResult &a, ScanResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
  swap(a.more, b.more);
  swap(a.__isset, b.__isset);
}

ScanResult::ScanResult(const ScanResult& other28) {
  results = other28.results;
  more = other28.more;
  __isset = other28.__isset;
}
ScanResult& ScanResult::operator=(const ScanResult& other29) {
  results = other29.results;
  more = other29.more;
  __isset = other29.__isset;
  return *this;
}
void ScanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanResult(";
  out << "results=" << to_string(results);
  out << ", " << "more=" << to_string(more);
  out << ")";
}


TRange::~TRange() throw() {
}


void TRange::__set_start(const TKey& val) {
  this->start = val;
}

void TRange::__set_stop(const TKey& val) {
  this->stop = val;
}

void TRange::__set_startKeyInclusive(const bool val) {
  this->startKeyInclusive = val;
}

void TRange::__set_stopKeyInclusive(const bool val) {
  this->stopKeyInclusive = val;
}

void TRange::__set_infiniteStartKey(const bool val) {
  this->infiniteStartKey = val;
}

void TRange::__set_infiniteStopKey(const bool val) {
  this->infiniteStopKey = val;
}
std::ostream& operator<<(std::ostream& out, const TRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stop.read(iprot);
          this->__isset.stop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startKeyInclusive);
          this->__isset.startKeyInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->stopKeyInclusive);
          this->__isset.stopKeyInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->infiniteStartKey);
          this->__isset.infiniteStartKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->infiniteStopKey);
          this->__isset.infiniteStopKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRange");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stop", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startKeyInclusive", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->startKeyInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopKeyInclusive", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->stopKeyInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infiniteStartKey", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->infiniteStartKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infiniteStopKey", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->infiniteStopKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRange &a, TRange &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.stop, b.stop);
  swap(a.startKeyInclusive, b.startKeyInclusive);
  swap(a.stopKeyInclusive, b.stopKeyInclusive);
  swap(a.infiniteStartKey, b.infiniteStartKey);
  swap(a.infiniteStopKey, b.infiniteStopKey);
  swap(a.__isset, b.__isset);
}

TRange::TRange(const TRange& other30) {
  start = other30.start;
  stop = other30.stop;
  startKeyInclusive = other30.startKeyInclusive;
  stopKeyInclusive = other30.stopKeyInclusive;
  infiniteStartKey = other30.infiniteStartKey;
  infiniteStopKey = other30.infiniteStopKey;
  __isset = other30.__isset;
}
TRange& TRange::operator=(const TRange& other31) {
  start = other31.start;
  stop = other31.stop;
  startKeyInclusive = other31.startKeyInclusive;
  stopKeyInclusive = other31.stopKeyInclusive;
  infiniteStartKey = other31.infiniteStartKey;
  infiniteStopKey = other31.infiniteStopKey;
  __isset = other31.__isset;
  return *this;
}
void TRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRange(";
  out << "start=" << to_string(start);
  out << ", " << "stop=" << to_string(stop);
  out << ", " << "startKeyInclusive=" << to_string(startKeyInclusive);
  out << ", " << "stopKeyInclusive=" << to_string(stopKeyInclusive);
  out << ", " << "infiniteStartKey=" << to_string(infiniteStartKey);
  out << ", " << "infiniteStopKey=" << to_string(infiniteStopKey);
  out << ")";
}


MultiScanResult::~MultiScanResult() throw() {
}


void MultiScanResult::__set_results(const std::vector<TKeyValue> & val) {
  this->results = val;
}

void MultiScanResult::__set_failures(const ScanBatch& val) {
  this->failures = val;
}

void MultiScanResult::__set_fullScans(const std::vector<TKeyExtent> & val) {
  this->fullScans = val;
}

void MultiScanResult::__set_partScan(const TKeyExtent& val) {
  this->partScan = val;
}

void MultiScanResult::__set_partNextKey(const TKey& val) {
  this->partNextKey = val;
}

void MultiScanResult::__set_partNextKeyInclusive(const bool val) {
  this->partNextKeyInclusive = val;
}

void MultiScanResult::__set_more(const bool val) {
  this->more = val;
}
std::ostream& operator<<(std::ostream& out, const MultiScanResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MultiScanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->results.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->results[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->failures.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _ktype38;
            ::apache::thrift::protocol::TType _vtype39;
            xfer += iprot->readMapBegin(_ktype38, _vtype39, _size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              TKeyExtent _key42;
              xfer += _key42.read(iprot);
              std::vector<TRange> & _val43 = this->failures[_key42];
              {
                _val43.clear();
                uint32_t _size44;
                ::apache::thrift::protocol::TType _etype47;
                xfer += iprot->readListBegin(_etype47, _size44);
                _val43.resize(_size44);
                uint32_t _i48;
                for (_i48 = 0; _i48 < _size44; ++_i48)
                {
                  xfer += _val43[_i48].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.failures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fullScans.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->fullScans.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += this->fullScans[_i53].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fullScans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partScan.read(iprot);
          this->__isset.partScan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partNextKey.read(iprot);
          this->__isset.partNextKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->partNextKeyInclusive);
          this->__isset.partNextKeyInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->more);
          this->__isset.more = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MultiScanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MultiScanResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<TKeyValue> ::const_iterator _iter54;
    for (_iter54 = this->results.begin(); _iter54 != this->results.end(); ++_iter54)
    {
      xfer += (*_iter54).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failures", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->failures.size()));
    std::map<TKeyExtent, std::vector<TRange> > ::const_iterator _iter55;
    for (_iter55 = this->failures.begin(); _iter55 != this->failures.end(); ++_iter55)
    {
      xfer += _iter55->first.write(oprot);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter55->second.size()));
        std::vector<TRange> ::const_iterator _iter56;
        for (_iter56 = _iter55->second.begin(); _iter56 != _iter55->second.end(); ++_iter56)
        {
          xfer += (*_iter56).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fullScans", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fullScans.size()));
    std::vector<TKeyExtent> ::const_iterator _iter57;
    for (_iter57 = this->fullScans.begin(); _iter57 != this->fullScans.end(); ++_iter57)
    {
      xfer += (*_iter57).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partScan", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->partScan.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNextKey", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->partNextKey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNextKeyInclusive", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->partNextKeyInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->more);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MultiScanResult &a, MultiScanResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
  swap(a.failures, b.failures);
  swap(a.fullScans, b.fullScans);
  swap(a.partScan, b.partScan);
  swap(a.partNextKey, b.partNextKey);
  swap(a.partNextKeyInclusive, b.partNextKeyInclusive);
  swap(a.more, b.more);
  swap(a.__isset, b.__isset);
}

MultiScanResult::MultiScanResult(const MultiScanResult& other58) {
  results = other58.results;
  failures = other58.failures;
  fullScans = other58.fullScans;
  partScan = other58.partScan;
  partNextKey = other58.partNextKey;
  partNextKeyInclusive = other58.partNextKeyInclusive;
  more = other58.more;
  __isset = other58.__isset;
}
MultiScanResult& MultiScanResult::operator=(const MultiScanResult& other59) {
  results = other59.results;
  failures = other59.failures;
  fullScans = other59.fullScans;
  partScan = other59.partScan;
  partNextKey = other59.partNextKey;
  partNextKeyInclusive = other59.partNextKeyInclusive;
  more = other59.more;
  __isset = other59.__isset;
  return *this;
}
void MultiScanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MultiScanResult(";
  out << "results=" << to_string(results);
  out << ", " << "failures=" << to_string(failures);
  out << ", " << "fullScans=" << to_string(fullScans);
  out << ", " << "partScan=" << to_string(partScan);
  out << ", " << "partNextKey=" << to_string(partNextKey);
  out << ", " << "partNextKeyInclusive=" << to_string(partNextKeyInclusive);
  out << ", " << "more=" << to_string(more);
  out << ")";
}


InitialScan::~InitialScan() throw() {
}


void InitialScan::__set_scanID(const ScanID val) {
  this->scanID = val;
}

void InitialScan::__set_result(const ScanResult& val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const InitialScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitialScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitialScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitialScan");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitialScan &a, InitialScan &b) {
  using ::std::swap;
  swap(a.scanID, b.scanID);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

InitialScan::InitialScan(const InitialScan& other60) {
  scanID = other60.scanID;
  result = other60.result;
  __isset = other60.__isset;
}
InitialScan& InitialScan::operator=(const InitialScan& other61) {
  scanID = other61.scanID;
  result = other61.result;
  __isset = other61.__isset;
  return *this;
}
void InitialScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitialScan(";
  out << "scanID=" << to_string(scanID);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


InitialMultiScan::~InitialMultiScan() throw() {
}


void InitialMultiScan::__set_scanID(const ScanID val) {
  this->scanID = val;
}

void InitialMultiScan::__set_result(const MultiScanResult& val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const InitialMultiScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitialMultiScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanID);
          this->__isset.scanID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitialMultiScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitialMultiScan");

  xfer += oprot->writeFieldBegin("scanID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scanID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitialMultiScan &a, InitialMultiScan &b) {
  using ::std::swap;
  swap(a.scanID, b.scanID);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

InitialMultiScan::InitialMultiScan(const InitialMultiScan& other62) {
  scanID = other62.scanID;
  result = other62.result;
  __isset = other62.__isset;
}
InitialMultiScan& InitialMultiScan::operator=(const InitialMultiScan& other63) {
  scanID = other63.scanID;
  result = other63.result;
  __isset = other63.__isset;
  return *this;
}
void InitialMultiScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitialMultiScan(";
  out << "scanID=" << to_string(scanID);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


IterInfo::~IterInfo() throw() {
}


void IterInfo::__set_priority(const int32_t val) {
  this->priority = val;
}

void IterInfo::__set_className(const std::string& val) {
  this->className = val;
}

void IterInfo::__set_iterName(const std::string& val) {
  this->iterName = val;
}
std::ostream& operator<<(std::ostream& out, const IterInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iterName);
          this->__isset.iterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IterInfo");

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iterName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IterInfo &a, IterInfo &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.className, b.className);
  swap(a.iterName, b.iterName);
  swap(a.__isset, b.__isset);
}

IterInfo::IterInfo(const IterInfo& other64) {
  priority = other64.priority;
  className = other64.className;
  iterName = other64.iterName;
  __isset = other64.__isset;
}
IterInfo& IterInfo::operator=(const IterInfo& other65) {
  priority = other65.priority;
  className = other65.className;
  iterName = other65.iterName;
  __isset = other65.__isset;
  return *this;
}
void IterInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IterInfo(";
  out << "priority=" << to_string(priority);
  out << ", " << "className=" << to_string(className);
  out << ", " << "iterName=" << to_string(iterName);
  out << ")";
}


TConstraintViolationSummary::~TConstraintViolationSummary() throw() {
}


void TConstraintViolationSummary::__set_constrainClass(const std::string& val) {
  this->constrainClass = val;
}

void TConstraintViolationSummary::__set_violationCode(const int16_t val) {
  this->violationCode = val;
}

void TConstraintViolationSummary::__set_violationDescription(const std::string& val) {
  this->violationDescription = val;
}

void TConstraintViolationSummary::__set_numberOfViolatingMutations(const int64_t val) {
  this->numberOfViolatingMutations = val;
}
std::ostream& operator<<(std::ostream& out, const TConstraintViolationSummary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TConstraintViolationSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->constrainClass);
          this->__isset.constrainClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->violationCode);
          this->__isset.violationCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->violationDescription);
          this->__isset.violationDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numberOfViolatingMutations);
          this->__isset.numberOfViolatingMutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TConstraintViolationSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TConstraintViolationSummary");

  xfer += oprot->writeFieldBegin("constrainClass", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->constrainClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("violationCode", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->violationCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("violationDescription", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->violationDescription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numberOfViolatingMutations", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numberOfViolatingMutations);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TConstraintViolationSummary &a, TConstraintViolationSummary &b) {
  using ::std::swap;
  swap(a.constrainClass, b.constrainClass);
  swap(a.violationCode, b.violationCode);
  swap(a.violationDescription, b.violationDescription);
  swap(a.numberOfViolatingMutations, b.numberOfViolatingMutations);
  swap(a.__isset, b.__isset);
}

TConstraintViolationSummary::TConstraintViolationSummary(const TConstraintViolationSummary& other66) {
  constrainClass = other66.constrainClass;
  violationCode = other66.violationCode;
  violationDescription = other66.violationDescription;
  numberOfViolatingMutations = other66.numberOfViolatingMutations;
  __isset = other66.__isset;
}
TConstraintViolationSummary& TConstraintViolationSummary::operator=(const TConstraintViolationSummary& other67) {
  constrainClass = other67.constrainClass;
  violationCode = other67.violationCode;
  violationDescription = other67.violationDescription;
  numberOfViolatingMutations = other67.numberOfViolatingMutations;
  __isset = other67.__isset;
  return *this;
}
void TConstraintViolationSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TConstraintViolationSummary(";
  out << "constrainClass=" << to_string(constrainClass);
  out << ", " << "violationCode=" << to_string(violationCode);
  out << ", " << "violationDescription=" << to_string(violationDescription);
  out << ", " << "numberOfViolatingMutations=" << to_string(numberOfViolatingMutations);
  out << ")";
}


UpdateErrors::~UpdateErrors() throw() {
}


void UpdateErrors::__set_failedExtents(const std::map<TKeyExtent, int64_t> & val) {
  this->failedExtents = val;
}

void UpdateErrors::__set_violationSummaries(const std::vector<TConstraintViolationSummary> & val) {
  this->violationSummaries = val;
}

void UpdateErrors::__set_authorizationFailures(const std::map<TKeyExtent,  ::org::apache::accumulov2::core::clientImpl::thrift::SecurityErrorCode::type> & val) {
  this->authorizationFailures = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateErrors& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateErrors::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->failedExtents.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _ktype69;
            ::apache::thrift::protocol::TType _vtype70;
            xfer += iprot->readMapBegin(_ktype69, _vtype70, _size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              TKeyExtent _key73;
              xfer += _key73.read(iprot);
              int64_t& _val74 = this->failedExtents[_key73];
              xfer += iprot->readI64(_val74);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.failedExtents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->violationSummaries.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->violationSummaries.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->violationSummaries[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.violationSummaries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->authorizationFailures.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _ktype81;
            ::apache::thrift::protocol::TType _vtype82;
            xfer += iprot->readMapBegin(_ktype81, _vtype82, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              TKeyExtent _key85;
              xfer += _key85.read(iprot);
               ::org::apache::accumulov2::core::clientImpl::thrift::SecurityErrorCode::type& _val86 = this->authorizationFailures[_key85];
              int32_t ecast87;
              xfer += iprot->readI32(ecast87);
              _val86 = ( ::org::apache::accumulov2::core::clientImpl::thrift::SecurityErrorCode::type)ecast87;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.authorizationFailures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateErrors::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateErrors");

  xfer += oprot->writeFieldBegin("failedExtents", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->failedExtents.size()));
    std::map<TKeyExtent, int64_t> ::const_iterator _iter88;
    for (_iter88 = this->failedExtents.begin(); _iter88 != this->failedExtents.end(); ++_iter88)
    {
      xfer += _iter88->first.write(oprot);
      xfer += oprot->writeI64(_iter88->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("violationSummaries", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->violationSummaries.size()));
    std::vector<TConstraintViolationSummary> ::const_iterator _iter89;
    for (_iter89 = this->violationSummaries.begin(); _iter89 != this->violationSummaries.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizationFailures", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->authorizationFailures.size()));
    std::map<TKeyExtent,  ::org::apache::accumulov2::core::clientImpl::thrift::SecurityErrorCode::type> ::const_iterator _iter90;
    for (_iter90 = this->authorizationFailures.begin(); _iter90 != this->authorizationFailures.end(); ++_iter90)
    {
      xfer += _iter90->first.write(oprot);
      xfer += oprot->writeI32((int32_t)_iter90->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateErrors &a, UpdateErrors &b) {
  using ::std::swap;
  swap(a.failedExtents, b.failedExtents);
  swap(a.violationSummaries, b.violationSummaries);
  swap(a.authorizationFailures, b.authorizationFailures);
  swap(a.__isset, b.__isset);
}

UpdateErrors::UpdateErrors(const UpdateErrors& other91) {
  failedExtents = other91.failedExtents;
  violationSummaries = other91.violationSummaries;
  authorizationFailures = other91.authorizationFailures;
  __isset = other91.__isset;
}
UpdateErrors& UpdateErrors::operator=(const UpdateErrors& other92) {
  failedExtents = other92.failedExtents;
  violationSummaries = other92.violationSummaries;
  authorizationFailures = other92.authorizationFailures;
  __isset = other92.__isset;
  return *this;
}
void UpdateErrors::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateErrors(";
  out << "failedExtents=" << to_string(failedExtents);
  out << ", " << "violationSummaries=" << to_string(violationSummaries);
  out << ", " << "authorizationFailures=" << to_string(authorizationFailures);
  out << ")";
}


TCMResult::~TCMResult() throw() {
}


void TCMResult::__set_cmid(const int64_t val) {
  this->cmid = val;
}

void TCMResult::__set_status(const TCMStatus::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCMResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCMResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cmid);
          this->__isset.cmid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast93;
          xfer += iprot->readI32(ecast93);
          this->status = (TCMStatus::type)ecast93;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCMResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCMResult");

  xfer += oprot->writeFieldBegin("cmid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cmid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCMResult &a, TCMResult &b) {
  using ::std::swap;
  swap(a.cmid, b.cmid);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TCMResult::TCMResult(const TCMResult& other94) {
  cmid = other94.cmid;
  status = other94.status;
  __isset = other94.__isset;
}
TCMResult& TCMResult::operator=(const TCMResult& other95) {
  cmid = other95.cmid;
  status = other95.status;
  __isset = other95.__isset;
  return *this;
}
void TCMResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCMResult(";
  out << "cmid=" << to_string(cmid);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


MapFileInfo::~MapFileInfo() throw() {
}


void MapFileInfo::__set_estimatedSize(const int64_t val) {
  this->estimatedSize = val;
}
std::ostream& operator<<(std::ostream& out, const MapFileInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapFileInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->estimatedSize);
          this->__isset.estimatedSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapFileInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapFileInfo");

  xfer += oprot->writeFieldBegin("estimatedSize", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->estimatedSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapFileInfo &a, MapFileInfo &b) {
  using ::std::swap;
  swap(a.estimatedSize, b.estimatedSize);
  swap(a.__isset, b.__isset);
}

MapFileInfo::MapFileInfo(const MapFileInfo& other96) {
  estimatedSize = other96.estimatedSize;
  __isset = other96.__isset;
}
MapFileInfo& MapFileInfo::operator=(const MapFileInfo& other97) {
  estimatedSize = other97.estimatedSize;
  __isset = other97.__isset;
  return *this;
}
void MapFileInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapFileInfo(";
  out << "estimatedSize=" << to_string(estimatedSize);
  out << ")";
}


TCondition::~TCondition() throw() {
}


void TCondition::__set_cf(const std::string& val) {
  this->cf = val;
}

void TCondition::__set_cq(const std::string& val) {
  this->cq = val;
}

void TCondition::__set_cv(const std::string& val) {
  this->cv = val;
}

void TCondition::__set_ts(const int64_t val) {
  this->ts = val;
}

void TCondition::__set_hasTimestamp(const bool val) {
  this->hasTimestamp = val;
}

void TCondition::__set_val(const std::string& val) {
  this->val = val;
}

void TCondition::__set_iterators(const std::string& val) {
  this->iterators = val;
}
std::ostream& operator<<(std::ostream& out, const TCondition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->cf);
          this->__isset.cf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->cq);
          this->__isset.cq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->cv);
          this->__isset.cv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasTimestamp);
          this->__isset.hasTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->val);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->iterators);
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCondition");

  xfer += oprot->writeFieldBegin("cf", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->cf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cq", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->cq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cv", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->cv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasTimestamp", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->hasTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->iterators);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCondition &a, TCondition &b) {
  using ::std::swap;
  swap(a.cf, b.cf);
  swap(a.cq, b.cq);
  swap(a.cv, b.cv);
  swap(a.ts, b.ts);
  swap(a.hasTimestamp, b.hasTimestamp);
  swap(a.val, b.val);
  swap(a.iterators, b.iterators);
  swap(a.__isset, b.__isset);
}

TCondition::TCondition(const TCondition& other98) {
  cf = other98.cf;
  cq = other98.cq;
  cv = other98.cv;
  ts = other98.ts;
  hasTimestamp = other98.hasTimestamp;
  val = other98.val;
  iterators = other98.iterators;
  __isset = other98.__isset;
}
TCondition& TCondition::operator=(const TCondition& other99) {
  cf = other99.cf;
  cq = other99.cq;
  cv = other99.cv;
  ts = other99.ts;
  hasTimestamp = other99.hasTimestamp;
  val = other99.val;
  iterators = other99.iterators;
  __isset = other99.__isset;
  return *this;
}
void TCondition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCondition(";
  out << "cf=" << to_string(cf);
  out << ", " << "cq=" << to_string(cq);
  out << ", " << "cv=" << to_string(cv);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "hasTimestamp=" << to_string(hasTimestamp);
  out << ", " << "val=" << to_string(val);
  out << ", " << "iterators=" << to_string(iterators);
  out << ")";
}


TConditionalMutation::~TConditionalMutation() throw() {
}


void TConditionalMutation::__set_conditions(const std::vector<TCondition> & val) {
  this->conditions = val;
}

void TConditionalMutation::__set_mutation(const TMutation& val) {
  this->mutation = val;
}

void TConditionalMutation::__set_id(const int64_t val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TConditionalMutation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TConditionalMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conditions.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->conditions.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->conditions[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mutation.read(iprot);
          this->__isset.mutation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TConditionalMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TConditionalMutation");

  xfer += oprot->writeFieldBegin("conditions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conditions.size()));
    std::vector<TCondition> ::const_iterator _iter105;
    for (_iter105 = this->conditions.begin(); _iter105 != this->conditions.end(); ++_iter105)
    {
      xfer += (*_iter105).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutation", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mutation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TConditionalMutation &a, TConditionalMutation &b) {
  using ::std::swap;
  swap(a.conditions, b.conditions);
  swap(a.mutation, b.mutation);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TConditionalMutation::TConditionalMutation(const TConditionalMutation& other106) {
  conditions = other106.conditions;
  mutation = other106.mutation;
  id = other106.id;
  __isset = other106.__isset;
}
TConditionalMutation& TConditionalMutation::operator=(const TConditionalMutation& other107) {
  conditions = other107.conditions;
  mutation = other107.mutation;
  id = other107.id;
  __isset = other107.__isset;
  return *this;
}
void TConditionalMutation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TConditionalMutation(";
  out << "conditions=" << to_string(conditions);
  out << ", " << "mutation=" << to_string(mutation);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


TConditionalSession::~TConditionalSession() throw() {
}


void TConditionalSession::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TConditionalSession::__set_tserverLock(const std::string& val) {
  this->tserverLock = val;
}

void TConditionalSession::__set_ttl(const int64_t val) {
  this->ttl = val;
}
std::ostream& operator<<(std::ostream& out, const TConditionalSession& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TConditionalSession::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tserverLock);
          this->__isset.tserverLock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TConditionalSession::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TConditionalSession");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tserverLock", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tserverLock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ttl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TConditionalSession &a, TConditionalSession &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.tserverLock, b.tserverLock);
  swap(a.ttl, b.ttl);
  swap(a.__isset, b.__isset);
}

TConditionalSession::TConditionalSession(const TConditionalSession& other108) {
  sessionId = other108.sessionId;
  tserverLock = other108.tserverLock;
  ttl = other108.ttl;
  __isset = other108.__isset;
}
TConditionalSession& TConditionalSession::operator=(const TConditionalSession& other109) {
  sessionId = other109.sessionId;
  tserverLock = other109.tserverLock;
  ttl = other109.ttl;
  __isset = other109.__isset;
  return *this;
}
void TConditionalSession::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TConditionalSession(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "tserverLock=" << to_string(tserverLock);
  out << ", " << "ttl=" << to_string(ttl);
  out << ")";
}


TSummarizerConfiguration::~TSummarizerConfiguration() throw() {
}


void TSummarizerConfiguration::__set_classname(const std::string& val) {
  this->classname = val;
}

void TSummarizerConfiguration::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
}

void TSummarizerConfiguration::__set_configId(const std::string& val) {
  this->configId = val;
}
std::ostream& operator<<(std::ostream& out, const TSummarizerConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSummarizerConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->classname);
          this->__isset.classname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _ktype111;
            ::apache::thrift::protocol::TType _vtype112;
            xfer += iprot->readMapBegin(_ktype111, _vtype112, _size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              std::string _key115;
              xfer += iprot->readString(_key115);
              std::string& _val116 = this->options[_key115];
              xfer += iprot->readString(_val116);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->configId);
          this->__isset.configId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSummarizerConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSummarizerConfiguration");

  xfer += oprot->writeFieldBegin("classname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->classname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::map<std::string, std::string> ::const_iterator _iter117;
    for (_iter117 = this->options.begin(); _iter117 != this->options.end(); ++_iter117)
    {
      xfer += oprot->writeString(_iter117->first);
      xfer += oprot->writeString(_iter117->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("configId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->configId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSummarizerConfiguration &a, TSummarizerConfiguration &b) {
  using ::std::swap;
  swap(a.classname, b.classname);
  swap(a.options, b.options);
  swap(a.configId, b.configId);
  swap(a.__isset, b.__isset);
}

TSummarizerConfiguration::TSummarizerConfiguration(const TSummarizerConfiguration& other118) {
  classname = other118.classname;
  options = other118.options;
  configId = other118.configId;
  __isset = other118.__isset;
}
TSummarizerConfiguration& TSummarizerConfiguration::operator=(const TSummarizerConfiguration& other119) {
  classname = other119.classname;
  options = other119.options;
  configId = other119.configId;
  __isset = other119.__isset;
  return *this;
}
void TSummarizerConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSummarizerConfiguration(";
  out << "classname=" << to_string(classname);
  out << ", " << "options=" << to_string(options);
  out << ", " << "configId=" << to_string(configId);
  out << ")";
}


TSummary::~TSummary() throw() {
}


void TSummary::__set_summary(const std::map<std::string, int64_t> & val) {
  this->summary = val;
}

void TSummary::__set_config(const TSummarizerConfiguration& val) {
  this->config = val;
}

void TSummary::__set_filesContaining(const int64_t val) {
  this->filesContaining = val;
}

void TSummary::__set_filesExceeding(const int64_t val) {
  this->filesExceeding = val;
}

void TSummary::__set_filesLarge(const int64_t val) {
  this->filesLarge = val;
}
std::ostream& operator<<(std::ostream& out, const TSummary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSummary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->summary.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _ktype121;
            ::apache::thrift::protocol::TType _vtype122;
            xfer += iprot->readMapBegin(_ktype121, _vtype122, _size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              std::string _key125;
              xfer += iprot->readString(_key125);
              int64_t& _val126 = this->summary[_key125];
              xfer += iprot->readI64(_val126);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filesContaining);
          this->__isset.filesContaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filesExceeding);
          this->__isset.filesExceeding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filesLarge);
          this->__isset.filesLarge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSummary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSummary");

  xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->summary.size()));
    std::map<std::string, int64_t> ::const_iterator _iter127;
    for (_iter127 = this->summary.begin(); _iter127 != this->summary.end(); ++_iter127)
    {
      xfer += oprot->writeString(_iter127->first);
      xfer += oprot->writeI64(_iter127->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filesContaining", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->filesContaining);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filesExceeding", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->filesExceeding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filesLarge", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->filesLarge);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSummary &a, TSummary &b) {
  using ::std::swap;
  swap(a.summary, b.summary);
  swap(a.config, b.config);
  swap(a.filesContaining, b.filesContaining);
  swap(a.filesExceeding, b.filesExceeding);
  swap(a.filesLarge, b.filesLarge);
  swap(a.__isset, b.__isset);
}

TSummary::TSummary(const TSummary& other128) {
  summary = other128.summary;
  config = other128.config;
  filesContaining = other128.filesContaining;
  filesExceeding = other128.filesExceeding;
  filesLarge = other128.filesLarge;
  __isset = other128.__isset;
}
TSummary& TSummary::operator=(const TSummary& other129) {
  summary = other129.summary;
  config = other129.config;
  filesContaining = other129.filesContaining;
  filesExceeding = other129.filesExceeding;
  filesLarge = other129.filesLarge;
  __isset = other129.__isset;
  return *this;
}
void TSummary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSummary(";
  out << "summary=" << to_string(summary);
  out << ", " << "config=" << to_string(config);
  out << ", " << "filesContaining=" << to_string(filesContaining);
  out << ", " << "filesExceeding=" << to_string(filesExceeding);
  out << ", " << "filesLarge=" << to_string(filesLarge);
  out << ")";
}


TSummaries::~TSummaries() throw() {
}


void TSummaries::__set_finished(const bool val) {
  this->finished = val;
}

void TSummaries::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSummaries::__set_totalFiles(const int64_t val) {
  this->totalFiles = val;
}

void TSummaries::__set_deletedFiles(const int64_t val) {
  this->deletedFiles = val;
}

void TSummaries::__set_summaries(const std::vector<TSummary> & val) {
  this->summaries = val;
}
std::ostream& operator<<(std::ostream& out, const TSummaries& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSummaries::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->finished);
          this->__isset.finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->totalFiles);
          this->__isset.totalFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deletedFiles);
          this->__isset.deletedFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->summaries.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->summaries.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += this->summaries[_i134].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.summaries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSummaries::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSummaries");

  xfer += oprot->writeFieldBegin("finished", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalFiles", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->totalFiles);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deletedFiles", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->deletedFiles);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("summaries", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->summaries.size()));
    std::vector<TSummary> ::const_iterator _iter135;
    for (_iter135 = this->summaries.begin(); _iter135 != this->summaries.end(); ++_iter135)
    {
      xfer += (*_iter135).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSummaries &a, TSummaries &b) {
  using ::std::swap;
  swap(a.finished, b.finished);
  swap(a.sessionId, b.sessionId);
  swap(a.totalFiles, b.totalFiles);
  swap(a.deletedFiles, b.deletedFiles);
  swap(a.summaries, b.summaries);
  swap(a.__isset, b.__isset);
}

TSummaries::TSummaries(const TSummaries& other136) {
  finished = other136.finished;
  sessionId = other136.sessionId;
  totalFiles = other136.totalFiles;
  deletedFiles = other136.deletedFiles;
  summaries = other136.summaries;
  __isset = other136.__isset;
}
TSummaries& TSummaries::operator=(const TSummaries& other137) {
  finished = other137.finished;
  sessionId = other137.sessionId;
  totalFiles = other137.totalFiles;
  deletedFiles = other137.deletedFiles;
  summaries = other137.summaries;
  __isset = other137.__isset;
  return *this;
}
void TSummaries::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSummaries(";
  out << "finished=" << to_string(finished);
  out << ", " << "sessionId=" << to_string(sessionId);
  out << ", " << "totalFiles=" << to_string(totalFiles);
  out << ", " << "deletedFiles=" << to_string(deletedFiles);
  out << ", " << "summaries=" << to_string(summaries);
  out << ")";
}


TRowRange::~TRowRange() throw() {
}


void TRowRange::__set_startRow(const std::string& val) {
  this->startRow = val;
}

void TRowRange::__set_endRow(const std::string& val) {
  this->endRow = val;
}
std::ostream& operator<<(std::ostream& out, const TRowRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowRange");

  xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->startRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowRange &a, TRowRange &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.endRow, b.endRow);
  swap(a.__isset, b.__isset);
}

TRowRange::TRowRange(const TRowRange& other138) {
  startRow = other138.startRow;
  endRow = other138.endRow;
  __isset = other138.__isset;
}
TRowRange& TRowRange::operator=(const TRowRange& other139) {
  startRow = other139.startRow;
  endRow = other139.endRow;
  __isset = other139.__isset;
  return *this;
}
void TRowRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowRange(";
  out << "startRow=" << to_string(startRow);
  out << ", " << "endRow=" << to_string(endRow);
  out << ")";
}


TSummaryRequest::~TSummaryRequest() throw() {
}


void TSummaryRequest::__set_tableId(const std::string& val) {
  this->tableId = val;
}

void TSummaryRequest::__set_bounds(const TRowRange& val) {
  this->bounds = val;
}

void TSummaryRequest::__set_summarizers(const std::vector<TSummarizerConfiguration> & val) {
  this->summarizers = val;
}

void TSummaryRequest::__set_summarizerPattern(const std::string& val) {
  this->summarizerPattern = val;
}
std::ostream& operator<<(std::ostream& out, const TSummaryRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSummaryRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bounds.read(iprot);
          this->__isset.bounds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->summarizers.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->summarizers.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->summarizers[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.summarizers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summarizerPattern);
          this->__isset.summarizerPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSummaryRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSummaryRequest");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bounds", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->bounds.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("summarizers", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->summarizers.size()));
    std::vector<TSummarizerConfiguration> ::const_iterator _iter145;
    for (_iter145 = this->summarizers.begin(); _iter145 != this->summarizers.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("summarizerPattern", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->summarizerPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSummaryRequest &a, TSummaryRequest &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.bounds, b.bounds);
  swap(a.summarizers, b.summarizers);
  swap(a.summarizerPattern, b.summarizerPattern);
  swap(a.__isset, b.__isset);
}

TSummaryRequest::TSummaryRequest(const TSummaryRequest& other146) {
  tableId = other146.tableId;
  bounds = other146.bounds;
  summarizers = other146.summarizers;
  summarizerPattern = other146.summarizerPattern;
  __isset = other146.__isset;
}
TSummaryRequest& TSummaryRequest::operator=(const TSummaryRequest& other147) {
  tableId = other147.tableId;
  bounds = other147.bounds;
  summarizers = other147.summarizers;
  summarizerPattern = other147.summarizerPattern;
  __isset = other147.__isset;
  return *this;
}
void TSummaryRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSummaryRequest(";
  out << "tableId=" << to_string(tableId);
  out << ", " << "bounds=" << to_string(bounds);
  out << ", " << "summarizers=" << to_string(summarizers);
  out << ", " << "summarizerPattern=" << to_string(summarizerPattern);
  out << ")";
}

}}}}}} // namespace
