/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data/extern/thriftv2/master_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace org { namespace apache { namespace accumulov2 { namespace core { namespace master { namespace thrift {

int _kBulkImportStateValues[] = {
  BulkImportState::INITIAL,
  BulkImportState::MOVING,
  BulkImportState::PROCESSING,
  BulkImportState::ASSIGNING,
  BulkImportState::LOADING,
  BulkImportState::COPY_FILES,
  BulkImportState::CLEANUP
};
const char* _kBulkImportStateNames[] = {
  "INITIAL",
  "MOVING",
  "PROCESSING",
  "ASSIGNING",
  "LOADING",
  "COPY_FILES",
  "CLEANUP"
};
const std::map<int, const char*> _BulkImportState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kBulkImportStateValues, _kBulkImportStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BulkImportState::type& val) {
  std::map<int, const char*>::const_iterator it = _BulkImportState_VALUES_TO_NAMES.find(val);
  if (it != _BulkImportState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kMasterStateValues[] = {
  MasterState::INITIAL,
  MasterState::HAVE_LOCK,
  MasterState::SAFE_MODE,
  MasterState::NORMAL,
  MasterState::UNLOAD_METADATA_TABLETS,
  MasterState::UNLOAD_ROOT_TABLET,
  MasterState::STOP
};
const char* _kMasterStateNames[] = {
  "INITIAL",
  "HAVE_LOCK",
  "SAFE_MODE",
  "NORMAL",
  "UNLOAD_METADATA_TABLETS",
  "UNLOAD_ROOT_TABLET",
  "STOP"
};
const std::map<int, const char*> _MasterState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMasterStateValues, _kMasterStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MasterState::type& val) {
  std::map<int, const char*>::const_iterator it = _MasterState_VALUES_TO_NAMES.find(val);
  if (it != _MasterState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kMasterGoalStateValues[] = {
  MasterGoalState::CLEAN_STOP,
  MasterGoalState::SAFE_MODE,
  MasterGoalState::NORMAL
};
const char* _kMasterGoalStateNames[] = {
  "CLEAN_STOP",
  "SAFE_MODE",
  "NORMAL"
};
const std::map<int, const char*> _MasterGoalState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMasterGoalStateValues, _kMasterGoalStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MasterGoalState::type& val) {
  std::map<int, const char*>::const_iterator it = _MasterGoalState_VALUES_TO_NAMES.find(val);
  if (it != _MasterGoalState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTabletLoadStateValues[] = {
  TabletLoadState::LOADED,
  TabletLoadState::LOAD_FAILURE,
  TabletLoadState::UNLOADED,
  TabletLoadState::UNLOAD_FAILURE_NOT_SERVING,
  TabletLoadState::UNLOAD_ERROR,
  TabletLoadState::CHOPPED
};
const char* _kTabletLoadStateNames[] = {
  "LOADED",
  "LOAD_FAILURE",
  "UNLOADED",
  "UNLOAD_FAILURE_NOT_SERVING",
  "UNLOAD_ERROR",
  "CHOPPED"
};
const std::map<int, const char*> _TabletLoadState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTabletLoadStateValues, _kTabletLoadStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TabletLoadState::type& val) {
  std::map<int, const char*>::const_iterator it = _TabletLoadState_VALUES_TO_NAMES.find(val);
  if (it != _TabletLoadState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kFateOperationValues[] = {
  FateOperation::TABLE_CREATE,
  FateOperation::TABLE_CLONE,
  FateOperation::TABLE_DELETE,
  FateOperation::TABLE_RENAME,
  FateOperation::TABLE_ONLINE,
  FateOperation::TABLE_OFFLINE,
  FateOperation::TABLE_MERGE,
  FateOperation::TABLE_DELETE_RANGE,
  FateOperation::TABLE_BULK_IMPORT,
  FateOperation::TABLE_COMPACT,
  FateOperation::TABLE_IMPORT,
  FateOperation::TABLE_EXPORT,
  FateOperation::TABLE_CANCEL_COMPACT,
  FateOperation::NAMESPACE_CREATE,
  FateOperation::NAMESPACE_DELETE,
  FateOperation::NAMESPACE_RENAME,
  FateOperation::TABLE_BULK_IMPORT2
};
const char* _kFateOperationNames[] = {
  "TABLE_CREATE",
  "TABLE_CLONE",
  "TABLE_DELETE",
  "TABLE_RENAME",
  "TABLE_ONLINE",
  "TABLE_OFFLINE",
  "TABLE_MERGE",
  "TABLE_DELETE_RANGE",
  "TABLE_BULK_IMPORT",
  "TABLE_COMPACT",
  "TABLE_IMPORT",
  "TABLE_EXPORT",
  "TABLE_CANCEL_COMPACT",
  "NAMESPACE_CREATE",
  "NAMESPACE_DELETE",
  "NAMESPACE_RENAME",
  "TABLE_BULK_IMPORT2"
};
const std::map<int, const char*> _FateOperation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kFateOperationValues, _kFateOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FateOperation::type& val) {
  std::map<int, const char*>::const_iterator it = _FateOperation_VALUES_TO_NAMES.find(val);
  if (it != _FateOperation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Compacting::~Compacting() throw() {
}


void Compacting::__set_running(const int32_t val) {
  this->running = val;
}

void Compacting::__set_queued(const int32_t val) {
  this->queued = val;
}
std::ostream& operator<<(std::ostream& out, const Compacting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Compacting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->running);
          this->__isset.running = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queued);
          this->__isset.queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Compacting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Compacting");

  xfer += oprot->writeFieldBegin("running", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->running);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queued", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->queued);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Compacting &a, Compacting &b) {
  using ::std::swap;
  swap(a.running, b.running);
  swap(a.queued, b.queued);
  swap(a.__isset, b.__isset);
}

Compacting::Compacting(const Compacting& other0) {
  running = other0.running;
  queued = other0.queued;
  __isset = other0.__isset;
}
Compacting& Compacting::operator=(const Compacting& other1) {
  running = other1.running;
  queued = other1.queued;
  __isset = other1.__isset;
  return *this;
}
void Compacting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Compacting(";
  out << "running=" << to_string(running);
  out << ", " << "queued=" << to_string(queued);
  out << ")";
}


TableInfo::~TableInfo() throw() {
}


void TableInfo::__set_recs(const int64_t val) {
  this->recs = val;
}

void TableInfo::__set_recsInMemory(const int64_t val) {
  this->recsInMemory = val;
}

void TableInfo::__set_tablets(const int32_t val) {
  this->tablets = val;
}

void TableInfo::__set_onlineTablets(const int32_t val) {
  this->onlineTablets = val;
}

void TableInfo::__set_ingestRate(const double val) {
  this->ingestRate = val;
}

void TableInfo::__set_ingestByteRate(const double val) {
  this->ingestByteRate = val;
}

void TableInfo::__set_queryRate(const double val) {
  this->queryRate = val;
}

void TableInfo::__set_queryByteRate(const double val) {
  this->queryByteRate = val;
}

void TableInfo::__set_minors(const Compacting& val) {
  this->minors = val;
}

void TableInfo::__set_majors(const Compacting& val) {
  this->majors = val;
}

void TableInfo::__set_scans(const Compacting& val) {
  this->scans = val;
}

void TableInfo::__set_scanRate(const double val) {
  this->scanRate = val;
}
std::ostream& operator<<(std::ostream& out, const TableInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recs);
          this->__isset.recs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->recsInMemory);
          this->__isset.recsInMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tablets);
          this->__isset.tablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->onlineTablets);
          this->__isset.onlineTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ingestRate);
          this->__isset.ingestRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ingestByteRate);
          this->__isset.ingestByteRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queryRate);
          this->__isset.queryRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->queryByteRate);
          this->__isset.queryByteRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->minors.read(iprot);
          this->__isset.minors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->majors.read(iprot);
          this->__isset.majors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scans.read(iprot);
          this->__isset.scans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->scanRate);
          this->__isset.scanRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableInfo");

  xfer += oprot->writeFieldBegin("recs", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->recs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recsInMemory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->recsInMemory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablets", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->tablets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("onlineTablets", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->onlineTablets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ingestRate", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->ingestRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ingestByteRate", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->ingestByteRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryRate", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->queryRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryByteRate", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->queryByteRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minors", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->minors.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("majors", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->majors.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scans", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->scans.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scanRate", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->scanRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableInfo &a, TableInfo &b) {
  using ::std::swap;
  swap(a.recs, b.recs);
  swap(a.recsInMemory, b.recsInMemory);
  swap(a.tablets, b.tablets);
  swap(a.onlineTablets, b.onlineTablets);
  swap(a.ingestRate, b.ingestRate);
  swap(a.ingestByteRate, b.ingestByteRate);
  swap(a.queryRate, b.queryRate);
  swap(a.queryByteRate, b.queryByteRate);
  swap(a.minors, b.minors);
  swap(a.majors, b.majors);
  swap(a.scans, b.scans);
  swap(a.scanRate, b.scanRate);
  swap(a.__isset, b.__isset);
}

TableInfo::TableInfo(const TableInfo& other2) {
  recs = other2.recs;
  recsInMemory = other2.recsInMemory;
  tablets = other2.tablets;
  onlineTablets = other2.onlineTablets;
  ingestRate = other2.ingestRate;
  ingestByteRate = other2.ingestByteRate;
  queryRate = other2.queryRate;
  queryByteRate = other2.queryByteRate;
  minors = other2.minors;
  majors = other2.majors;
  scans = other2.scans;
  scanRate = other2.scanRate;
  __isset = other2.__isset;
}
TableInfo& TableInfo::operator=(const TableInfo& other3) {
  recs = other3.recs;
  recsInMemory = other3.recsInMemory;
  tablets = other3.tablets;
  onlineTablets = other3.onlineTablets;
  ingestRate = other3.ingestRate;
  ingestByteRate = other3.ingestByteRate;
  queryRate = other3.queryRate;
  queryByteRate = other3.queryByteRate;
  minors = other3.minors;
  majors = other3.majors;
  scans = other3.scans;
  scanRate = other3.scanRate;
  __isset = other3.__isset;
  return *this;
}
void TableInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableInfo(";
  out << "recs=" << to_string(recs);
  out << ", " << "recsInMemory=" << to_string(recsInMemory);
  out << ", " << "tablets=" << to_string(tablets);
  out << ", " << "onlineTablets=" << to_string(onlineTablets);
  out << ", " << "ingestRate=" << to_string(ingestRate);
  out << ", " << "ingestByteRate=" << to_string(ingestByteRate);
  out << ", " << "queryRate=" << to_string(queryRate);
  out << ", " << "queryByteRate=" << to_string(queryByteRate);
  out << ", " << "minors=" << to_string(minors);
  out << ", " << "majors=" << to_string(majors);
  out << ", " << "scans=" << to_string(scans);
  out << ", " << "scanRate=" << to_string(scanRate);
  out << ")";
}


RecoveryStatus::~RecoveryStatus() throw() {
}


void RecoveryStatus::__set_name(const std::string& val) {
  this->name = val;
}

void RecoveryStatus::__set_runtime(const int32_t val) {
  this->runtime = val;
}

void RecoveryStatus::__set_progress(const double val) {
  this->progress = val;
}
std::ostream& operator<<(std::ostream& out, const RecoveryStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RecoveryStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->runtime);
          this->__isset.runtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecoveryStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecoveryStatus");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runtime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->runtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecoveryStatus &a, RecoveryStatus &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.runtime, b.runtime);
  swap(a.progress, b.progress);
  swap(a.__isset, b.__isset);
}

RecoveryStatus::RecoveryStatus(const RecoveryStatus& other4) {
  name = other4.name;
  runtime = other4.runtime;
  progress = other4.progress;
  __isset = other4.__isset;
}
RecoveryStatus& RecoveryStatus::operator=(const RecoveryStatus& other5) {
  name = other5.name;
  runtime = other5.runtime;
  progress = other5.progress;
  __isset = other5.__isset;
  return *this;
}
void RecoveryStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecoveryStatus(";
  out << "name=" << to_string(name);
  out << ", " << "runtime=" << to_string(runtime);
  out << ", " << "progress=" << to_string(progress);
  out << ")";
}


BulkImportStatus::~BulkImportStatus() throw() {
}


void BulkImportStatus::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void BulkImportStatus::__set_filename(const std::string& val) {
  this->filename = val;
}

void BulkImportStatus::__set_state(const BulkImportState::type val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const BulkImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BulkImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          this->__isset.filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->state = (BulkImportState::type)ecast6;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkImportStatus");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkImportStatus &a, BulkImportStatus &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
  swap(a.filename, b.filename);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

BulkImportStatus::BulkImportStatus(const BulkImportStatus& other7) {
  startTime = other7.startTime;
  filename = other7.filename;
  state = other7.state;
  __isset = other7.__isset;
}
BulkImportStatus& BulkImportStatus::operator=(const BulkImportStatus& other8) {
  startTime = other8.startTime;
  filename = other8.filename;
  state = other8.state;
  __isset = other8.__isset;
  return *this;
}
void BulkImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkImportStatus(";
  out << "startTime=" << to_string(startTime);
  out << ", " << "filename=" << to_string(filename);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


TabletServerStatus::~TabletServerStatus() throw() {
}


void TabletServerStatus::__set_tableMap(const std::map<std::string, TableInfo> & val) {
  this->tableMap = val;
}

void TabletServerStatus::__set_lastContact(const int64_t val) {
  this->lastContact = val;
}

void TabletServerStatus::__set_name(const std::string& val) {
  this->name = val;
}

void TabletServerStatus::__set_osLoad(const double val) {
  this->osLoad = val;
}

void TabletServerStatus::__set_holdTime(const int64_t val) {
  this->holdTime = val;
}

void TabletServerStatus::__set_lookups(const int64_t val) {
  this->lookups = val;
}

void TabletServerStatus::__set_indexCacheHits(const int64_t val) {
  this->indexCacheHits = val;
}

void TabletServerStatus::__set_indexCacheRequest(const int64_t val) {
  this->indexCacheRequest = val;
}

void TabletServerStatus::__set_dataCacheHits(const int64_t val) {
  this->dataCacheHits = val;
}

void TabletServerStatus::__set_dataCacheRequest(const int64_t val) {
  this->dataCacheRequest = val;
}

void TabletServerStatus::__set_logSorts(const std::vector<RecoveryStatus> & val) {
  this->logSorts = val;
}

void TabletServerStatus::__set_flushs(const int64_t val) {
  this->flushs = val;
}

void TabletServerStatus::__set_syncs(const int64_t val) {
  this->syncs = val;
}

void TabletServerStatus::__set_bulkImports(const std::vector<BulkImportStatus> & val) {
  this->bulkImports = val;
}

void TabletServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TabletServerStatus::__set_responseTime(const int64_t val) {
  this->responseTime = val;
}
std::ostream& operator<<(std::ostream& out, const TabletServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TabletServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tableMap.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              std::string _key14;
              xfer += iprot->readString(_key14);
              TableInfo& _val15 = this->tableMap[_key14];
              xfer += _val15.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tableMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastContact);
          this->__isset.lastContact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->osLoad);
          this->__isset.osLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->holdTime);
          this->__isset.holdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lookups);
          this->__isset.lookups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->indexCacheHits);
          this->__isset.indexCacheHits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->indexCacheRequest);
          this->__isset.indexCacheRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataCacheHits);
          this->__isset.dataCacheHits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dataCacheRequest);
          this->__isset.dataCacheRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logSorts.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->logSorts.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->logSorts[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logSorts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->flushs);
          this->__isset.flushs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->syncs);
          this->__isset.syncs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bulkImports.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->bulkImports.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->bulkImports[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bulkImports = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->responseTime);
          this->__isset.responseTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletServerStatus");

  xfer += oprot->writeFieldBegin("tableMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableMap.size()));
    std::map<std::string, TableInfo> ::const_iterator _iter26;
    for (_iter26 = this->tableMap.begin(); _iter26 != this->tableMap.end(); ++_iter26)
    {
      xfer += oprot->writeString(_iter26->first);
      xfer += _iter26->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastContact", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastContact);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("osLoad", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->osLoad);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("holdTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->holdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lookups", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lookups);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexCacheHits", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->indexCacheHits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexCacheRequest", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->indexCacheRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataCacheHits", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->dataCacheHits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataCacheRequest", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->dataCacheRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("logSorts", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->logSorts.size()));
    std::vector<RecoveryStatus> ::const_iterator _iter27;
    for (_iter27 = this->logSorts.begin(); _iter27 != this->logSorts.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flushs", ::apache::thrift::protocol::T_I64, 15);
  xfer += oprot->writeI64(this->flushs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncs", ::apache::thrift::protocol::T_I64, 16);
  xfer += oprot->writeI64(this->syncs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulkImports", ::apache::thrift::protocol::T_LIST, 17);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bulkImports.size()));
    std::vector<BulkImportStatus> ::const_iterator _iter28;
    for (_iter28 = this->bulkImports.begin(); _iter28 != this->bulkImports.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responseTime", ::apache::thrift::protocol::T_I64, 18);
  xfer += oprot->writeI64(this->responseTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TabletServerStatus &a, TabletServerStatus &b) {
  using ::std::swap;
  swap(a.tableMap, b.tableMap);
  swap(a.lastContact, b.lastContact);
  swap(a.name, b.name);
  swap(a.osLoad, b.osLoad);
  swap(a.holdTime, b.holdTime);
  swap(a.lookups, b.lookups);
  swap(a.indexCacheHits, b.indexCacheHits);
  swap(a.indexCacheRequest, b.indexCacheRequest);
  swap(a.dataCacheHits, b.dataCacheHits);
  swap(a.dataCacheRequest, b.dataCacheRequest);
  swap(a.logSorts, b.logSorts);
  swap(a.flushs, b.flushs);
  swap(a.syncs, b.syncs);
  swap(a.bulkImports, b.bulkImports);
  swap(a.version, b.version);
  swap(a.responseTime, b.responseTime);
  swap(a.__isset, b.__isset);
}

TabletServerStatus::TabletServerStatus(const TabletServerStatus& other29) {
  tableMap = other29.tableMap;
  lastContact = other29.lastContact;
  name = other29.name;
  osLoad = other29.osLoad;
  holdTime = other29.holdTime;
  lookups = other29.lookups;
  indexCacheHits = other29.indexCacheHits;
  indexCacheRequest = other29.indexCacheRequest;
  dataCacheHits = other29.dataCacheHits;
  dataCacheRequest = other29.dataCacheRequest;
  logSorts = other29.logSorts;
  flushs = other29.flushs;
  syncs = other29.syncs;
  bulkImports = other29.bulkImports;
  version = other29.version;
  responseTime = other29.responseTime;
  __isset = other29.__isset;
}
TabletServerStatus& TabletServerStatus::operator=(const TabletServerStatus& other30) {
  tableMap = other30.tableMap;
  lastContact = other30.lastContact;
  name = other30.name;
  osLoad = other30.osLoad;
  holdTime = other30.holdTime;
  lookups = other30.lookups;
  indexCacheHits = other30.indexCacheHits;
  indexCacheRequest = other30.indexCacheRequest;
  dataCacheHits = other30.dataCacheHits;
  dataCacheRequest = other30.dataCacheRequest;
  logSorts = other30.logSorts;
  flushs = other30.flushs;
  syncs = other30.syncs;
  bulkImports = other30.bulkImports;
  version = other30.version;
  responseTime = other30.responseTime;
  __isset = other30.__isset;
  return *this;
}
void TabletServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TabletServerStatus(";
  out << "tableMap=" << to_string(tableMap);
  out << ", " << "lastContact=" << to_string(lastContact);
  out << ", " << "name=" << to_string(name);
  out << ", " << "osLoad=" << to_string(osLoad);
  out << ", " << "holdTime=" << to_string(holdTime);
  out << ", " << "lookups=" << to_string(lookups);
  out << ", " << "indexCacheHits=" << to_string(indexCacheHits);
  out << ", " << "indexCacheRequest=" << to_string(indexCacheRequest);
  out << ", " << "dataCacheHits=" << to_string(dataCacheHits);
  out << ", " << "dataCacheRequest=" << to_string(dataCacheRequest);
  out << ", " << "logSorts=" << to_string(logSorts);
  out << ", " << "flushs=" << to_string(flushs);
  out << ", " << "syncs=" << to_string(syncs);
  out << ", " << "bulkImports=" << to_string(bulkImports);
  out << ", " << "version=" << to_string(version);
  out << ", " << "responseTime=" << to_string(responseTime);
  out << ")";
}


DeadServer::~DeadServer() throw() {
}


void DeadServer::__set_server(const std::string& val) {
  this->server = val;
}

void DeadServer::__set_lastStatus(const int64_t val) {
  this->lastStatus = val;
}

void DeadServer::__set_status(const std::string& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const DeadServer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeadServer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server);
          this->__isset.server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastStatus);
          this->__isset.lastStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeadServer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeadServer");

  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->server);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastStatus", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lastStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeadServer &a, DeadServer &b) {
  using ::std::swap;
  swap(a.server, b.server);
  swap(a.lastStatus, b.lastStatus);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

DeadServer::DeadServer(const DeadServer& other31) {
  server = other31.server;
  lastStatus = other31.lastStatus;
  status = other31.status;
  __isset = other31.__isset;
}
DeadServer& DeadServer::operator=(const DeadServer& other32) {
  server = other32.server;
  lastStatus = other32.lastStatus;
  status = other32.status;
  __isset = other32.__isset;
  return *this;
}
void DeadServer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeadServer(";
  out << "server=" << to_string(server);
  out << ", " << "lastStatus=" << to_string(lastStatus);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


MasterMonitorInfo::~MasterMonitorInfo() throw() {
}


void MasterMonitorInfo::__set_tableMap(const std::map<std::string, TableInfo> & val) {
  this->tableMap = val;
}

void MasterMonitorInfo::__set_tServerInfo(const std::vector<TabletServerStatus> & val) {
  this->tServerInfo = val;
}

void MasterMonitorInfo::__set_badTServers(const std::map<std::string, int8_t> & val) {
  this->badTServers = val;
}

void MasterMonitorInfo::__set_state(const MasterState::type val) {
  this->state = val;
}

void MasterMonitorInfo::__set_goalState(const MasterGoalState::type val) {
  this->goalState = val;
}

void MasterMonitorInfo::__set_unassignedTablets(const int32_t val) {
  this->unassignedTablets = val;
}

void MasterMonitorInfo::__set_serversShuttingDown(const std::set<std::string> & val) {
  this->serversShuttingDown = val;
}

void MasterMonitorInfo::__set_deadTabletServers(const std::vector<DeadServer> & val) {
  this->deadTabletServers = val;
}

void MasterMonitorInfo::__set_bulkImports(const std::vector<BulkImportStatus> & val) {
  this->bulkImports = val;
}
std::ostream& operator<<(std::ostream& out, const MasterMonitorInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MasterMonitorInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tableMap.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _ktype34;
            ::apache::thrift::protocol::TType _vtype35;
            xfer += iprot->readMapBegin(_ktype34, _vtype35, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _key38;
              xfer += iprot->readString(_key38);
              TableInfo& _val39 = this->tableMap[_key38];
              xfer += _val39.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tableMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tServerInfo.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->tServerInfo.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->tServerInfo[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tServerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->badTServers.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _ktype46;
            ::apache::thrift::protocol::TType _vtype47;
            xfer += iprot->readMapBegin(_ktype46, _vtype47, _size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              std::string _key50;
              xfer += iprot->readString(_key50);
              int8_t& _val51 = this->badTServers[_key50];
              xfer += iprot->readByte(_val51);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.badTServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->state = (MasterState::type)ecast52;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->goalState = (MasterGoalState::type)ecast53;
          this->__isset.goalState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->unassignedTablets);
          this->__isset.unassignedTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serversShuttingDown.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readSetBegin(_etype57, _size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              std::string _elem59;
              xfer += iprot->readString(_elem59);
              this->serversShuttingDown.insert(_elem59);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serversShuttingDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deadTabletServers.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->deadTabletServers.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->deadTabletServers[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deadTabletServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bulkImports.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->bulkImports.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->bulkImports[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bulkImports = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MasterMonitorInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MasterMonitorInfo");

  xfer += oprot->writeFieldBegin("tableMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableMap.size()));
    std::map<std::string, TableInfo> ::const_iterator _iter70;
    for (_iter70 = this->tableMap.begin(); _iter70 != this->tableMap.end(); ++_iter70)
    {
      xfer += oprot->writeString(_iter70->first);
      xfer += _iter70->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tServerInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tServerInfo.size()));
    std::vector<TabletServerStatus> ::const_iterator _iter71;
    for (_iter71 = this->tServerInfo.begin(); _iter71 != this->tServerInfo.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("badTServers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->badTServers.size()));
    std::map<std::string, int8_t> ::const_iterator _iter72;
    for (_iter72 = this->badTServers.begin(); _iter72 != this->badTServers.end(); ++_iter72)
    {
      xfer += oprot->writeString(_iter72->first);
      xfer += oprot->writeByte(_iter72->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unassignedTablets", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->unassignedTablets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goalState", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->goalState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serversShuttingDown", ::apache::thrift::protocol::T_SET, 9);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serversShuttingDown.size()));
    std::set<std::string> ::const_iterator _iter73;
    for (_iter73 = this->serversShuttingDown.begin(); _iter73 != this->serversShuttingDown.end(); ++_iter73)
    {
      xfer += oprot->writeString((*_iter73));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deadTabletServers", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deadTabletServers.size()));
    std::vector<DeadServer> ::const_iterator _iter74;
    for (_iter74 = this->deadTabletServers.begin(); _iter74 != this->deadTabletServers.end(); ++_iter74)
    {
      xfer += (*_iter74).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulkImports", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bulkImports.size()));
    std::vector<BulkImportStatus> ::const_iterator _iter75;
    for (_iter75 = this->bulkImports.begin(); _iter75 != this->bulkImports.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MasterMonitorInfo &a, MasterMonitorInfo &b) {
  using ::std::swap;
  swap(a.tableMap, b.tableMap);
  swap(a.tServerInfo, b.tServerInfo);
  swap(a.badTServers, b.badTServers);
  swap(a.state, b.state);
  swap(a.goalState, b.goalState);
  swap(a.unassignedTablets, b.unassignedTablets);
  swap(a.serversShuttingDown, b.serversShuttingDown);
  swap(a.deadTabletServers, b.deadTabletServers);
  swap(a.bulkImports, b.bulkImports);
  swap(a.__isset, b.__isset);
}

MasterMonitorInfo::MasterMonitorInfo(const MasterMonitorInfo& other76) {
  tableMap = other76.tableMap;
  tServerInfo = other76.tServerInfo;
  badTServers = other76.badTServers;
  state = other76.state;
  goalState = other76.goalState;
  unassignedTablets = other76.unassignedTablets;
  serversShuttingDown = other76.serversShuttingDown;
  deadTabletServers = other76.deadTabletServers;
  bulkImports = other76.bulkImports;
  __isset = other76.__isset;
}
MasterMonitorInfo& MasterMonitorInfo::operator=(const MasterMonitorInfo& other77) {
  tableMap = other77.tableMap;
  tServerInfo = other77.tServerInfo;
  badTServers = other77.badTServers;
  state = other77.state;
  goalState = other77.goalState;
  unassignedTablets = other77.unassignedTablets;
  serversShuttingDown = other77.serversShuttingDown;
  deadTabletServers = other77.deadTabletServers;
  bulkImports = other77.bulkImports;
  __isset = other77.__isset;
  return *this;
}
void MasterMonitorInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MasterMonitorInfo(";
  out << "tableMap=" << to_string(tableMap);
  out << ", " << "tServerInfo=" << to_string(tServerInfo);
  out << ", " << "badTServers=" << to_string(badTServers);
  out << ", " << "state=" << to_string(state);
  out << ", " << "goalState=" << to_string(goalState);
  out << ", " << "unassignedTablets=" << to_string(unassignedTablets);
  out << ", " << "serversShuttingDown=" << to_string(serversShuttingDown);
  out << ", " << "deadTabletServers=" << to_string(deadTabletServers);
  out << ", " << "bulkImports=" << to_string(bulkImports);
  out << ")";
}


TabletSplit::~TabletSplit() throw() {
}


void TabletSplit::__set_oldTablet(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val) {
  this->oldTablet = val;
}

void TabletSplit::__set_newTablets(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & val) {
  this->newTablets = val;
}
std::ostream& operator<<(std::ostream& out, const TabletSplit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TabletSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->oldTablet.read(iprot);
          this->__isset.oldTablet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newTablets.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->newTablets.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->newTablets[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.newTablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TabletSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TabletSplit");

  xfer += oprot->writeFieldBegin("oldTablet", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->oldTablet.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newTablets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->newTablets.size()));
    std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> ::const_iterator _iter83;
    for (_iter83 = this->newTablets.begin(); _iter83 != this->newTablets.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TabletSplit &a, TabletSplit &b) {
  using ::std::swap;
  swap(a.oldTablet, b.oldTablet);
  swap(a.newTablets, b.newTablets);
  swap(a.__isset, b.__isset);
}

TabletSplit::TabletSplit(const TabletSplit& other84) {
  oldTablet = other84.oldTablet;
  newTablets = other84.newTablets;
  __isset = other84.__isset;
}
TabletSplit& TabletSplit::operator=(const TabletSplit& other85) {
  oldTablet = other85.oldTablet;
  newTablets = other85.newTablets;
  __isset = other85.__isset;
  return *this;
}
void TabletSplit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TabletSplit(";
  out << "oldTablet=" << to_string(oldTablet);
  out << ", " << "newTablets=" << to_string(newTablets);
  out << ")";
}


RecoveryException::~RecoveryException() throw() {
}


void RecoveryException::__set_why(const std::string& val) {
  this->why = val;
}
std::ostream& operator<<(std::ostream& out, const RecoveryException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RecoveryException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecoveryException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecoveryException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecoveryException &a, RecoveryException &b) {
  using ::std::swap;
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

RecoveryException::RecoveryException(const RecoveryException& other86) : TException() {
  why = other86.why;
  __isset = other86.__isset;
}
RecoveryException& RecoveryException::operator=(const RecoveryException& other87) {
  why = other87.why;
  __isset = other87.__isset;
  return *this;
}
void RecoveryException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecoveryException(";
  out << "why=" << to_string(why);
  out << ")";
}

const char* RecoveryException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: RecoveryException";
  }
}

}}}}}} // namespace
