/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef master_TYPES_V2H
#define master_TYPES_V2H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "data_types.h"
#include "security_types.h"
#include "client_types.h"
#include "trace_types.h"


namespace org { namespace apache { namespace accumulov2 { namespace core { namespace master { namespace thrift {

struct BulkImportState {
  enum type {
    INITIAL = 0,
    MOVING = 1,
    PROCESSING = 2,
    ASSIGNING = 3,
    LOADING = 4,
    COPY_FILES = 5,
    CLEANUP = 6
  };
};

extern const std::map<int, const char*> _BulkImportState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const BulkImportState::type& val);

struct MasterState {
  enum type {
    INITIAL = 0,
    HAVE_LOCK = 1,
    SAFE_MODE = 2,
    NORMAL = 3,
    UNLOAD_METADATA_TABLETS = 4,
    UNLOAD_ROOT_TABLET = 5,
    STOP = 6
  };
};

extern const std::map<int, const char*> _MasterState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const MasterState::type& val);

struct MasterGoalState {
  enum type {
    CLEAN_STOP = 0,
    SAFE_MODE = 1,
    NORMAL = 2
  };
};

extern const std::map<int, const char*> _MasterGoalState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const MasterGoalState::type& val);

struct TabletLoadState {
  enum type {
    LOADED = 0,
    LOAD_FAILURE = 1,
    UNLOADED = 2,
    UNLOAD_FAILURE_NOT_SERVING = 3,
    UNLOAD_ERROR = 4,
    CHOPPED = 5
  };
};

extern const std::map<int, const char*> _TabletLoadState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TabletLoadState::type& val);

struct FateOperation {
  enum type {
    TABLE_CREATE = 0,
    TABLE_CLONE = 1,
    TABLE_DELETE = 2,
    TABLE_RENAME = 3,
    TABLE_ONLINE = 4,
    TABLE_OFFLINE = 5,
    TABLE_MERGE = 6,
    TABLE_DELETE_RANGE = 7,
    TABLE_BULK_IMPORT = 8,
    TABLE_COMPACT = 9,
    TABLE_IMPORT = 10,
    TABLE_EXPORT = 11,
    TABLE_CANCEL_COMPACT = 12,
    NAMESPACE_CREATE = 13,
    NAMESPACE_DELETE = 14,
    NAMESPACE_RENAME = 15,
    TABLE_BULK_IMPORT2 = 16
  };
};

extern const std::map<int, const char*> _FateOperation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FateOperation::type& val);

class Compacting;

class TableInfo;

class RecoveryStatus;

class BulkImportStatus;

class TabletServerStatus;

class DeadServer;

class MasterMonitorInfo;

class TabletSplit;

class RecoveryException;

typedef struct _Compacting__isset {
  _Compacting__isset() : running(false), queued(false) {}
  bool running :1;
  bool queued :1;
} _Compacting__isset;

class Compacting : public virtual ::apache::thrift::TBase {
 public:

  Compacting(const Compacting&);
  Compacting& operator=(const Compacting&);
  Compacting() : running(0), queued(0) {
  }

  virtual ~Compacting() throw();
  int32_t running;
  int32_t queued;

  _Compacting__isset __isset;

  void __set_running(const int32_t val);

  void __set_queued(const int32_t val);

  bool operator == (const Compacting & rhs) const
  {
    if (!(running == rhs.running))
      return false;
    if (!(queued == rhs.queued))
      return false;
    return true;
  }
  bool operator != (const Compacting &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Compacting & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Compacting &a, Compacting &b);

std::ostream& operator<<(std::ostream& out, const Compacting& obj);

typedef struct _TableInfo__isset {
  _TableInfo__isset() : recs(false), recsInMemory(false), tablets(false), onlineTablets(false), ingestRate(false), ingestByteRate(false), queryRate(false), queryByteRate(false), minors(false), majors(false), scans(false), scanRate(false) {}
  bool recs :1;
  bool recsInMemory :1;
  bool tablets :1;
  bool onlineTablets :1;
  bool ingestRate :1;
  bool ingestByteRate :1;
  bool queryRate :1;
  bool queryByteRate :1;
  bool minors :1;
  bool majors :1;
  bool scans :1;
  bool scanRate :1;
} _TableInfo__isset;

class TableInfo : public virtual ::apache::thrift::TBase {
 public:

  TableInfo(const TableInfo&);
  TableInfo& operator=(const TableInfo&);
  TableInfo() : recs(0), recsInMemory(0), tablets(0), onlineTablets(0), ingestRate(0), ingestByteRate(0), queryRate(0), queryByteRate(0), scanRate(0) {
  }

  virtual ~TableInfo() throw();
  int64_t recs;
  int64_t recsInMemory;
  int32_t tablets;
  int32_t onlineTablets;
  double ingestRate;
  double ingestByteRate;
  double queryRate;
  double queryByteRate;
  Compacting minors;
  Compacting majors;
  Compacting scans;
  double scanRate;

  _TableInfo__isset __isset;

  void __set_recs(const int64_t val);

  void __set_recsInMemory(const int64_t val);

  void __set_tablets(const int32_t val);

  void __set_onlineTablets(const int32_t val);

  void __set_ingestRate(const double val);

  void __set_ingestByteRate(const double val);

  void __set_queryRate(const double val);

  void __set_queryByteRate(const double val);

  void __set_minors(const Compacting& val);

  void __set_majors(const Compacting& val);

  void __set_scans(const Compacting& val);

  void __set_scanRate(const double val);

  bool operator == (const TableInfo & rhs) const
  {
    if (!(recs == rhs.recs))
      return false;
    if (!(recsInMemory == rhs.recsInMemory))
      return false;
    if (!(tablets == rhs.tablets))
      return false;
    if (!(onlineTablets == rhs.onlineTablets))
      return false;
    if (!(ingestRate == rhs.ingestRate))
      return false;
    if (!(ingestByteRate == rhs.ingestByteRate))
      return false;
    if (!(queryRate == rhs.queryRate))
      return false;
    if (!(queryByteRate == rhs.queryByteRate))
      return false;
    if (!(minors == rhs.minors))
      return false;
    if (!(majors == rhs.majors))
      return false;
    if (!(scans == rhs.scans))
      return false;
    if (!(scanRate == rhs.scanRate))
      return false;
    return true;
  }
  bool operator != (const TableInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableInfo &a, TableInfo &b);

std::ostream& operator<<(std::ostream& out, const TableInfo& obj);

typedef struct _RecoveryStatus__isset {
  _RecoveryStatus__isset() : name(false), runtime(false), progress(false) {}
  bool name :1;
  bool runtime :1;
  bool progress :1;
} _RecoveryStatus__isset;

class RecoveryStatus : public virtual ::apache::thrift::TBase {
 public:

  RecoveryStatus(const RecoveryStatus&);
  RecoveryStatus& operator=(const RecoveryStatus&);
  RecoveryStatus() : name(), runtime(0), progress(0) {
  }

  virtual ~RecoveryStatus() throw();
  std::string name;
  int32_t runtime;
  double progress;

  _RecoveryStatus__isset __isset;

  void __set_name(const std::string& val);

  void __set_runtime(const int32_t val);

  void __set_progress(const double val);

  bool operator == (const RecoveryStatus & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(runtime == rhs.runtime))
      return false;
    if (!(progress == rhs.progress))
      return false;
    return true;
  }
  bool operator != (const RecoveryStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecoveryStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RecoveryStatus &a, RecoveryStatus &b);

std::ostream& operator<<(std::ostream& out, const RecoveryStatus& obj);

typedef struct _BulkImportStatus__isset {
  _BulkImportStatus__isset() : startTime(false), filename(false), state(false) {}
  bool startTime :1;
  bool filename :1;
  bool state :1;
} _BulkImportStatus__isset;

class BulkImportStatus : public virtual ::apache::thrift::TBase {
 public:

  BulkImportStatus(const BulkImportStatus&);
  BulkImportStatus& operator=(const BulkImportStatus&);
  BulkImportStatus() : startTime(0), filename(), state((BulkImportState::type)0) {
  }

  virtual ~BulkImportStatus() throw();
  int64_t startTime;
  std::string filename;
  BulkImportState::type state;

  _BulkImportStatus__isset __isset;

  void __set_startTime(const int64_t val);

  void __set_filename(const std::string& val);

  void __set_state(const BulkImportState::type val);

  bool operator == (const BulkImportStatus & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    if (!(filename == rhs.filename))
      return false;
    if (!(state == rhs.state))
      return false;
    return true;
  }
  bool operator != (const BulkImportStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulkImportStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulkImportStatus &a, BulkImportStatus &b);

std::ostream& operator<<(std::ostream& out, const BulkImportStatus& obj);

typedef struct _TabletServerStatus__isset {
  _TabletServerStatus__isset() : tableMap(false), lastContact(false), name(false), osLoad(false), holdTime(false), lookups(false), indexCacheHits(false), indexCacheRequest(false), dataCacheHits(false), dataCacheRequest(false), logSorts(false), flushs(false), syncs(false), bulkImports(false), version(false), responseTime(false) {}
  bool tableMap :1;
  bool lastContact :1;
  bool name :1;
  bool osLoad :1;
  bool holdTime :1;
  bool lookups :1;
  bool indexCacheHits :1;
  bool indexCacheRequest :1;
  bool dataCacheHits :1;
  bool dataCacheRequest :1;
  bool logSorts :1;
  bool flushs :1;
  bool syncs :1;
  bool bulkImports :1;
  bool version :1;
  bool responseTime :1;
} _TabletServerStatus__isset;

class TabletServerStatus : public virtual ::apache::thrift::TBase {
 public:

  TabletServerStatus(const TabletServerStatus&);
  TabletServerStatus& operator=(const TabletServerStatus&);
  TabletServerStatus() : lastContact(0), name(), osLoad(0), holdTime(0), lookups(0), indexCacheHits(0), indexCacheRequest(0), dataCacheHits(0), dataCacheRequest(0), flushs(0), syncs(0), version(), responseTime(0) {
  }

  virtual ~TabletServerStatus() throw();
  std::map<std::string, TableInfo>  tableMap;
  int64_t lastContact;
  std::string name;
  double osLoad;
  int64_t holdTime;
  int64_t lookups;
  int64_t indexCacheHits;
  int64_t indexCacheRequest;
  int64_t dataCacheHits;
  int64_t dataCacheRequest;
  std::vector<RecoveryStatus>  logSorts;
  int64_t flushs;
  int64_t syncs;
  std::vector<BulkImportStatus>  bulkImports;
  std::string version;
  int64_t responseTime;

  _TabletServerStatus__isset __isset;

  void __set_tableMap(const std::map<std::string, TableInfo> & val);

  void __set_lastContact(const int64_t val);

  void __set_name(const std::string& val);

  void __set_osLoad(const double val);

  void __set_holdTime(const int64_t val);

  void __set_lookups(const int64_t val);

  void __set_indexCacheHits(const int64_t val);

  void __set_indexCacheRequest(const int64_t val);

  void __set_dataCacheHits(const int64_t val);

  void __set_dataCacheRequest(const int64_t val);

  void __set_logSorts(const std::vector<RecoveryStatus> & val);

  void __set_flushs(const int64_t val);

  void __set_syncs(const int64_t val);

  void __set_bulkImports(const std::vector<BulkImportStatus> & val);

  void __set_version(const std::string& val);

  void __set_responseTime(const int64_t val);

  bool operator == (const TabletServerStatus & rhs) const
  {
    if (!(tableMap == rhs.tableMap))
      return false;
    if (!(lastContact == rhs.lastContact))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(osLoad == rhs.osLoad))
      return false;
    if (!(holdTime == rhs.holdTime))
      return false;
    if (!(lookups == rhs.lookups))
      return false;
    if (!(indexCacheHits == rhs.indexCacheHits))
      return false;
    if (!(indexCacheRequest == rhs.indexCacheRequest))
      return false;
    if (!(dataCacheHits == rhs.dataCacheHits))
      return false;
    if (!(dataCacheRequest == rhs.dataCacheRequest))
      return false;
    if (!(logSorts == rhs.logSorts))
      return false;
    if (!(flushs == rhs.flushs))
      return false;
    if (!(syncs == rhs.syncs))
      return false;
    if (!(bulkImports == rhs.bulkImports))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(responseTime == rhs.responseTime))
      return false;
    return true;
  }
  bool operator != (const TabletServerStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletServerStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TabletServerStatus &a, TabletServerStatus &b);

std::ostream& operator<<(std::ostream& out, const TabletServerStatus& obj);

typedef struct _DeadServer__isset {
  _DeadServer__isset() : server(false), lastStatus(false), status(false) {}
  bool server :1;
  bool lastStatus :1;
  bool status :1;
} _DeadServer__isset;

class DeadServer : public virtual ::apache::thrift::TBase {
 public:

  DeadServer(const DeadServer&);
  DeadServer& operator=(const DeadServer&);
  DeadServer() : server(), lastStatus(0), status() {
  }

  virtual ~DeadServer() throw();
  std::string server;
  int64_t lastStatus;
  std::string status;

  _DeadServer__isset __isset;

  void __set_server(const std::string& val);

  void __set_lastStatus(const int64_t val);

  void __set_status(const std::string& val);

  bool operator == (const DeadServer & rhs) const
  {
    if (!(server == rhs.server))
      return false;
    if (!(lastStatus == rhs.lastStatus))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const DeadServer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeadServer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DeadServer &a, DeadServer &b);

std::ostream& operator<<(std::ostream& out, const DeadServer& obj);

typedef struct _MasterMonitorInfo__isset {
  _MasterMonitorInfo__isset() : tableMap(false), tServerInfo(false), badTServers(false), state(false), goalState(false), unassignedTablets(false), serversShuttingDown(false), deadTabletServers(false), bulkImports(false) {}
  bool tableMap :1;
  bool tServerInfo :1;
  bool badTServers :1;
  bool state :1;
  bool goalState :1;
  bool unassignedTablets :1;
  bool serversShuttingDown :1;
  bool deadTabletServers :1;
  bool bulkImports :1;
} _MasterMonitorInfo__isset;

class MasterMonitorInfo : public virtual ::apache::thrift::TBase {
 public:

  MasterMonitorInfo(const MasterMonitorInfo&);
  MasterMonitorInfo& operator=(const MasterMonitorInfo&);
  MasterMonitorInfo() : state((MasterState::type)0), goalState((MasterGoalState::type)0), unassignedTablets(0) {
  }

  virtual ~MasterMonitorInfo() throw();
  std::map<std::string, TableInfo>  tableMap;
  std::vector<TabletServerStatus>  tServerInfo;
  std::map<std::string, int8_t>  badTServers;
  MasterState::type state;
  MasterGoalState::type goalState;
  int32_t unassignedTablets;
  std::set<std::string>  serversShuttingDown;
  std::vector<DeadServer>  deadTabletServers;
  std::vector<BulkImportStatus>  bulkImports;

  _MasterMonitorInfo__isset __isset;

  void __set_tableMap(const std::map<std::string, TableInfo> & val);

  void __set_tServerInfo(const std::vector<TabletServerStatus> & val);

  void __set_badTServers(const std::map<std::string, int8_t> & val);

  void __set_state(const MasterState::type val);

  void __set_goalState(const MasterGoalState::type val);

  void __set_unassignedTablets(const int32_t val);

  void __set_serversShuttingDown(const std::set<std::string> & val);

  void __set_deadTabletServers(const std::vector<DeadServer> & val);

  void __set_bulkImports(const std::vector<BulkImportStatus> & val);

  bool operator == (const MasterMonitorInfo & rhs) const
  {
    if (!(tableMap == rhs.tableMap))
      return false;
    if (!(tServerInfo == rhs.tServerInfo))
      return false;
    if (!(badTServers == rhs.badTServers))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(goalState == rhs.goalState))
      return false;
    if (!(unassignedTablets == rhs.unassignedTablets))
      return false;
    if (!(serversShuttingDown == rhs.serversShuttingDown))
      return false;
    if (!(deadTabletServers == rhs.deadTabletServers))
      return false;
    if (!(bulkImports == rhs.bulkImports))
      return false;
    return true;
  }
  bool operator != (const MasterMonitorInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MasterMonitorInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MasterMonitorInfo &a, MasterMonitorInfo &b);

std::ostream& operator<<(std::ostream& out, const MasterMonitorInfo& obj);

typedef struct _TabletSplit__isset {
  _TabletSplit__isset() : oldTablet(false), newTablets(false) {}
  bool oldTablet :1;
  bool newTablets :1;
} _TabletSplit__isset;

class TabletSplit : public virtual ::apache::thrift::TBase {
 public:

  TabletSplit(const TabletSplit&);
  TabletSplit& operator=(const TabletSplit&);
  TabletSplit() {
  }

  virtual ~TabletSplit() throw();
   ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent oldTablet;
  std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent>  newTablets;

  _TabletSplit__isset __isset;

  void __set_oldTablet(const  ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent& val);

  void __set_newTablets(const std::vector< ::org::apache::accumulov2::core::dataImpl::thrift::TKeyExtent> & val);

  bool operator == (const TabletSplit & rhs) const
  {
    if (!(oldTablet == rhs.oldTablet))
      return false;
    if (!(newTablets == rhs.newTablets))
      return false;
    return true;
  }
  bool operator != (const TabletSplit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TabletSplit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TabletSplit &a, TabletSplit &b);

std::ostream& operator<<(std::ostream& out, const TabletSplit& obj);

typedef struct _RecoveryException__isset {
  _RecoveryException__isset() : why(false) {}
  bool why :1;
} _RecoveryException__isset;

class RecoveryException : public ::apache::thrift::TException {
 public:

  RecoveryException(const RecoveryException&);
  RecoveryException& operator=(const RecoveryException&);
  RecoveryException() : why() {
  }

  virtual ~RecoveryException() throw();
  std::string why;

  _RecoveryException__isset __isset;

  void __set_why(const std::string& val);

  bool operator == (const RecoveryException & rhs) const
  {
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const RecoveryException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecoveryException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(RecoveryException &a, RecoveryException &b);

std::ostream& operator<<(std::ostream& out, const RecoveryException& obj);

}}}}}} // namespace

#endif
