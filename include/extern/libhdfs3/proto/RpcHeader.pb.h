// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RpcHeader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_RpcHeader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_RpcHeader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RpcHeader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_RpcHeader_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_RpcHeader_2eproto;
namespace Hdfs {
namespace Internal {
class RpcRequestHeaderProto;
class RpcRequestHeaderProtoDefaultTypeInternal;
extern RpcRequestHeaderProtoDefaultTypeInternal _RpcRequestHeaderProto_default_instance_;
class RpcResponseHeaderProto;
class RpcResponseHeaderProtoDefaultTypeInternal;
extern RpcResponseHeaderProtoDefaultTypeInternal _RpcResponseHeaderProto_default_instance_;
class RpcSaslProto;
class RpcSaslProtoDefaultTypeInternal;
extern RpcSaslProtoDefaultTypeInternal _RpcSaslProto_default_instance_;
class RpcSaslProto_SaslAuth;
class RpcSaslProto_SaslAuthDefaultTypeInternal;
extern RpcSaslProto_SaslAuthDefaultTypeInternal _RpcSaslProto_SaslAuth_default_instance_;
}  // namespace Internal
}  // namespace Hdfs
PROTOBUF_NAMESPACE_OPEN
template<> ::Hdfs::Internal::RpcRequestHeaderProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RpcRequestHeaderProto>(Arena*);
template<> ::Hdfs::Internal::RpcResponseHeaderProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RpcResponseHeaderProto>(Arena*);
template<> ::Hdfs::Internal::RpcSaslProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RpcSaslProto>(Arena*);
template<> ::Hdfs::Internal::RpcSaslProto_SaslAuth* Arena::CreateMaybeMessage<::Hdfs::Internal::RpcSaslProto_SaslAuth>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Hdfs {
namespace Internal {

enum RpcRequestHeaderProto_OperationProto : int {
  RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET = 0,
  RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET = 1,
  RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION = 2
};
bool RpcRequestHeaderProto_OperationProto_IsValid(int value);
constexpr RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MIN = RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
constexpr RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MAX = RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
constexpr int RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE = RpcRequestHeaderProto_OperationProto_OperationProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcRequestHeaderProto_OperationProto_descriptor();
template<typename T>
inline const std::string& RpcRequestHeaderProto_OperationProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcRequestHeaderProto_OperationProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcRequestHeaderProto_OperationProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcRequestHeaderProto_OperationProto_descriptor(), enum_t_value);
}
inline bool RpcRequestHeaderProto_OperationProto_Parse(
    const std::string& name, RpcRequestHeaderProto_OperationProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcRequestHeaderProto_OperationProto>(
    RpcRequestHeaderProto_OperationProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcStatusProto : int {
  RpcResponseHeaderProto_RpcStatusProto_SUCCESS = 0,
  RpcResponseHeaderProto_RpcStatusProto_ERROR = 1,
  RpcResponseHeaderProto_RpcStatusProto_FATAL = 2
};
bool RpcResponseHeaderProto_RpcStatusProto_IsValid(int value);
constexpr RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN = RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
constexpr RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX = RpcResponseHeaderProto_RpcStatusProto_FATAL;
constexpr int RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE = RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcResponseHeaderProto_RpcStatusProto_descriptor();
template<typename T>
inline const std::string& RpcResponseHeaderProto_RpcStatusProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcResponseHeaderProto_RpcStatusProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcResponseHeaderProto_RpcStatusProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), enum_t_value);
}
inline bool RpcResponseHeaderProto_RpcStatusProto_Parse(
    const std::string& name, RpcResponseHeaderProto_RpcStatusProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcStatusProto>(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcErrorCodeProto : int {
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION = 1,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD = 2,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL = 3,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER = 4,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE = 5,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH = 6,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN = 10,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION = 11,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER = 12,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST = 13,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH = 14,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED = 15
};
bool RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(int value);
constexpr RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN = RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
constexpr RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX = RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
constexpr int RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE = RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
template<typename T>
inline const std::string& RpcResponseHeaderProto_RpcErrorCodeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcResponseHeaderProto_RpcErrorCodeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcResponseHeaderProto_RpcErrorCodeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), enum_t_value);
}
inline bool RpcResponseHeaderProto_RpcErrorCodeProto_Parse(
    const std::string& name, RpcResponseHeaderProto_RpcErrorCodeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcErrorCodeProto>(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), name, value);
}
enum RpcSaslProto_SaslState : int {
  RpcSaslProto_SaslState_SUCCESS = 0,
  RpcSaslProto_SaslState_NEGOTIATE = 1,
  RpcSaslProto_SaslState_INITIATE = 2,
  RpcSaslProto_SaslState_CHALLENGE = 3,
  RpcSaslProto_SaslState_RESPONSE = 4,
  RpcSaslProto_SaslState_WRAP = 5
};
bool RpcSaslProto_SaslState_IsValid(int value);
constexpr RpcSaslProto_SaslState RpcSaslProto_SaslState_SaslState_MIN = RpcSaslProto_SaslState_SUCCESS;
constexpr RpcSaslProto_SaslState RpcSaslProto_SaslState_SaslState_MAX = RpcSaslProto_SaslState_WRAP;
constexpr int RpcSaslProto_SaslState_SaslState_ARRAYSIZE = RpcSaslProto_SaslState_SaslState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcSaslProto_SaslState_descriptor();
template<typename T>
inline const std::string& RpcSaslProto_SaslState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcSaslProto_SaslState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcSaslProto_SaslState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcSaslProto_SaslState_descriptor(), enum_t_value);
}
inline bool RpcSaslProto_SaslState_Parse(
    const std::string& name, RpcSaslProto_SaslState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcSaslProto_SaslState>(
    RpcSaslProto_SaslState_descriptor(), name, value);
}
enum RpcKindProto : int {
  RPC_BUILTIN = 0,
  RPC_WRITABLE = 1,
  RPC_PROTOCOL_BUFFER = 2
};
bool RpcKindProto_IsValid(int value);
constexpr RpcKindProto RpcKindProto_MIN = RPC_BUILTIN;
constexpr RpcKindProto RpcKindProto_MAX = RPC_PROTOCOL_BUFFER;
constexpr int RpcKindProto_ARRAYSIZE = RpcKindProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcKindProto_descriptor();
template<typename T>
inline const std::string& RpcKindProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcKindProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcKindProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcKindProto_descriptor(), enum_t_value);
}
inline bool RpcKindProto_Parse(
    const std::string& name, RpcKindProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcKindProto>(
    RpcKindProto_descriptor(), name, value);
}
// ===================================================================

class RpcRequestHeaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RpcRequestHeaderProto) */ {
 public:
  RpcRequestHeaderProto();
  virtual ~RpcRequestHeaderProto();

  RpcRequestHeaderProto(const RpcRequestHeaderProto& from);
  RpcRequestHeaderProto(RpcRequestHeaderProto&& from) noexcept
    : RpcRequestHeaderProto() {
    *this = ::std::move(from);
  }

  inline RpcRequestHeaderProto& operator=(const RpcRequestHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcRequestHeaderProto& operator=(RpcRequestHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RpcRequestHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcRequestHeaderProto* internal_default_instance() {
    return reinterpret_cast<const RpcRequestHeaderProto*>(
               &_RpcRequestHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RpcRequestHeaderProto& a, RpcRequestHeaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcRequestHeaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RpcRequestHeaderProto* New() const final {
    return CreateMaybeMessage<RpcRequestHeaderProto>(nullptr);
  }

  RpcRequestHeaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RpcRequestHeaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RpcRequestHeaderProto& from);
  void MergeFrom(const RpcRequestHeaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcRequestHeaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RpcRequestHeaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RpcHeader_2eproto);
    return ::descriptor_table_RpcHeader_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RpcRequestHeaderProto_OperationProto OperationProto;
  static constexpr OperationProto RPC_FINAL_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
  static constexpr OperationProto RPC_CONTINUATION_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET;
  static constexpr OperationProto RPC_CLOSE_CONNECTION =
    RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
  static inline bool OperationProto_IsValid(int value) {
    return RpcRequestHeaderProto_OperationProto_IsValid(value);
  }
  static constexpr OperationProto OperationProto_MIN =
    RpcRequestHeaderProto_OperationProto_OperationProto_MIN;
  static constexpr OperationProto OperationProto_MAX =
    RpcRequestHeaderProto_OperationProto_OperationProto_MAX;
  static constexpr int OperationProto_ARRAYSIZE =
    RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperationProto_descriptor() {
    return RpcRequestHeaderProto_OperationProto_descriptor();
  }
  template<typename T>
  static inline const std::string& OperationProto_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperationProto>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperationProto_Name.");
    return RpcRequestHeaderProto_OperationProto_Name(enum_t_value);
  }
  static inline bool OperationProto_Parse(const std::string& name,
      OperationProto* value) {
    return RpcRequestHeaderProto_OperationProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 4,
    kRpcKindFieldNumber = 1,
    kRpcOpFieldNumber = 2,
    kCallIdFieldNumber = 3,
    kRetryCountFieldNumber = 5,
  };
  // required bytes clientId = 4;
  bool has_clientid() const;
  private:
  bool _internal_has_clientid() const;
  public:
  void clear_clientid();
  const std::string& clientid() const;
  void set_clientid(const std::string& value);
  void set_clientid(std::string&& value);
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  std::string* mutable_clientid();
  std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // optional .Hdfs.Internal.RpcKindProto rpcKind = 1;
  bool has_rpckind() const;
  private:
  bool _internal_has_rpckind() const;
  public:
  void clear_rpckind();
  ::Hdfs::Internal::RpcKindProto rpckind() const;
  void set_rpckind(::Hdfs::Internal::RpcKindProto value);
  private:
  ::Hdfs::Internal::RpcKindProto _internal_rpckind() const;
  void _internal_set_rpckind(::Hdfs::Internal::RpcKindProto value);
  public:

  // optional .Hdfs.Internal.RpcRequestHeaderProto.OperationProto rpcOp = 2;
  bool has_rpcop() const;
  private:
  bool _internal_has_rpcop() const;
  public:
  void clear_rpcop();
  ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto rpcop() const;
  void set_rpcop(::Hdfs::Internal::RpcRequestHeaderProto_OperationProto value);
  private:
  ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto _internal_rpcop() const;
  void _internal_set_rpcop(::Hdfs::Internal::RpcRequestHeaderProto_OperationProto value);
  public:

  // required sint32 callId = 3;
  bool has_callid() const;
  private:
  bool _internal_has_callid() const;
  public:
  void clear_callid();
  ::PROTOBUF_NAMESPACE_ID::int32 callid() const;
  void set_callid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_callid() const;
  void _internal_set_callid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional sint32 retryCount = 5 [default = -1];
  bool has_retrycount() const;
  private:
  bool _internal_has_retrycount() const;
  public:
  void clear_retrycount();
  ::PROTOBUF_NAMESPACE_ID::int32 retrycount() const;
  void set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_retrycount() const;
  void _internal_set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RpcRequestHeaderProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  int rpckind_;
  int rpcop_;
  ::PROTOBUF_NAMESPACE_ID::int32 callid_;
  ::PROTOBUF_NAMESPACE_ID::int32 retrycount_;
  friend struct ::TableStruct_RpcHeader_2eproto;
};
// -------------------------------------------------------------------

class RpcResponseHeaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RpcResponseHeaderProto) */ {
 public:
  RpcResponseHeaderProto();
  virtual ~RpcResponseHeaderProto();

  RpcResponseHeaderProto(const RpcResponseHeaderProto& from);
  RpcResponseHeaderProto(RpcResponseHeaderProto&& from) noexcept
    : RpcResponseHeaderProto() {
    *this = ::std::move(from);
  }

  inline RpcResponseHeaderProto& operator=(const RpcResponseHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcResponseHeaderProto& operator=(RpcResponseHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RpcResponseHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcResponseHeaderProto* internal_default_instance() {
    return reinterpret_cast<const RpcResponseHeaderProto*>(
               &_RpcResponseHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RpcResponseHeaderProto& a, RpcResponseHeaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcResponseHeaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RpcResponseHeaderProto* New() const final {
    return CreateMaybeMessage<RpcResponseHeaderProto>(nullptr);
  }

  RpcResponseHeaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RpcResponseHeaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RpcResponseHeaderProto& from);
  void MergeFrom(const RpcResponseHeaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcResponseHeaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RpcResponseHeaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RpcHeader_2eproto);
    return ::descriptor_table_RpcHeader_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RpcResponseHeaderProto_RpcStatusProto RpcStatusProto;
  static constexpr RpcStatusProto SUCCESS =
    RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
  static constexpr RpcStatusProto ERROR =
    RpcResponseHeaderProto_RpcStatusProto_ERROR;
  static constexpr RpcStatusProto FATAL =
    RpcResponseHeaderProto_RpcStatusProto_FATAL;
  static inline bool RpcStatusProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcStatusProto_IsValid(value);
  }
  static constexpr RpcStatusProto RpcStatusProto_MIN =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN;
  static constexpr RpcStatusProto RpcStatusProto_MAX =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX;
  static constexpr int RpcStatusProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RpcStatusProto_descriptor() {
    return RpcResponseHeaderProto_RpcStatusProto_descriptor();
  }
  template<typename T>
  static inline const std::string& RpcStatusProto_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RpcStatusProto>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RpcStatusProto_Name.");
    return RpcResponseHeaderProto_RpcStatusProto_Name(enum_t_value);
  }
  static inline bool RpcStatusProto_Parse(const std::string& name,
      RpcStatusProto* value) {
    return RpcResponseHeaderProto_RpcStatusProto_Parse(name, value);
  }

  typedef RpcResponseHeaderProto_RpcErrorCodeProto RpcErrorCodeProto;
  static constexpr RpcErrorCodeProto ERROR_APPLICATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
  static constexpr RpcErrorCodeProto ERROR_NO_SUCH_METHOD =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD;
  static constexpr RpcErrorCodeProto ERROR_NO_SUCH_PROTOCOL =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL;
  static constexpr RpcErrorCodeProto ERROR_RPC_SERVER =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER;
  static constexpr RpcErrorCodeProto ERROR_SERIALIZING_RESPONSE =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE;
  static constexpr RpcErrorCodeProto ERROR_RPC_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH;
  static constexpr RpcErrorCodeProto FATAL_UNKNOWN =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN;
  static constexpr RpcErrorCodeProto FATAL_UNSUPPORTED_SERIALIZATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION;
  static constexpr RpcErrorCodeProto FATAL_INVALID_RPC_HEADER =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER;
  static constexpr RpcErrorCodeProto FATAL_DESERIALIZING_REQUEST =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST;
  static constexpr RpcErrorCodeProto FATAL_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH;
  static constexpr RpcErrorCodeProto FATAL_UNAUTHORIZED =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
  static inline bool RpcErrorCodeProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value);
  }
  static constexpr RpcErrorCodeProto RpcErrorCodeProto_MIN =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN;
  static constexpr RpcErrorCodeProto RpcErrorCodeProto_MAX =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX;
  static constexpr int RpcErrorCodeProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RpcErrorCodeProto_descriptor() {
    return RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
  }
  template<typename T>
  static inline const std::string& RpcErrorCodeProto_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RpcErrorCodeProto>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RpcErrorCodeProto_Name.");
    return RpcResponseHeaderProto_RpcErrorCodeProto_Name(enum_t_value);
  }
  static inline bool RpcErrorCodeProto_Parse(const std::string& name,
      RpcErrorCodeProto* value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExceptionClassNameFieldNumber = 4,
    kErrorMsgFieldNumber = 5,
    kClientIdFieldNumber = 7,
    kCallIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kServerIpcVersionNumFieldNumber = 3,
    kErrorDetailFieldNumber = 6,
    kRetryCountFieldNumber = 8,
  };
  // optional string exceptionClassName = 4;
  bool has_exceptionclassname() const;
  private:
  bool _internal_has_exceptionclassname() const;
  public:
  void clear_exceptionclassname();
  const std::string& exceptionclassname() const;
  void set_exceptionclassname(const std::string& value);
  void set_exceptionclassname(std::string&& value);
  void set_exceptionclassname(const char* value);
  void set_exceptionclassname(const char* value, size_t size);
  std::string* mutable_exceptionclassname();
  std::string* release_exceptionclassname();
  void set_allocated_exceptionclassname(std::string* exceptionclassname);
  private:
  const std::string& _internal_exceptionclassname() const;
  void _internal_set_exceptionclassname(const std::string& value);
  std::string* _internal_mutable_exceptionclassname();
  public:

  // optional string errorMsg = 5;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  void set_errormsg(const std::string& value);
  void set_errormsg(std::string&& value);
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  std::string* mutable_errormsg();
  std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // optional bytes clientId = 7;
  bool has_clientid() const;
  private:
  bool _internal_has_clientid() const;
  public:
  void clear_clientid();
  const std::string& clientid() const;
  void set_clientid(const std::string& value);
  void set_clientid(std::string&& value);
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  std::string* mutable_clientid();
  std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // required uint32 callId = 1;
  bool has_callid() const;
  private:
  bool _internal_has_callid() const;
  public:
  void clear_callid();
  ::PROTOBUF_NAMESPACE_ID::uint32 callid() const;
  void set_callid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_callid() const;
  void _internal_set_callid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Hdfs.Internal.RpcResponseHeaderProto.RpcStatusProto status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto status() const;
  void set_status(::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto value);
  private:
  ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto _internal_status() const;
  void _internal_set_status(::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto value);
  public:

  // optional uint32 serverIpcVersionNum = 3;
  bool has_serveripcversionnum() const;
  private:
  bool _internal_has_serveripcversionnum() const;
  public:
  void clear_serveripcversionnum();
  ::PROTOBUF_NAMESPACE_ID::uint32 serveripcversionnum() const;
  void set_serveripcversionnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_serveripcversionnum() const;
  void _internal_set_serveripcversionnum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .Hdfs.Internal.RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
  bool has_errordetail() const;
  private:
  bool _internal_has_errordetail() const;
  public:
  void clear_errordetail();
  ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto errordetail() const;
  void set_errordetail(::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto value);
  private:
  ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto _internal_errordetail() const;
  void _internal_set_errordetail(::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto value);
  public:

  // optional sint32 retryCount = 8 [default = -1];
  bool has_retrycount() const;
  private:
  bool _internal_has_retrycount() const;
  public:
  void clear_retrycount();
  ::PROTOBUF_NAMESPACE_ID::int32 retrycount() const;
  void set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_retrycount() const;
  void _internal_set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RpcResponseHeaderProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exceptionclassname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 callid_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 serveripcversionnum_;
  int errordetail_;
  ::PROTOBUF_NAMESPACE_ID::int32 retrycount_;
  friend struct ::TableStruct_RpcHeader_2eproto;
};
// -------------------------------------------------------------------

class RpcSaslProto_SaslAuth :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RpcSaslProto.SaslAuth) */ {
 public:
  RpcSaslProto_SaslAuth();
  virtual ~RpcSaslProto_SaslAuth();

  RpcSaslProto_SaslAuth(const RpcSaslProto_SaslAuth& from);
  RpcSaslProto_SaslAuth(RpcSaslProto_SaslAuth&& from) noexcept
    : RpcSaslProto_SaslAuth() {
    *this = ::std::move(from);
  }

  inline RpcSaslProto_SaslAuth& operator=(const RpcSaslProto_SaslAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcSaslProto_SaslAuth& operator=(RpcSaslProto_SaslAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RpcSaslProto_SaslAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcSaslProto_SaslAuth* internal_default_instance() {
    return reinterpret_cast<const RpcSaslProto_SaslAuth*>(
               &_RpcSaslProto_SaslAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RpcSaslProto_SaslAuth& a, RpcSaslProto_SaslAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcSaslProto_SaslAuth* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RpcSaslProto_SaslAuth* New() const final {
    return CreateMaybeMessage<RpcSaslProto_SaslAuth>(nullptr);
  }

  RpcSaslProto_SaslAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RpcSaslProto_SaslAuth>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RpcSaslProto_SaslAuth& from);
  void MergeFrom(const RpcSaslProto_SaslAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcSaslProto_SaslAuth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RpcSaslProto.SaslAuth";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RpcHeader_2eproto);
    return ::descriptor_table_RpcHeader_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kMechanismFieldNumber = 2,
    kProtocolFieldNumber = 3,
    kServerIdFieldNumber = 4,
    kChallengeFieldNumber = 5,
  };
  // required string method = 1;
  bool has_method() const;
  private:
  bool _internal_has_method() const;
  public:
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // required string mechanism = 2;
  bool has_mechanism() const;
  private:
  bool _internal_has_mechanism() const;
  public:
  void clear_mechanism();
  const std::string& mechanism() const;
  void set_mechanism(const std::string& value);
  void set_mechanism(std::string&& value);
  void set_mechanism(const char* value);
  void set_mechanism(const char* value, size_t size);
  std::string* mutable_mechanism();
  std::string* release_mechanism();
  void set_allocated_mechanism(std::string* mechanism);
  private:
  const std::string& _internal_mechanism() const;
  void _internal_set_mechanism(const std::string& value);
  std::string* _internal_mutable_mechanism();
  public:

  // optional string protocol = 3;
  bool has_protocol() const;
  private:
  bool _internal_has_protocol() const;
  public:
  void clear_protocol();
  const std::string& protocol() const;
  void set_protocol(const std::string& value);
  void set_protocol(std::string&& value);
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  std::string* mutable_protocol();
  std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // optional string serverId = 4;
  bool has_serverid() const;
  private:
  bool _internal_has_serverid() const;
  public:
  void clear_serverid();
  const std::string& serverid() const;
  void set_serverid(const std::string& value);
  void set_serverid(std::string&& value);
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  std::string* mutable_serverid();
  std::string* release_serverid();
  void set_allocated_serverid(std::string* serverid);
  private:
  const std::string& _internal_serverid() const;
  void _internal_set_serverid(const std::string& value);
  std::string* _internal_mutable_serverid();
  public:

  // optional bytes challenge = 5;
  bool has_challenge() const;
  private:
  bool _internal_has_challenge() const;
  public:
  void clear_challenge();
  const std::string& challenge() const;
  void set_challenge(const std::string& value);
  void set_challenge(std::string&& value);
  void set_challenge(const char* value);
  void set_challenge(const void* value, size_t size);
  std::string* mutable_challenge();
  std::string* release_challenge();
  void set_allocated_challenge(std::string* challenge);
  private:
  const std::string& _internal_challenge() const;
  void _internal_set_challenge(const std::string& value);
  std::string* _internal_mutable_challenge();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RpcSaslProto.SaslAuth)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mechanism_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_;
  friend struct ::TableStruct_RpcHeader_2eproto;
};
// -------------------------------------------------------------------

class RpcSaslProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RpcSaslProto) */ {
 public:
  RpcSaslProto();
  virtual ~RpcSaslProto();

  RpcSaslProto(const RpcSaslProto& from);
  RpcSaslProto(RpcSaslProto&& from) noexcept
    : RpcSaslProto() {
    *this = ::std::move(from);
  }

  inline RpcSaslProto& operator=(const RpcSaslProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcSaslProto& operator=(RpcSaslProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RpcSaslProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcSaslProto* internal_default_instance() {
    return reinterpret_cast<const RpcSaslProto*>(
               &_RpcSaslProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RpcSaslProto& a, RpcSaslProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcSaslProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RpcSaslProto* New() const final {
    return CreateMaybeMessage<RpcSaslProto>(nullptr);
  }

  RpcSaslProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RpcSaslProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RpcSaslProto& from);
  void MergeFrom(const RpcSaslProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcSaslProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RpcSaslProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_RpcHeader_2eproto);
    return ::descriptor_table_RpcHeader_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RpcSaslProto_SaslAuth SaslAuth;

  typedef RpcSaslProto_SaslState SaslState;
  static constexpr SaslState SUCCESS =
    RpcSaslProto_SaslState_SUCCESS;
  static constexpr SaslState NEGOTIATE =
    RpcSaslProto_SaslState_NEGOTIATE;
  static constexpr SaslState INITIATE =
    RpcSaslProto_SaslState_INITIATE;
  static constexpr SaslState CHALLENGE =
    RpcSaslProto_SaslState_CHALLENGE;
  static constexpr SaslState RESPONSE =
    RpcSaslProto_SaslState_RESPONSE;
  static constexpr SaslState WRAP =
    RpcSaslProto_SaslState_WRAP;
  static inline bool SaslState_IsValid(int value) {
    return RpcSaslProto_SaslState_IsValid(value);
  }
  static constexpr SaslState SaslState_MIN =
    RpcSaslProto_SaslState_SaslState_MIN;
  static constexpr SaslState SaslState_MAX =
    RpcSaslProto_SaslState_SaslState_MAX;
  static constexpr int SaslState_ARRAYSIZE =
    RpcSaslProto_SaslState_SaslState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SaslState_descriptor() {
    return RpcSaslProto_SaslState_descriptor();
  }
  template<typename T>
  static inline const std::string& SaslState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SaslState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SaslState_Name.");
    return RpcSaslProto_SaslState_Name(enum_t_value);
  }
  static inline bool SaslState_Parse(const std::string& name,
      SaslState* value) {
    return RpcSaslProto_SaslState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAuthsFieldNumber = 4,
    kTokenFieldNumber = 3,
    kVersionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // repeated .Hdfs.Internal.RpcSaslProto.SaslAuth auths = 4;
  int auths_size() const;
  private:
  int _internal_auths_size() const;
  public:
  void clear_auths();
  ::Hdfs::Internal::RpcSaslProto_SaslAuth* mutable_auths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RpcSaslProto_SaslAuth >*
      mutable_auths();
  private:
  const ::Hdfs::Internal::RpcSaslProto_SaslAuth& _internal_auths(int index) const;
  ::Hdfs::Internal::RpcSaslProto_SaslAuth* _internal_add_auths();
  public:
  const ::Hdfs::Internal::RpcSaslProto_SaslAuth& auths(int index) const;
  ::Hdfs::Internal::RpcSaslProto_SaslAuth* add_auths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RpcSaslProto_SaslAuth >&
      auths() const;

  // optional bytes token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Hdfs.Internal.RpcSaslProto.SaslState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::Hdfs::Internal::RpcSaslProto_SaslState state() const;
  void set_state(::Hdfs::Internal::RpcSaslProto_SaslState value);
  private:
  ::Hdfs::Internal::RpcSaslProto_SaslState _internal_state() const;
  void _internal_set_state(::Hdfs::Internal::RpcSaslProto_SaslState value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RpcSaslProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RpcSaslProto_SaslAuth > auths_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  int state_;
  friend struct ::TableStruct_RpcHeader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RpcRequestHeaderProto

// optional .Hdfs.Internal.RpcKindProto rpcKind = 1;
inline bool RpcRequestHeaderProto::_internal_has_rpckind() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RpcRequestHeaderProto::has_rpckind() const {
  return _internal_has_rpckind();
}
inline void RpcRequestHeaderProto::clear_rpckind() {
  rpckind_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::Hdfs::Internal::RpcKindProto RpcRequestHeaderProto::_internal_rpckind() const {
  return static_cast< ::Hdfs::Internal::RpcKindProto >(rpckind_);
}
inline ::Hdfs::Internal::RpcKindProto RpcRequestHeaderProto::rpckind() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcRequestHeaderProto.rpcKind)
  return _internal_rpckind();
}
inline void RpcRequestHeaderProto::_internal_set_rpckind(::Hdfs::Internal::RpcKindProto value) {
  assert(::Hdfs::Internal::RpcKindProto_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  rpckind_ = value;
}
inline void RpcRequestHeaderProto::set_rpckind(::Hdfs::Internal::RpcKindProto value) {
  _internal_set_rpckind(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcRequestHeaderProto.rpcKind)
}

// optional .Hdfs.Internal.RpcRequestHeaderProto.OperationProto rpcOp = 2;
inline bool RpcRequestHeaderProto::_internal_has_rpcop() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RpcRequestHeaderProto::has_rpcop() const {
  return _internal_has_rpcop();
}
inline void RpcRequestHeaderProto::clear_rpcop() {
  rpcop_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::_internal_rpcop() const {
  return static_cast< ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto >(rpcop_);
}
inline ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::rpcop() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcRequestHeaderProto.rpcOp)
  return _internal_rpcop();
}
inline void RpcRequestHeaderProto::_internal_set_rpcop(::Hdfs::Internal::RpcRequestHeaderProto_OperationProto value) {
  assert(::Hdfs::Internal::RpcRequestHeaderProto_OperationProto_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  rpcop_ = value;
}
inline void RpcRequestHeaderProto::set_rpcop(::Hdfs::Internal::RpcRequestHeaderProto_OperationProto value) {
  _internal_set_rpcop(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcRequestHeaderProto.rpcOp)
}

// required sint32 callId = 3;
inline bool RpcRequestHeaderProto::_internal_has_callid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RpcRequestHeaderProto::has_callid() const {
  return _internal_has_callid();
}
inline void RpcRequestHeaderProto::clear_callid() {
  callid_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcRequestHeaderProto::_internal_callid() const {
  return callid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcRequestHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcRequestHeaderProto.callId)
  return _internal_callid();
}
inline void RpcRequestHeaderProto::_internal_set_callid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  callid_ = value;
}
inline void RpcRequestHeaderProto::set_callid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_callid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcRequestHeaderProto.callId)
}

// required bytes clientId = 4;
inline bool RpcRequestHeaderProto::_internal_has_clientid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcRequestHeaderProto::has_clientid() const {
  return _internal_has_clientid();
}
inline void RpcRequestHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RpcRequestHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcRequestHeaderProto.clientId)
  return _internal_clientid();
}
inline void RpcRequestHeaderProto::set_clientid(const std::string& value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcRequestHeaderProto.clientId)
}
inline std::string* RpcRequestHeaderProto::mutable_clientid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcRequestHeaderProto.clientId)
  return _internal_mutable_clientid();
}
inline const std::string& RpcRequestHeaderProto::_internal_clientid() const {
  return clientid_.GetNoArena();
}
inline void RpcRequestHeaderProto::_internal_set_clientid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcRequestHeaderProto::set_clientid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  clientid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcRequestHeaderProto.clientId)
}
inline void RpcRequestHeaderProto::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcRequestHeaderProto.clientId)
}
inline void RpcRequestHeaderProto::set_clientid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcRequestHeaderProto.clientId)
}
inline std::string* RpcRequestHeaderProto::_internal_mutable_clientid() {
  _has_bits_[0] |= 0x00000001u;
  return clientid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcRequestHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcRequestHeaderProto.clientId)
  if (!_internal_has_clientid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clientid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequestHeaderProto::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clientid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcRequestHeaderProto.clientId)
}

// optional sint32 retryCount = 5 [default = -1];
inline bool RpcRequestHeaderProto::_internal_has_retrycount() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RpcRequestHeaderProto::has_retrycount() const {
  return _internal_has_retrycount();
}
inline void RpcRequestHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcRequestHeaderProto::_internal_retrycount() const {
  return retrycount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcRequestHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcRequestHeaderProto.retryCount)
  return _internal_retrycount();
}
inline void RpcRequestHeaderProto::_internal_set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  retrycount_ = value;
}
inline void RpcRequestHeaderProto::set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_retrycount(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcRequestHeaderProto.retryCount)
}

// -------------------------------------------------------------------

// RpcResponseHeaderProto

// required uint32 callId = 1;
inline bool RpcResponseHeaderProto::_internal_has_callid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_callid() const {
  return _internal_has_callid();
}
inline void RpcResponseHeaderProto::clear_callid() {
  callid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcResponseHeaderProto::_internal_callid() const {
  return callid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcResponseHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.callId)
  return _internal_callid();
}
inline void RpcResponseHeaderProto::_internal_set_callid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  callid_ = value;
}
inline void RpcResponseHeaderProto::set_callid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_callid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.callId)
}

// required .Hdfs.Internal.RpcResponseHeaderProto.RpcStatusProto status = 2;
inline bool RpcResponseHeaderProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_status() const {
  return _internal_has_status();
}
inline void RpcResponseHeaderProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::_internal_status() const {
  return static_cast< ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto >(status_);
}
inline ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::status() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.status)
  return _internal_status();
}
inline void RpcResponseHeaderProto::_internal_set_status(::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto value) {
  assert(::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void RpcResponseHeaderProto::set_status(::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.status)
}

// optional uint32 serverIpcVersionNum = 3;
inline bool RpcResponseHeaderProto::_internal_has_serveripcversionnum() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_serveripcversionnum() const {
  return _internal_has_serveripcversionnum();
}
inline void RpcResponseHeaderProto::clear_serveripcversionnum() {
  serveripcversionnum_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcResponseHeaderProto::_internal_serveripcversionnum() const {
  return serveripcversionnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcResponseHeaderProto::serveripcversionnum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.serverIpcVersionNum)
  return _internal_serveripcversionnum();
}
inline void RpcResponseHeaderProto::_internal_set_serveripcversionnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  serveripcversionnum_ = value;
}
inline void RpcResponseHeaderProto::set_serveripcversionnum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_serveripcversionnum(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.serverIpcVersionNum)
}

// optional string exceptionClassName = 4;
inline bool RpcResponseHeaderProto::_internal_has_exceptionclassname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_exceptionclassname() const {
  return _internal_has_exceptionclassname();
}
inline void RpcResponseHeaderProto::clear_exceptionclassname() {
  exceptionclassname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RpcResponseHeaderProto::exceptionclassname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
  return _internal_exceptionclassname();
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const std::string& value) {
  _internal_set_exceptionclassname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
}
inline std::string* RpcResponseHeaderProto::mutable_exceptionclassname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
  return _internal_mutable_exceptionclassname();
}
inline const std::string& RpcResponseHeaderProto::_internal_exceptionclassname() const {
  return exceptionclassname_.GetNoArena();
}
inline void RpcResponseHeaderProto::_internal_set_exceptionclassname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  exceptionclassname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcResponseHeaderProto::set_exceptionclassname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  exceptionclassname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  exceptionclassname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  exceptionclassname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
}
inline std::string* RpcResponseHeaderProto::_internal_mutable_exceptionclassname() {
  _has_bits_[0] |= 0x00000001u;
  return exceptionclassname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcResponseHeaderProto::release_exceptionclassname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
  if (!_internal_has_exceptionclassname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return exceptionclassname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_exceptionclassname(std::string* exceptionclassname) {
  if (exceptionclassname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  exceptionclassname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exceptionclassname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcResponseHeaderProto.exceptionClassName)
}

// optional string errorMsg = 5;
inline bool RpcResponseHeaderProto::_internal_has_errormsg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void RpcResponseHeaderProto::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RpcResponseHeaderProto::errormsg() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
  return _internal_errormsg();
}
inline void RpcResponseHeaderProto::set_errormsg(const std::string& value) {
  _internal_set_errormsg(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
}
inline std::string* RpcResponseHeaderProto::mutable_errormsg() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
  return _internal_mutable_errormsg();
}
inline const std::string& RpcResponseHeaderProto::_internal_errormsg() const {
  return errormsg_.GetNoArena();
}
inline void RpcResponseHeaderProto::_internal_set_errormsg(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  errormsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcResponseHeaderProto::set_errormsg(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  errormsg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
}
inline void RpcResponseHeaderProto::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  errormsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
}
inline void RpcResponseHeaderProto::set_errormsg(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  errormsg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
}
inline std::string* RpcResponseHeaderProto::_internal_mutable_errormsg() {
  _has_bits_[0] |= 0x00000002u;
  return errormsg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcResponseHeaderProto::release_errormsg() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return errormsg_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  errormsg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcResponseHeaderProto.errorMsg)
}

// optional .Hdfs.Internal.RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
inline bool RpcResponseHeaderProto::_internal_has_errordetail() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_errordetail() const {
  return _internal_has_errordetail();
}
inline void RpcResponseHeaderProto::clear_errordetail() {
  errordetail_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::_internal_errordetail() const {
  return static_cast< ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto >(errordetail_);
}
inline ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::errordetail() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.errorDetail)
  return _internal_errordetail();
}
inline void RpcResponseHeaderProto::_internal_set_errordetail(::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto value) {
  assert(::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  errordetail_ = value;
}
inline void RpcResponseHeaderProto::set_errordetail(::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto value) {
  _internal_set_errordetail(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.errorDetail)
}

// optional bytes clientId = 7;
inline bool RpcResponseHeaderProto::_internal_has_clientid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_clientid() const {
  return _internal_has_clientid();
}
inline void RpcResponseHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RpcResponseHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.clientId)
  return _internal_clientid();
}
inline void RpcResponseHeaderProto::set_clientid(const std::string& value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.clientId)
}
inline std::string* RpcResponseHeaderProto::mutable_clientid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcResponseHeaderProto.clientId)
  return _internal_mutable_clientid();
}
inline const std::string& RpcResponseHeaderProto::_internal_clientid() const {
  return clientid_.GetNoArena();
}
inline void RpcResponseHeaderProto::_internal_set_clientid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcResponseHeaderProto::set_clientid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  clientid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcResponseHeaderProto.clientId)
}
inline void RpcResponseHeaderProto::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcResponseHeaderProto.clientId)
}
inline void RpcResponseHeaderProto::set_clientid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcResponseHeaderProto.clientId)
}
inline std::string* RpcResponseHeaderProto::_internal_mutable_clientid() {
  _has_bits_[0] |= 0x00000004u;
  return clientid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcResponseHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcResponseHeaderProto.clientId)
  if (!_internal_has_clientid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return clientid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  clientid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcResponseHeaderProto.clientId)
}

// optional sint32 retryCount = 8 [default = -1];
inline bool RpcResponseHeaderProto::_internal_has_retrycount() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RpcResponseHeaderProto::has_retrycount() const {
  return _internal_has_retrycount();
}
inline void RpcResponseHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcResponseHeaderProto::_internal_retrycount() const {
  return retrycount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcResponseHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcResponseHeaderProto.retryCount)
  return _internal_retrycount();
}
inline void RpcResponseHeaderProto::_internal_set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  retrycount_ = value;
}
inline void RpcResponseHeaderProto::set_retrycount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_retrycount(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcResponseHeaderProto.retryCount)
}

// -------------------------------------------------------------------

// RpcSaslProto_SaslAuth

// required string method = 1;
inline bool RpcSaslProto_SaslAuth::_internal_has_method() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcSaslProto_SaslAuth::has_method() const {
  return _internal_has_method();
}
inline void RpcSaslProto_SaslAuth::clear_method() {
  method_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RpcSaslProto_SaslAuth::method() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
  return _internal_method();
}
inline void RpcSaslProto_SaslAuth::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
}
inline std::string* RpcSaslProto_SaslAuth::mutable_method() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
  return _internal_mutable_method();
}
inline const std::string& RpcSaslProto_SaslAuth::_internal_method() const {
  return method_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::_internal_set_method(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  method_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto_SaslAuth::set_method(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  method_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
}
inline void RpcSaslProto_SaslAuth::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  method_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
}
inline void RpcSaslProto_SaslAuth::set_method(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  method_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
}
inline std::string* RpcSaslProto_SaslAuth::_internal_mutable_method() {
  _has_bits_[0] |= 0x00000001u;
  return method_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto_SaslAuth::release_method() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
  if (!_internal_has_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return method_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  method_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.SaslAuth.method)
}

// required string mechanism = 2;
inline bool RpcSaslProto_SaslAuth::_internal_has_mechanism() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RpcSaslProto_SaslAuth::has_mechanism() const {
  return _internal_has_mechanism();
}
inline void RpcSaslProto_SaslAuth::clear_mechanism() {
  mechanism_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RpcSaslProto_SaslAuth::mechanism() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
  return _internal_mechanism();
}
inline void RpcSaslProto_SaslAuth::set_mechanism(const std::string& value) {
  _internal_set_mechanism(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
}
inline std::string* RpcSaslProto_SaslAuth::mutable_mechanism() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
  return _internal_mutable_mechanism();
}
inline const std::string& RpcSaslProto_SaslAuth::_internal_mechanism() const {
  return mechanism_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::_internal_set_mechanism(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mechanism_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto_SaslAuth::set_mechanism(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mechanism_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
}
inline void RpcSaslProto_SaslAuth::set_mechanism(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mechanism_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
}
inline void RpcSaslProto_SaslAuth::set_mechanism(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mechanism_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
}
inline std::string* RpcSaslProto_SaslAuth::_internal_mutable_mechanism() {
  _has_bits_[0] |= 0x00000002u;
  return mechanism_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto_SaslAuth::release_mechanism() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
  if (!_internal_has_mechanism()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mechanism_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_mechanism(std::string* mechanism) {
  if (mechanism != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mechanism_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mechanism);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.SaslAuth.mechanism)
}

// optional string protocol = 3;
inline bool RpcSaslProto_SaslAuth::_internal_has_protocol() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RpcSaslProto_SaslAuth::has_protocol() const {
  return _internal_has_protocol();
}
inline void RpcSaslProto_SaslAuth::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RpcSaslProto_SaslAuth::protocol() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
  return _internal_protocol();
}
inline void RpcSaslProto_SaslAuth::set_protocol(const std::string& value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
}
inline std::string* RpcSaslProto_SaslAuth::mutable_protocol() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
  return _internal_mutable_protocol();
}
inline const std::string& RpcSaslProto_SaslAuth::_internal_protocol() const {
  return protocol_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::_internal_set_protocol(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  protocol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto_SaslAuth::set_protocol(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  protocol_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
}
inline void RpcSaslProto_SaslAuth::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  protocol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
}
inline void RpcSaslProto_SaslAuth::set_protocol(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  protocol_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
}
inline std::string* RpcSaslProto_SaslAuth::_internal_mutable_protocol() {
  _has_bits_[0] |= 0x00000004u;
  return protocol_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto_SaslAuth::release_protocol() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
  if (!_internal_has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return protocol_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  protocol_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.SaslAuth.protocol)
}

// optional string serverId = 4;
inline bool RpcSaslProto_SaslAuth::_internal_has_serverid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RpcSaslProto_SaslAuth::has_serverid() const {
  return _internal_has_serverid();
}
inline void RpcSaslProto_SaslAuth::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RpcSaslProto_SaslAuth::serverid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
  return _internal_serverid();
}
inline void RpcSaslProto_SaslAuth::set_serverid(const std::string& value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
}
inline std::string* RpcSaslProto_SaslAuth::mutable_serverid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
  return _internal_mutable_serverid();
}
inline const std::string& RpcSaslProto_SaslAuth::_internal_serverid() const {
  return serverid_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::_internal_set_serverid(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto_SaslAuth::set_serverid(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  serverid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
}
inline void RpcSaslProto_SaslAuth::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
}
inline void RpcSaslProto_SaslAuth::set_serverid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
}
inline std::string* RpcSaslProto_SaslAuth::_internal_mutable_serverid() {
  _has_bits_[0] |= 0x00000008u;
  return serverid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto_SaslAuth::release_serverid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
  if (!_internal_has_serverid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return serverid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_serverid(std::string* serverid) {
  if (serverid != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  serverid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.SaslAuth.serverId)
}

// optional bytes challenge = 5;
inline bool RpcSaslProto_SaslAuth::_internal_has_challenge() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RpcSaslProto_SaslAuth::has_challenge() const {
  return _internal_has_challenge();
}
inline void RpcSaslProto_SaslAuth::clear_challenge() {
  challenge_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RpcSaslProto_SaslAuth::challenge() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
  return _internal_challenge();
}
inline void RpcSaslProto_SaslAuth::set_challenge(const std::string& value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
}
inline std::string* RpcSaslProto_SaslAuth::mutable_challenge() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
  return _internal_mutable_challenge();
}
inline const std::string& RpcSaslProto_SaslAuth::_internal_challenge() const {
  return challenge_.GetNoArena();
}
inline void RpcSaslProto_SaslAuth::_internal_set_challenge(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto_SaslAuth::set_challenge(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  challenge_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
}
inline void RpcSaslProto_SaslAuth::set_challenge(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
}
inline void RpcSaslProto_SaslAuth::set_challenge(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  challenge_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
}
inline std::string* RpcSaslProto_SaslAuth::_internal_mutable_challenge() {
  _has_bits_[0] |= 0x00000010u;
  return challenge_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto_SaslAuth::release_challenge() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
  if (!_internal_has_challenge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return challenge_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto_SaslAuth::set_allocated_challenge(std::string* challenge) {
  if (challenge != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  challenge_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), challenge);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.SaslAuth.challenge)
}

// -------------------------------------------------------------------

// RpcSaslProto

// optional uint32 version = 1;
inline bool RpcSaslProto::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RpcSaslProto::has_version() const {
  return _internal_has_version();
}
inline void RpcSaslProto::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcSaslProto::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RpcSaslProto::version() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.version)
  return _internal_version();
}
inline void RpcSaslProto::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void RpcSaslProto::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.version)
}

// required .Hdfs.Internal.RpcSaslProto.SaslState state = 2;
inline bool RpcSaslProto::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RpcSaslProto::has_state() const {
  return _internal_has_state();
}
inline void RpcSaslProto::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Hdfs::Internal::RpcSaslProto_SaslState RpcSaslProto::_internal_state() const {
  return static_cast< ::Hdfs::Internal::RpcSaslProto_SaslState >(state_);
}
inline ::Hdfs::Internal::RpcSaslProto_SaslState RpcSaslProto::state() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.state)
  return _internal_state();
}
inline void RpcSaslProto::_internal_set_state(::Hdfs::Internal::RpcSaslProto_SaslState value) {
  assert(::Hdfs::Internal::RpcSaslProto_SaslState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
}
inline void RpcSaslProto::set_state(::Hdfs::Internal::RpcSaslProto_SaslState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.state)
}

// optional bytes token = 3;
inline bool RpcSaslProto::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcSaslProto::has_token() const {
  return _internal_has_token();
}
inline void RpcSaslProto::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RpcSaslProto::token() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.token)
  return _internal_token();
}
inline void RpcSaslProto::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RpcSaslProto.token)
}
inline std::string* RpcSaslProto::mutable_token() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.token)
  return _internal_mutable_token();
}
inline const std::string& RpcSaslProto::_internal_token() const {
  return token_.GetNoArena();
}
inline void RpcSaslProto::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RpcSaslProto::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.RpcSaslProto.token)
}
inline void RpcSaslProto::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.RpcSaslProto.token)
}
inline void RpcSaslProto::set_token(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.RpcSaslProto.token)
}
inline std::string* RpcSaslProto::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcSaslProto::release_token() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RpcSaslProto.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RpcSaslProto::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RpcSaslProto.token)
}

// repeated .Hdfs.Internal.RpcSaslProto.SaslAuth auths = 4;
inline int RpcSaslProto::_internal_auths_size() const {
  return auths_.size();
}
inline int RpcSaslProto::auths_size() const {
  return _internal_auths_size();
}
inline void RpcSaslProto::clear_auths() {
  auths_.Clear();
}
inline ::Hdfs::Internal::RpcSaslProto_SaslAuth* RpcSaslProto::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RpcSaslProto.auths)
  return auths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RpcSaslProto_SaslAuth >*
RpcSaslProto::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.RpcSaslProto.auths)
  return &auths_;
}
inline const ::Hdfs::Internal::RpcSaslProto_SaslAuth& RpcSaslProto::_internal_auths(int index) const {
  return auths_.Get(index);
}
inline const ::Hdfs::Internal::RpcSaslProto_SaslAuth& RpcSaslProto::auths(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RpcSaslProto.auths)
  return _internal_auths(index);
}
inline ::Hdfs::Internal::RpcSaslProto_SaslAuth* RpcSaslProto::_internal_add_auths() {
  return auths_.Add();
}
inline ::Hdfs::Internal::RpcSaslProto_SaslAuth* RpcSaslProto::add_auths() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.RpcSaslProto.auths)
  return _internal_add_auths();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RpcSaslProto_SaslAuth >&
RpcSaslProto::auths() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.RpcSaslProto.auths)
  return auths_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Internal
}  // namespace Hdfs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto>() {
  return ::Hdfs::Internal::RpcRequestHeaderProto_OperationProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto>() {
  return ::Hdfs::Internal::RpcResponseHeaderProto_RpcStatusProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto>() {
  return ::Hdfs::Internal::RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::RpcSaslProto_SaslState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::RpcSaslProto_SaslState>() {
  return ::Hdfs::Internal::RpcSaslProto_SaslState_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::RpcKindProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::RpcKindProto>() {
  return ::Hdfs::Internal::RpcKindProto_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_RpcHeader_2eproto
