// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datatransfer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_datatransfer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_datatransfer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Security.pb.h"
#include "hdfs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_datatransfer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_datatransfer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_datatransfer_2eproto;
namespace Hdfs {
namespace Internal {
class BaseHeaderProto;
class BaseHeaderProtoDefaultTypeInternal;
extern BaseHeaderProtoDefaultTypeInternal _BaseHeaderProto_default_instance_;
class BlockOpResponseProto;
class BlockOpResponseProtoDefaultTypeInternal;
extern BlockOpResponseProtoDefaultTypeInternal _BlockOpResponseProto_default_instance_;
class CachingStrategyProto;
class CachingStrategyProtoDefaultTypeInternal;
extern CachingStrategyProtoDefaultTypeInternal _CachingStrategyProto_default_instance_;
class ChecksumProto;
class ChecksumProtoDefaultTypeInternal;
extern ChecksumProtoDefaultTypeInternal _ChecksumProto_default_instance_;
class ClientOperationHeaderProto;
class ClientOperationHeaderProtoDefaultTypeInternal;
extern ClientOperationHeaderProtoDefaultTypeInternal _ClientOperationHeaderProto_default_instance_;
class ClientReadStatusProto;
class ClientReadStatusProtoDefaultTypeInternal;
extern ClientReadStatusProtoDefaultTypeInternal _ClientReadStatusProto_default_instance_;
class DNTransferAckProto;
class DNTransferAckProtoDefaultTypeInternal;
extern DNTransferAckProtoDefaultTypeInternal _DNTransferAckProto_default_instance_;
class DataTransferEncryptorMessageProto;
class DataTransferEncryptorMessageProtoDefaultTypeInternal;
extern DataTransferEncryptorMessageProtoDefaultTypeInternal _DataTransferEncryptorMessageProto_default_instance_;
class OpBlockChecksumProto;
class OpBlockChecksumProtoDefaultTypeInternal;
extern OpBlockChecksumProtoDefaultTypeInternal _OpBlockChecksumProto_default_instance_;
class OpBlockChecksumResponseProto;
class OpBlockChecksumResponseProtoDefaultTypeInternal;
extern OpBlockChecksumResponseProtoDefaultTypeInternal _OpBlockChecksumResponseProto_default_instance_;
class OpCopyBlockProto;
class OpCopyBlockProtoDefaultTypeInternal;
extern OpCopyBlockProtoDefaultTypeInternal _OpCopyBlockProto_default_instance_;
class OpReadBlockProto;
class OpReadBlockProtoDefaultTypeInternal;
extern OpReadBlockProtoDefaultTypeInternal _OpReadBlockProto_default_instance_;
class OpReplaceBlockProto;
class OpReplaceBlockProtoDefaultTypeInternal;
extern OpReplaceBlockProtoDefaultTypeInternal _OpReplaceBlockProto_default_instance_;
class OpRequestShortCircuitAccessProto;
class OpRequestShortCircuitAccessProtoDefaultTypeInternal;
extern OpRequestShortCircuitAccessProtoDefaultTypeInternal _OpRequestShortCircuitAccessProto_default_instance_;
class OpTransferBlockProto;
class OpTransferBlockProtoDefaultTypeInternal;
extern OpTransferBlockProtoDefaultTypeInternal _OpTransferBlockProto_default_instance_;
class OpWriteBlockProto;
class OpWriteBlockProtoDefaultTypeInternal;
extern OpWriteBlockProtoDefaultTypeInternal _OpWriteBlockProto_default_instance_;
class PacketHeaderProto;
class PacketHeaderProtoDefaultTypeInternal;
extern PacketHeaderProtoDefaultTypeInternal _PacketHeaderProto_default_instance_;
class PipelineAckProto;
class PipelineAckProtoDefaultTypeInternal;
extern PipelineAckProtoDefaultTypeInternal _PipelineAckProto_default_instance_;
class ReadOpChecksumInfoProto;
class ReadOpChecksumInfoProtoDefaultTypeInternal;
extern ReadOpChecksumInfoProtoDefaultTypeInternal _ReadOpChecksumInfoProto_default_instance_;
}  // namespace Internal
}  // namespace Hdfs
PROTOBUF_NAMESPACE_OPEN
template<> ::Hdfs::Internal::BaseHeaderProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(Arena*);
template<> ::Hdfs::Internal::BlockOpResponseProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BlockOpResponseProto>(Arena*);
template<> ::Hdfs::Internal::CachingStrategyProto* Arena::CreateMaybeMessage<::Hdfs::Internal::CachingStrategyProto>(Arena*);
template<> ::Hdfs::Internal::ChecksumProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ChecksumProto>(Arena*);
template<> ::Hdfs::Internal::ClientOperationHeaderProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ClientOperationHeaderProto>(Arena*);
template<> ::Hdfs::Internal::ClientReadStatusProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ClientReadStatusProto>(Arena*);
template<> ::Hdfs::Internal::DNTransferAckProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DNTransferAckProto>(Arena*);
template<> ::Hdfs::Internal::DataTransferEncryptorMessageProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DataTransferEncryptorMessageProto>(Arena*);
template<> ::Hdfs::Internal::OpBlockChecksumProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpBlockChecksumProto>(Arena*);
template<> ::Hdfs::Internal::OpBlockChecksumResponseProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpBlockChecksumResponseProto>(Arena*);
template<> ::Hdfs::Internal::OpCopyBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpCopyBlockProto>(Arena*);
template<> ::Hdfs::Internal::OpReadBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpReadBlockProto>(Arena*);
template<> ::Hdfs::Internal::OpReplaceBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpReplaceBlockProto>(Arena*);
template<> ::Hdfs::Internal::OpRequestShortCircuitAccessProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpRequestShortCircuitAccessProto>(Arena*);
template<> ::Hdfs::Internal::OpTransferBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpTransferBlockProto>(Arena*);
template<> ::Hdfs::Internal::OpWriteBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::OpWriteBlockProto>(Arena*);
template<> ::Hdfs::Internal::PacketHeaderProto* Arena::CreateMaybeMessage<::Hdfs::Internal::PacketHeaderProto>(Arena*);
template<> ::Hdfs::Internal::PipelineAckProto* Arena::CreateMaybeMessage<::Hdfs::Internal::PipelineAckProto>(Arena*);
template<> ::Hdfs::Internal::ReadOpChecksumInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ReadOpChecksumInfoProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Hdfs {
namespace Internal {

enum DataTransferEncryptorMessageProto_DataTransferEncryptorStatus : int {
  DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_SUCCESS = 0,
  DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_ERROR_UNKNOWN_KEY = 1,
  DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_ERROR = 2
};
bool DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_IsValid(int value);
constexpr DataTransferEncryptorMessageProto_DataTransferEncryptorStatus DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_MIN = DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_SUCCESS;
constexpr DataTransferEncryptorMessageProto_DataTransferEncryptorStatus DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_MAX = DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_ERROR;
constexpr int DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_ARRAYSIZE = DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_descriptor();
template<typename T>
inline const std::string& DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_descriptor(), enum_t_value);
}
inline bool DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_Parse(
    const std::string& name, DataTransferEncryptorMessageProto_DataTransferEncryptorStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>(
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_descriptor(), name, value);
}
enum OpWriteBlockProto_BlockConstructionStage : int {
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_APPEND = 0,
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_APPEND_RECOVERY = 1,
  OpWriteBlockProto_BlockConstructionStage_DATA_STREAMING = 2,
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_STREAMING_RECOVERY = 3,
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_CLOSE = 4,
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_CLOSE_RECOVERY = 5,
  OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_CREATE = 6,
  OpWriteBlockProto_BlockConstructionStage_TRANSFER_RBW = 7,
  OpWriteBlockProto_BlockConstructionStage_TRANSFER_FINALIZED = 8
};
bool OpWriteBlockProto_BlockConstructionStage_IsValid(int value);
constexpr OpWriteBlockProto_BlockConstructionStage OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_MIN = OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_APPEND;
constexpr OpWriteBlockProto_BlockConstructionStage OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_MAX = OpWriteBlockProto_BlockConstructionStage_TRANSFER_FINALIZED;
constexpr int OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_ARRAYSIZE = OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpWriteBlockProto_BlockConstructionStage_descriptor();
template<typename T>
inline const std::string& OpWriteBlockProto_BlockConstructionStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpWriteBlockProto_BlockConstructionStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpWriteBlockProto_BlockConstructionStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpWriteBlockProto_BlockConstructionStage_descriptor(), enum_t_value);
}
inline bool OpWriteBlockProto_BlockConstructionStage_Parse(
    const std::string& name, OpWriteBlockProto_BlockConstructionStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpWriteBlockProto_BlockConstructionStage>(
    OpWriteBlockProto_BlockConstructionStage_descriptor(), name, value);
}
enum Status : int {
  DT_PROTO_SUCCESS = 0,
  DT_PROTO_ERROR = 1,
  DT_PROTO_ERROR_CHECKSUM = 2,
  DT_PROTO_ERROR_INVALID = 3,
  DT_PROTO_ERROR_EXISTS = 4,
  DT_PROTO_ERROR_ACCESS_TOKEN = 5,
  DT_PROTO_CHECKSUM_OK = 6,
  DT_PROTO_ERROR_UNSUPPORTED = 7,
  DT_PROTO_OOB_RESTART = 8,
  DT_PROTO_OOB_RESERVED1 = 9,
  DT_PROTO_OOB_RESERVED2 = 10,
  DT_PROTO_OOB_RESERVED3 = 11,
  DT_PROTO_IN_PROGRESS = 12
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = DT_PROTO_SUCCESS;
constexpr Status Status_MAX = DT_PROTO_IN_PROGRESS;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    const std::string& name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class DataTransferEncryptorMessageProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DataTransferEncryptorMessageProto) */ {
 public:
  DataTransferEncryptorMessageProto();
  virtual ~DataTransferEncryptorMessageProto();

  DataTransferEncryptorMessageProto(const DataTransferEncryptorMessageProto& from);
  DataTransferEncryptorMessageProto(DataTransferEncryptorMessageProto&& from) noexcept
    : DataTransferEncryptorMessageProto() {
    *this = ::std::move(from);
  }

  inline DataTransferEncryptorMessageProto& operator=(const DataTransferEncryptorMessageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTransferEncryptorMessageProto& operator=(DataTransferEncryptorMessageProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataTransferEncryptorMessageProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataTransferEncryptorMessageProto* internal_default_instance() {
    return reinterpret_cast<const DataTransferEncryptorMessageProto*>(
               &_DataTransferEncryptorMessageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataTransferEncryptorMessageProto& a, DataTransferEncryptorMessageProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTransferEncryptorMessageProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataTransferEncryptorMessageProto* New() const final {
    return CreateMaybeMessage<DataTransferEncryptorMessageProto>(nullptr);
  }

  DataTransferEncryptorMessageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataTransferEncryptorMessageProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataTransferEncryptorMessageProto& from);
  void MergeFrom(const DataTransferEncryptorMessageProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTransferEncryptorMessageProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DataTransferEncryptorMessageProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DataTransferEncryptorMessageProto_DataTransferEncryptorStatus DataTransferEncryptorStatus;
  static constexpr DataTransferEncryptorStatus SUCCESS =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_SUCCESS;
  static constexpr DataTransferEncryptorStatus ERROR_UNKNOWN_KEY =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_ERROR_UNKNOWN_KEY;
  static constexpr DataTransferEncryptorStatus ERROR =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_ERROR;
  static inline bool DataTransferEncryptorStatus_IsValid(int value) {
    return DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_IsValid(value);
  }
  static constexpr DataTransferEncryptorStatus DataTransferEncryptorStatus_MIN =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_MIN;
  static constexpr DataTransferEncryptorStatus DataTransferEncryptorStatus_MAX =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_MAX;
  static constexpr int DataTransferEncryptorStatus_ARRAYSIZE =
    DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_DataTransferEncryptorStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataTransferEncryptorStatus_descriptor() {
    return DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& DataTransferEncryptorStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataTransferEncryptorStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataTransferEncryptorStatus_Name.");
    return DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_Name(enum_t_value);
  }
  static inline bool DataTransferEncryptorStatus_Parse(const std::string& name,
      DataTransferEncryptorStatus* value) {
    return DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCipherOptionFieldNumber = 4,
    kPayloadFieldNumber = 2,
    kMessageFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.CipherOptionProto cipherOption = 4;
  int cipheroption_size() const;
  private:
  int _internal_cipheroption_size() const;
  public:
  void clear_cipheroption();
  ::Hdfs::Internal::CipherOptionProto* mutable_cipheroption(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::CipherOptionProto >*
      mutable_cipheroption();
  private:
  const ::Hdfs::Internal::CipherOptionProto& _internal_cipheroption(int index) const;
  ::Hdfs::Internal::CipherOptionProto* _internal_add_cipheroption();
  public:
  const ::Hdfs::Internal::CipherOptionProto& cipheroption(int index) const;
  ::Hdfs::Internal::CipherOptionProto* add_cipheroption();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::CipherOptionProto >&
      cipheroption() const;

  // optional bytes payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required .Hdfs.Internal.DataTransferEncryptorMessageProto.DataTransferEncryptorStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus status() const;
  void set_status(::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus value);
  private:
  ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus _internal_status() const;
  void _internal_set_status(::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DataTransferEncryptorMessageProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::CipherOptionProto > cipheroption_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class BaseHeaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BaseHeaderProto) */ {
 public:
  BaseHeaderProto();
  virtual ~BaseHeaderProto();

  BaseHeaderProto(const BaseHeaderProto& from);
  BaseHeaderProto(BaseHeaderProto&& from) noexcept
    : BaseHeaderProto() {
    *this = ::std::move(from);
  }

  inline BaseHeaderProto& operator=(const BaseHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseHeaderProto& operator=(BaseHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BaseHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BaseHeaderProto* internal_default_instance() {
    return reinterpret_cast<const BaseHeaderProto*>(
               &_BaseHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BaseHeaderProto& a, BaseHeaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseHeaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseHeaderProto* New() const final {
    return CreateMaybeMessage<BaseHeaderProto>(nullptr);
  }

  BaseHeaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseHeaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseHeaderProto& from);
  void MergeFrom(const BaseHeaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseHeaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BaseHeaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // required .Hdfs.Internal.ExtendedBlockProto block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Hdfs::Internal::ExtendedBlockProto& block() const;
  ::Hdfs::Internal::ExtendedBlockProto* release_block();
  ::Hdfs::Internal::ExtendedBlockProto* mutable_block();
  void set_allocated_block(::Hdfs::Internal::ExtendedBlockProto* block);
  private:
  const ::Hdfs::Internal::ExtendedBlockProto& _internal_block() const;
  ::Hdfs::Internal::ExtendedBlockProto* _internal_mutable_block();
  public:

  // optional .Hdfs.Internal.TokenProto token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::Hdfs::Internal::TokenProto& token() const;
  ::Hdfs::Internal::TokenProto* release_token();
  ::Hdfs::Internal::TokenProto* mutable_token();
  void set_allocated_token(::Hdfs::Internal::TokenProto* token);
  private:
  const ::Hdfs::Internal::TokenProto& _internal_token() const;
  ::Hdfs::Internal::TokenProto* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BaseHeaderProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::ExtendedBlockProto* block_;
  ::Hdfs::Internal::TokenProto* token_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class ClientOperationHeaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ClientOperationHeaderProto) */ {
 public:
  ClientOperationHeaderProto();
  virtual ~ClientOperationHeaderProto();

  ClientOperationHeaderProto(const ClientOperationHeaderProto& from);
  ClientOperationHeaderProto(ClientOperationHeaderProto&& from) noexcept
    : ClientOperationHeaderProto() {
    *this = ::std::move(from);
  }

  inline ClientOperationHeaderProto& operator=(const ClientOperationHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientOperationHeaderProto& operator=(ClientOperationHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientOperationHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientOperationHeaderProto* internal_default_instance() {
    return reinterpret_cast<const ClientOperationHeaderProto*>(
               &_ClientOperationHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientOperationHeaderProto& a, ClientOperationHeaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientOperationHeaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientOperationHeaderProto* New() const final {
    return CreateMaybeMessage<ClientOperationHeaderProto>(nullptr);
  }

  ClientOperationHeaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientOperationHeaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientOperationHeaderProto& from);
  void MergeFrom(const ClientOperationHeaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientOperationHeaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ClientOperationHeaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 2,
    kBaseHeaderFieldNumber = 1,
  };
  // required string clientName = 2;
  bool has_clientname() const;
  private:
  bool _internal_has_clientname() const;
  public:
  void clear_clientname();
  const std::string& clientname() const;
  void set_clientname(const std::string& value);
  void set_clientname(std::string&& value);
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  std::string* mutable_clientname();
  std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // required .Hdfs.Internal.BaseHeaderProto baseHeader = 1;
  bool has_baseheader() const;
  private:
  bool _internal_has_baseheader() const;
  public:
  void clear_baseheader();
  const ::Hdfs::Internal::BaseHeaderProto& baseheader() const;
  ::Hdfs::Internal::BaseHeaderProto* release_baseheader();
  ::Hdfs::Internal::BaseHeaderProto* mutable_baseheader();
  void set_allocated_baseheader(::Hdfs::Internal::BaseHeaderProto* baseheader);
  private:
  const ::Hdfs::Internal::BaseHeaderProto& _internal_baseheader() const;
  ::Hdfs::Internal::BaseHeaderProto* _internal_mutable_baseheader();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ClientOperationHeaderProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::Hdfs::Internal::BaseHeaderProto* baseheader_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class CachingStrategyProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.CachingStrategyProto) */ {
 public:
  CachingStrategyProto();
  virtual ~CachingStrategyProto();

  CachingStrategyProto(const CachingStrategyProto& from);
  CachingStrategyProto(CachingStrategyProto&& from) noexcept
    : CachingStrategyProto() {
    *this = ::std::move(from);
  }

  inline CachingStrategyProto& operator=(const CachingStrategyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CachingStrategyProto& operator=(CachingStrategyProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CachingStrategyProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CachingStrategyProto* internal_default_instance() {
    return reinterpret_cast<const CachingStrategyProto*>(
               &_CachingStrategyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CachingStrategyProto& a, CachingStrategyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CachingStrategyProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CachingStrategyProto* New() const final {
    return CreateMaybeMessage<CachingStrategyProto>(nullptr);
  }

  CachingStrategyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CachingStrategyProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CachingStrategyProto& from);
  void MergeFrom(const CachingStrategyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CachingStrategyProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.CachingStrategyProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadaheadFieldNumber = 2,
    kDropBehindFieldNumber = 1,
  };
  // optional int64 readahead = 2;
  bool has_readahead() const;
  private:
  bool _internal_has_readahead() const;
  public:
  void clear_readahead();
  ::PROTOBUF_NAMESPACE_ID::int64 readahead() const;
  void set_readahead(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_readahead() const;
  void _internal_set_readahead(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool dropBehind = 1;
  bool has_dropbehind() const;
  private:
  bool _internal_has_dropbehind() const;
  public:
  void clear_dropbehind();
  bool dropbehind() const;
  void set_dropbehind(bool value);
  private:
  bool _internal_dropbehind() const;
  void _internal_set_dropbehind(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.CachingStrategyProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 readahead_;
  bool dropbehind_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpReadBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpReadBlockProto) */ {
 public:
  OpReadBlockProto();
  virtual ~OpReadBlockProto();

  OpReadBlockProto(const OpReadBlockProto& from);
  OpReadBlockProto(OpReadBlockProto&& from) noexcept
    : OpReadBlockProto() {
    *this = ::std::move(from);
  }

  inline OpReadBlockProto& operator=(const OpReadBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpReadBlockProto& operator=(OpReadBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpReadBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpReadBlockProto* internal_default_instance() {
    return reinterpret_cast<const OpReadBlockProto*>(
               &_OpReadBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OpReadBlockProto& a, OpReadBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpReadBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpReadBlockProto* New() const final {
    return CreateMaybeMessage<OpReadBlockProto>(nullptr);
  }

  OpReadBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpReadBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpReadBlockProto& from);
  void MergeFrom(const OpReadBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpReadBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpReadBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCachingStrategyFieldNumber = 5,
    kOffsetFieldNumber = 2,
    kLenFieldNumber = 3,
    kSendChecksumsFieldNumber = 4,
  };
  // required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::ClientOperationHeaderProto& header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* release_header();
  ::Hdfs::Internal::ClientOperationHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header);
  private:
  const ::Hdfs::Internal::ClientOperationHeaderProto& _internal_header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* _internal_mutable_header();
  public:

  // optional .Hdfs.Internal.CachingStrategyProto cachingStrategy = 5;
  bool has_cachingstrategy() const;
  private:
  bool _internal_has_cachingstrategy() const;
  public:
  void clear_cachingstrategy();
  const ::Hdfs::Internal::CachingStrategyProto& cachingstrategy() const;
  ::Hdfs::Internal::CachingStrategyProto* release_cachingstrategy();
  ::Hdfs::Internal::CachingStrategyProto* mutable_cachingstrategy();
  void set_allocated_cachingstrategy(::Hdfs::Internal::CachingStrategyProto* cachingstrategy);
  private:
  const ::Hdfs::Internal::CachingStrategyProto& _internal_cachingstrategy() const;
  ::Hdfs::Internal::CachingStrategyProto* _internal_mutable_cachingstrategy();
  public:

  // required uint64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 len = 3;
  bool has_len() const;
  private:
  bool _internal_has_len() const;
  public:
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::uint64 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_len() const;
  void _internal_set_len(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool sendChecksums = 4 [default = true];
  bool has_sendchecksums() const;
  private:
  bool _internal_has_sendchecksums() const;
  public:
  void clear_sendchecksums();
  bool sendchecksums() const;
  void set_sendchecksums(bool value);
  private:
  bool _internal_sendchecksums() const;
  void _internal_set_sendchecksums(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpReadBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::ClientOperationHeaderProto* header_;
  ::Hdfs::Internal::CachingStrategyProto* cachingstrategy_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 len_;
  bool sendchecksums_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class ChecksumProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ChecksumProto) */ {
 public:
  ChecksumProto();
  virtual ~ChecksumProto();

  ChecksumProto(const ChecksumProto& from);
  ChecksumProto(ChecksumProto&& from) noexcept
    : ChecksumProto() {
    *this = ::std::move(from);
  }

  inline ChecksumProto& operator=(const ChecksumProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChecksumProto& operator=(ChecksumProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChecksumProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChecksumProto* internal_default_instance() {
    return reinterpret_cast<const ChecksumProto*>(
               &_ChecksumProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChecksumProto& a, ChecksumProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ChecksumProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChecksumProto* New() const final {
    return CreateMaybeMessage<ChecksumProto>(nullptr);
  }

  ChecksumProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChecksumProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChecksumProto& from);
  void MergeFrom(const ChecksumProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChecksumProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ChecksumProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBytesPerChecksumFieldNumber = 2,
  };
  // required .Hdfs.Internal.ChecksumTypeProto type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Hdfs::Internal::ChecksumTypeProto type() const;
  void set_type(::Hdfs::Internal::ChecksumTypeProto value);
  private:
  ::Hdfs::Internal::ChecksumTypeProto _internal_type() const;
  void _internal_set_type(::Hdfs::Internal::ChecksumTypeProto value);
  public:

  // required uint32 bytesPerChecksum = 2;
  bool has_bytesperchecksum() const;
  private:
  bool _internal_has_bytesperchecksum() const;
  public:
  void clear_bytesperchecksum();
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperchecksum() const;
  void set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bytesperchecksum() const;
  void _internal_set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ChecksumProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperchecksum_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpWriteBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpWriteBlockProto) */ {
 public:
  OpWriteBlockProto();
  virtual ~OpWriteBlockProto();

  OpWriteBlockProto(const OpWriteBlockProto& from);
  OpWriteBlockProto(OpWriteBlockProto&& from) noexcept
    : OpWriteBlockProto() {
    *this = ::std::move(from);
  }

  inline OpWriteBlockProto& operator=(const OpWriteBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpWriteBlockProto& operator=(OpWriteBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpWriteBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpWriteBlockProto* internal_default_instance() {
    return reinterpret_cast<const OpWriteBlockProto*>(
               &_OpWriteBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OpWriteBlockProto& a, OpWriteBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpWriteBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpWriteBlockProto* New() const final {
    return CreateMaybeMessage<OpWriteBlockProto>(nullptr);
  }

  OpWriteBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpWriteBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpWriteBlockProto& from);
  void MergeFrom(const OpWriteBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpWriteBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpWriteBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef OpWriteBlockProto_BlockConstructionStage BlockConstructionStage;
  static constexpr BlockConstructionStage PIPELINE_SETUP_APPEND =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_APPEND;
  static constexpr BlockConstructionStage PIPELINE_SETUP_APPEND_RECOVERY =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_APPEND_RECOVERY;
  static constexpr BlockConstructionStage DATA_STREAMING =
    OpWriteBlockProto_BlockConstructionStage_DATA_STREAMING;
  static constexpr BlockConstructionStage PIPELINE_SETUP_STREAMING_RECOVERY =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_STREAMING_RECOVERY;
  static constexpr BlockConstructionStage PIPELINE_CLOSE =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_CLOSE;
  static constexpr BlockConstructionStage PIPELINE_CLOSE_RECOVERY =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_CLOSE_RECOVERY;
  static constexpr BlockConstructionStage PIPELINE_SETUP_CREATE =
    OpWriteBlockProto_BlockConstructionStage_PIPELINE_SETUP_CREATE;
  static constexpr BlockConstructionStage TRANSFER_RBW =
    OpWriteBlockProto_BlockConstructionStage_TRANSFER_RBW;
  static constexpr BlockConstructionStage TRANSFER_FINALIZED =
    OpWriteBlockProto_BlockConstructionStage_TRANSFER_FINALIZED;
  static inline bool BlockConstructionStage_IsValid(int value) {
    return OpWriteBlockProto_BlockConstructionStage_IsValid(value);
  }
  static constexpr BlockConstructionStage BlockConstructionStage_MIN =
    OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_MIN;
  static constexpr BlockConstructionStage BlockConstructionStage_MAX =
    OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_MAX;
  static constexpr int BlockConstructionStage_ARRAYSIZE =
    OpWriteBlockProto_BlockConstructionStage_BlockConstructionStage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BlockConstructionStage_descriptor() {
    return OpWriteBlockProto_BlockConstructionStage_descriptor();
  }
  template<typename T>
  static inline const std::string& BlockConstructionStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlockConstructionStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlockConstructionStage_Name.");
    return OpWriteBlockProto_BlockConstructionStage_Name(enum_t_value);
  }
  static inline bool BlockConstructionStage_Parse(const std::string& name,
      BlockConstructionStage* value) {
    return OpWriteBlockProto_BlockConstructionStage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kSourceFieldNumber = 3,
    kRequestedChecksumFieldNumber = 9,
    kCachingStrategyFieldNumber = 10,
    kStageFieldNumber = 4,
    kPipelineSizeFieldNumber = 5,
    kMinBytesRcvdFieldNumber = 6,
    kMaxBytesRcvdFieldNumber = 7,
    kLatestGenerationStampFieldNumber = 8,
  };
  // repeated .Hdfs.Internal.DatanodeInfoProto targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
      mutable_targets();
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_targets(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_add_targets();
  public:
  const ::Hdfs::Internal::DatanodeInfoProto& targets(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
      targets() const;

  // required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::ClientOperationHeaderProto& header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* release_header();
  ::Hdfs::Internal::ClientOperationHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header);
  private:
  const ::Hdfs::Internal::ClientOperationHeaderProto& _internal_header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* _internal_mutable_header();
  public:

  // optional .Hdfs.Internal.DatanodeInfoProto source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Hdfs::Internal::DatanodeInfoProto& source() const;
  ::Hdfs::Internal::DatanodeInfoProto* release_source();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_source();
  void set_allocated_source(::Hdfs::Internal::DatanodeInfoProto* source);
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_source() const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_mutable_source();
  public:

  // required .Hdfs.Internal.ChecksumProto requestedChecksum = 9;
  bool has_requestedchecksum() const;
  private:
  bool _internal_has_requestedchecksum() const;
  public:
  void clear_requestedchecksum();
  const ::Hdfs::Internal::ChecksumProto& requestedchecksum() const;
  ::Hdfs::Internal::ChecksumProto* release_requestedchecksum();
  ::Hdfs::Internal::ChecksumProto* mutable_requestedchecksum();
  void set_allocated_requestedchecksum(::Hdfs::Internal::ChecksumProto* requestedchecksum);
  private:
  const ::Hdfs::Internal::ChecksumProto& _internal_requestedchecksum() const;
  ::Hdfs::Internal::ChecksumProto* _internal_mutable_requestedchecksum();
  public:

  // optional .Hdfs.Internal.CachingStrategyProto cachingStrategy = 10;
  bool has_cachingstrategy() const;
  private:
  bool _internal_has_cachingstrategy() const;
  public:
  void clear_cachingstrategy();
  const ::Hdfs::Internal::CachingStrategyProto& cachingstrategy() const;
  ::Hdfs::Internal::CachingStrategyProto* release_cachingstrategy();
  ::Hdfs::Internal::CachingStrategyProto* mutable_cachingstrategy();
  void set_allocated_cachingstrategy(::Hdfs::Internal::CachingStrategyProto* cachingstrategy);
  private:
  const ::Hdfs::Internal::CachingStrategyProto& _internal_cachingstrategy() const;
  ::Hdfs::Internal::CachingStrategyProto* _internal_mutable_cachingstrategy();
  public:

  // required .Hdfs.Internal.OpWriteBlockProto.BlockConstructionStage stage = 4;
  bool has_stage() const;
  private:
  bool _internal_has_stage() const;
  public:
  void clear_stage();
  ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage stage() const;
  void set_stage(::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage value);
  private:
  ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage _internal_stage() const;
  void _internal_set_stage(::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage value);
  public:

  // required uint32 pipelineSize = 5;
  bool has_pipelinesize() const;
  private:
  bool _internal_has_pipelinesize() const;
  public:
  void clear_pipelinesize();
  ::PROTOBUF_NAMESPACE_ID::uint32 pipelinesize() const;
  void set_pipelinesize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pipelinesize() const;
  void _internal_set_pipelinesize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint64 minBytesRcvd = 6;
  bool has_minbytesrcvd() const;
  private:
  bool _internal_has_minbytesrcvd() const;
  public:
  void clear_minbytesrcvd();
  ::PROTOBUF_NAMESPACE_ID::uint64 minbytesrcvd() const;
  void set_minbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_minbytesrcvd() const;
  void _internal_set_minbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 maxBytesRcvd = 7;
  bool has_maxbytesrcvd() const;
  private:
  bool _internal_has_maxbytesrcvd() const;
  public:
  void clear_maxbytesrcvd();
  ::PROTOBUF_NAMESPACE_ID::uint64 maxbytesrcvd() const;
  void set_maxbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_maxbytesrcvd() const;
  void _internal_set_maxbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 latestGenerationStamp = 8;
  bool has_latestgenerationstamp() const;
  private:
  bool _internal_has_latestgenerationstamp() const;
  public:
  void clear_latestgenerationstamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 latestgenerationstamp() const;
  void set_latestgenerationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_latestgenerationstamp() const;
  void _internal_set_latestgenerationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpWriteBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto > targets_;
  ::Hdfs::Internal::ClientOperationHeaderProto* header_;
  ::Hdfs::Internal::DatanodeInfoProto* source_;
  ::Hdfs::Internal::ChecksumProto* requestedchecksum_;
  ::Hdfs::Internal::CachingStrategyProto* cachingstrategy_;
  int stage_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pipelinesize_;
  ::PROTOBUF_NAMESPACE_ID::uint64 minbytesrcvd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 maxbytesrcvd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 latestgenerationstamp_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpTransferBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpTransferBlockProto) */ {
 public:
  OpTransferBlockProto();
  virtual ~OpTransferBlockProto();

  OpTransferBlockProto(const OpTransferBlockProto& from);
  OpTransferBlockProto(OpTransferBlockProto&& from) noexcept
    : OpTransferBlockProto() {
    *this = ::std::move(from);
  }

  inline OpTransferBlockProto& operator=(const OpTransferBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpTransferBlockProto& operator=(OpTransferBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpTransferBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpTransferBlockProto* internal_default_instance() {
    return reinterpret_cast<const OpTransferBlockProto*>(
               &_OpTransferBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpTransferBlockProto& a, OpTransferBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpTransferBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpTransferBlockProto* New() const final {
    return CreateMaybeMessage<OpTransferBlockProto>(nullptr);
  }

  OpTransferBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpTransferBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpTransferBlockProto& from);
  void MergeFrom(const OpTransferBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpTransferBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpTransferBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.DatanodeInfoProto targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
      mutable_targets();
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_targets(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_add_targets();
  public:
  const ::Hdfs::Internal::DatanodeInfoProto& targets(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
      targets() const;

  // required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::ClientOperationHeaderProto& header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* release_header();
  ::Hdfs::Internal::ClientOperationHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header);
  private:
  const ::Hdfs::Internal::ClientOperationHeaderProto& _internal_header() const;
  ::Hdfs::Internal::ClientOperationHeaderProto* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpTransferBlockProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto > targets_;
  ::Hdfs::Internal::ClientOperationHeaderProto* header_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpReplaceBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpReplaceBlockProto) */ {
 public:
  OpReplaceBlockProto();
  virtual ~OpReplaceBlockProto();

  OpReplaceBlockProto(const OpReplaceBlockProto& from);
  OpReplaceBlockProto(OpReplaceBlockProto&& from) noexcept
    : OpReplaceBlockProto() {
    *this = ::std::move(from);
  }

  inline OpReplaceBlockProto& operator=(const OpReplaceBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpReplaceBlockProto& operator=(OpReplaceBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpReplaceBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpReplaceBlockProto* internal_default_instance() {
    return reinterpret_cast<const OpReplaceBlockProto*>(
               &_OpReplaceBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OpReplaceBlockProto& a, OpReplaceBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpReplaceBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpReplaceBlockProto* New() const final {
    return CreateMaybeMessage<OpReplaceBlockProto>(nullptr);
  }

  OpReplaceBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpReplaceBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpReplaceBlockProto& from);
  void MergeFrom(const OpReplaceBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpReplaceBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpReplaceBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelHintFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kSourceFieldNumber = 3,
  };
  // required string delHint = 2;
  bool has_delhint() const;
  private:
  bool _internal_has_delhint() const;
  public:
  void clear_delhint();
  const std::string& delhint() const;
  void set_delhint(const std::string& value);
  void set_delhint(std::string&& value);
  void set_delhint(const char* value);
  void set_delhint(const char* value, size_t size);
  std::string* mutable_delhint();
  std::string* release_delhint();
  void set_allocated_delhint(std::string* delhint);
  private:
  const std::string& _internal_delhint() const;
  void _internal_set_delhint(const std::string& value);
  std::string* _internal_mutable_delhint();
  public:

  // required .Hdfs.Internal.BaseHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::BaseHeaderProto& header() const;
  ::Hdfs::Internal::BaseHeaderProto* release_header();
  ::Hdfs::Internal::BaseHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header);
  private:
  const ::Hdfs::Internal::BaseHeaderProto& _internal_header() const;
  ::Hdfs::Internal::BaseHeaderProto* _internal_mutable_header();
  public:

  // required .Hdfs.Internal.DatanodeInfoProto source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Hdfs::Internal::DatanodeInfoProto& source() const;
  ::Hdfs::Internal::DatanodeInfoProto* release_source();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_source();
  void set_allocated_source(::Hdfs::Internal::DatanodeInfoProto* source);
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_source() const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_mutable_source();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpReplaceBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delhint_;
  ::Hdfs::Internal::BaseHeaderProto* header_;
  ::Hdfs::Internal::DatanodeInfoProto* source_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpCopyBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpCopyBlockProto) */ {
 public:
  OpCopyBlockProto();
  virtual ~OpCopyBlockProto();

  OpCopyBlockProto(const OpCopyBlockProto& from);
  OpCopyBlockProto(OpCopyBlockProto&& from) noexcept
    : OpCopyBlockProto() {
    *this = ::std::move(from);
  }

  inline OpCopyBlockProto& operator=(const OpCopyBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpCopyBlockProto& operator=(OpCopyBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpCopyBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpCopyBlockProto* internal_default_instance() {
    return reinterpret_cast<const OpCopyBlockProto*>(
               &_OpCopyBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OpCopyBlockProto& a, OpCopyBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpCopyBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpCopyBlockProto* New() const final {
    return CreateMaybeMessage<OpCopyBlockProto>(nullptr);
  }

  OpCopyBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpCopyBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpCopyBlockProto& from);
  void MergeFrom(const OpCopyBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpCopyBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpCopyBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // required .Hdfs.Internal.BaseHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::BaseHeaderProto& header() const;
  ::Hdfs::Internal::BaseHeaderProto* release_header();
  ::Hdfs::Internal::BaseHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header);
  private:
  const ::Hdfs::Internal::BaseHeaderProto& _internal_header() const;
  ::Hdfs::Internal::BaseHeaderProto* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpCopyBlockProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::BaseHeaderProto* header_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpBlockChecksumProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpBlockChecksumProto) */ {
 public:
  OpBlockChecksumProto();
  virtual ~OpBlockChecksumProto();

  OpBlockChecksumProto(const OpBlockChecksumProto& from);
  OpBlockChecksumProto(OpBlockChecksumProto&& from) noexcept
    : OpBlockChecksumProto() {
    *this = ::std::move(from);
  }

  inline OpBlockChecksumProto& operator=(const OpBlockChecksumProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpBlockChecksumProto& operator=(OpBlockChecksumProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpBlockChecksumProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpBlockChecksumProto* internal_default_instance() {
    return reinterpret_cast<const OpBlockChecksumProto*>(
               &_OpBlockChecksumProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OpBlockChecksumProto& a, OpBlockChecksumProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpBlockChecksumProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpBlockChecksumProto* New() const final {
    return CreateMaybeMessage<OpBlockChecksumProto>(nullptr);
  }

  OpBlockChecksumProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpBlockChecksumProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpBlockChecksumProto& from);
  void MergeFrom(const OpBlockChecksumProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpBlockChecksumProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpBlockChecksumProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // required .Hdfs.Internal.BaseHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::BaseHeaderProto& header() const;
  ::Hdfs::Internal::BaseHeaderProto* release_header();
  ::Hdfs::Internal::BaseHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header);
  private:
  const ::Hdfs::Internal::BaseHeaderProto& _internal_header() const;
  ::Hdfs::Internal::BaseHeaderProto* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpBlockChecksumProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::BaseHeaderProto* header_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpRequestShortCircuitAccessProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpRequestShortCircuitAccessProto) */ {
 public:
  OpRequestShortCircuitAccessProto();
  virtual ~OpRequestShortCircuitAccessProto();

  OpRequestShortCircuitAccessProto(const OpRequestShortCircuitAccessProto& from);
  OpRequestShortCircuitAccessProto(OpRequestShortCircuitAccessProto&& from) noexcept
    : OpRequestShortCircuitAccessProto() {
    *this = ::std::move(from);
  }

  inline OpRequestShortCircuitAccessProto& operator=(const OpRequestShortCircuitAccessProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpRequestShortCircuitAccessProto& operator=(OpRequestShortCircuitAccessProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpRequestShortCircuitAccessProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpRequestShortCircuitAccessProto* internal_default_instance() {
    return reinterpret_cast<const OpRequestShortCircuitAccessProto*>(
               &_OpRequestShortCircuitAccessProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OpRequestShortCircuitAccessProto& a, OpRequestShortCircuitAccessProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpRequestShortCircuitAccessProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpRequestShortCircuitAccessProto* New() const final {
    return CreateMaybeMessage<OpRequestShortCircuitAccessProto>(nullptr);
  }

  OpRequestShortCircuitAccessProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpRequestShortCircuitAccessProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpRequestShortCircuitAccessProto& from);
  void MergeFrom(const OpRequestShortCircuitAccessProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpRequestShortCircuitAccessProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpRequestShortCircuitAccessProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMaxVersionFieldNumber = 2,
  };
  // required .Hdfs.Internal.BaseHeaderProto header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::Hdfs::Internal::BaseHeaderProto& header() const;
  ::Hdfs::Internal::BaseHeaderProto* release_header();
  ::Hdfs::Internal::BaseHeaderProto* mutable_header();
  void set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header);
  private:
  const ::Hdfs::Internal::BaseHeaderProto& _internal_header() const;
  ::Hdfs::Internal::BaseHeaderProto* _internal_mutable_header();
  public:

  // required uint32 maxVersion = 2;
  bool has_maxversion() const;
  private:
  bool _internal_has_maxversion() const;
  public:
  void clear_maxversion();
  ::PROTOBUF_NAMESPACE_ID::uint32 maxversion() const;
  void set_maxversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_maxversion() const;
  void _internal_set_maxversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpRequestShortCircuitAccessProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::BaseHeaderProto* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 maxversion_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class PacketHeaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.PacketHeaderProto) */ {
 public:
  PacketHeaderProto();
  virtual ~PacketHeaderProto();

  PacketHeaderProto(const PacketHeaderProto& from);
  PacketHeaderProto(PacketHeaderProto&& from) noexcept
    : PacketHeaderProto() {
    *this = ::std::move(from);
  }

  inline PacketHeaderProto& operator=(const PacketHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketHeaderProto& operator=(PacketHeaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PacketHeaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PacketHeaderProto* internal_default_instance() {
    return reinterpret_cast<const PacketHeaderProto*>(
               &_PacketHeaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PacketHeaderProto& a, PacketHeaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketHeaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketHeaderProto* New() const final {
    return CreateMaybeMessage<PacketHeaderProto>(nullptr);
  }

  PacketHeaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketHeaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PacketHeaderProto& from);
  void MergeFrom(const PacketHeaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketHeaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.PacketHeaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetInBlockFieldNumber = 1,
    kSeqnoFieldNumber = 2,
    kDataLenFieldNumber = 4,
    kLastPacketInBlockFieldNumber = 3,
    kSyncBlockFieldNumber = 5,
  };
  // required sfixed64 offsetInBlock = 1;
  bool has_offsetinblock() const;
  private:
  bool _internal_has_offsetinblock() const;
  public:
  void clear_offsetinblock();
  ::PROTOBUF_NAMESPACE_ID::int64 offsetinblock() const;
  void set_offsetinblock(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offsetinblock() const;
  void _internal_set_offsetinblock(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required sfixed64 seqno = 2;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  ::PROTOBUF_NAMESPACE_ID::int64 seqno() const;
  void set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seqno() const;
  void _internal_set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required sfixed32 dataLen = 4;
  bool has_datalen() const;
  private:
  bool _internal_has_datalen() const;
  public:
  void clear_datalen();
  ::PROTOBUF_NAMESPACE_ID::int32 datalen() const;
  void set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datalen() const;
  void _internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool lastPacketInBlock = 3;
  bool has_lastpacketinblock() const;
  private:
  bool _internal_has_lastpacketinblock() const;
  public:
  void clear_lastpacketinblock();
  bool lastpacketinblock() const;
  void set_lastpacketinblock(bool value);
  private:
  bool _internal_lastpacketinblock() const;
  void _internal_set_lastpacketinblock(bool value);
  public:

  // optional bool syncBlock = 5 [default = false];
  bool has_syncblock() const;
  private:
  bool _internal_has_syncblock() const;
  public:
  void clear_syncblock();
  bool syncblock() const;
  void set_syncblock(bool value);
  private:
  bool _internal_syncblock() const;
  void _internal_set_syncblock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.PacketHeaderProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 offsetinblock_;
  ::PROTOBUF_NAMESPACE_ID::int64 seqno_;
  ::PROTOBUF_NAMESPACE_ID::int32 datalen_;
  bool lastpacketinblock_;
  bool syncblock_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class PipelineAckProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.PipelineAckProto) */ {
 public:
  PipelineAckProto();
  virtual ~PipelineAckProto();

  PipelineAckProto(const PipelineAckProto& from);
  PipelineAckProto(PipelineAckProto&& from) noexcept
    : PipelineAckProto() {
    *this = ::std::move(from);
  }

  inline PipelineAckProto& operator=(const PipelineAckProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineAckProto& operator=(PipelineAckProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PipelineAckProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PipelineAckProto* internal_default_instance() {
    return reinterpret_cast<const PipelineAckProto*>(
               &_PipelineAckProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PipelineAckProto& a, PipelineAckProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineAckProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PipelineAckProto* New() const final {
    return CreateMaybeMessage<PipelineAckProto>(nullptr);
  }

  PipelineAckProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PipelineAckProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PipelineAckProto& from);
  void MergeFrom(const PipelineAckProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PipelineAckProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.PipelineAckProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSeqnoFieldNumber = 1,
    kDownstreamAckTimeNanosFieldNumber = 3,
  };
  // repeated .Hdfs.Internal.Status status = 2;
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  private:
  ::Hdfs::Internal::Status _internal_status(int index) const;
  void _internal_add_status(::Hdfs::Internal::Status value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_status();
  public:
  ::Hdfs::Internal::Status status(int index) const;
  void set_status(int index, ::Hdfs::Internal::Status value);
  void add_status(::Hdfs::Internal::Status value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& status() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_status();

  // required sint64 seqno = 1;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  ::PROTOBUF_NAMESPACE_ID::int64 seqno() const;
  void set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seqno() const;
  void _internal_set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 downstreamAckTimeNanos = 3 [default = 0];
  bool has_downstreamacktimenanos() const;
  private:
  bool _internal_has_downstreamacktimenanos() const;
  public:
  void clear_downstreamacktimenanos();
  ::PROTOBUF_NAMESPACE_ID::uint64 downstreamacktimenanos() const;
  void set_downstreamacktimenanos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_downstreamacktimenanos() const;
  void _internal_set_downstreamacktimenanos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.PipelineAckProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> status_;
  ::PROTOBUF_NAMESPACE_ID::int64 seqno_;
  ::PROTOBUF_NAMESPACE_ID::uint64 downstreamacktimenanos_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class ReadOpChecksumInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ReadOpChecksumInfoProto) */ {
 public:
  ReadOpChecksumInfoProto();
  virtual ~ReadOpChecksumInfoProto();

  ReadOpChecksumInfoProto(const ReadOpChecksumInfoProto& from);
  ReadOpChecksumInfoProto(ReadOpChecksumInfoProto&& from) noexcept
    : ReadOpChecksumInfoProto() {
    *this = ::std::move(from);
  }

  inline ReadOpChecksumInfoProto& operator=(const ReadOpChecksumInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOpChecksumInfoProto& operator=(ReadOpChecksumInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadOpChecksumInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadOpChecksumInfoProto* internal_default_instance() {
    return reinterpret_cast<const ReadOpChecksumInfoProto*>(
               &_ReadOpChecksumInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadOpChecksumInfoProto& a, ReadOpChecksumInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOpChecksumInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadOpChecksumInfoProto* New() const final {
    return CreateMaybeMessage<ReadOpChecksumInfoProto>(nullptr);
  }

  ReadOpChecksumInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadOpChecksumInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadOpChecksumInfoProto& from);
  void MergeFrom(const ReadOpChecksumInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOpChecksumInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ReadOpChecksumInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChecksumFieldNumber = 1,
    kChunkOffsetFieldNumber = 2,
  };
  // required .Hdfs.Internal.ChecksumProto checksum = 1;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  const ::Hdfs::Internal::ChecksumProto& checksum() const;
  ::Hdfs::Internal::ChecksumProto* release_checksum();
  ::Hdfs::Internal::ChecksumProto* mutable_checksum();
  void set_allocated_checksum(::Hdfs::Internal::ChecksumProto* checksum);
  private:
  const ::Hdfs::Internal::ChecksumProto& _internal_checksum() const;
  ::Hdfs::Internal::ChecksumProto* _internal_mutable_checksum();
  public:

  // required uint64 chunkOffset = 2;
  bool has_chunkoffset() const;
  private:
  bool _internal_has_chunkoffset() const;
  public:
  void clear_chunkoffset();
  ::PROTOBUF_NAMESPACE_ID::uint64 chunkoffset() const;
  void set_chunkoffset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_chunkoffset() const;
  void _internal_set_chunkoffset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ReadOpChecksumInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::ChecksumProto* checksum_;
  ::PROTOBUF_NAMESPACE_ID::uint64 chunkoffset_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class BlockOpResponseProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BlockOpResponseProto) */ {
 public:
  BlockOpResponseProto();
  virtual ~BlockOpResponseProto();

  BlockOpResponseProto(const BlockOpResponseProto& from);
  BlockOpResponseProto(BlockOpResponseProto&& from) noexcept
    : BlockOpResponseProto() {
    *this = ::std::move(from);
  }

  inline BlockOpResponseProto& operator=(const BlockOpResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockOpResponseProto& operator=(BlockOpResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockOpResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockOpResponseProto* internal_default_instance() {
    return reinterpret_cast<const BlockOpResponseProto*>(
               &_BlockOpResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BlockOpResponseProto& a, BlockOpResponseProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockOpResponseProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockOpResponseProto* New() const final {
    return CreateMaybeMessage<BlockOpResponseProto>(nullptr);
  }

  BlockOpResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockOpResponseProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockOpResponseProto& from);
  void MergeFrom(const BlockOpResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockOpResponseProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BlockOpResponseProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstBadLinkFieldNumber = 2,
    kMessageFieldNumber = 5,
    kChecksumResponseFieldNumber = 3,
    kReadOpChecksumInfoFieldNumber = 4,
    kStatusFieldNumber = 1,
    kShortCircuitAccessVersionFieldNumber = 6,
  };
  // optional string firstBadLink = 2;
  bool has_firstbadlink() const;
  private:
  bool _internal_has_firstbadlink() const;
  public:
  void clear_firstbadlink();
  const std::string& firstbadlink() const;
  void set_firstbadlink(const std::string& value);
  void set_firstbadlink(std::string&& value);
  void set_firstbadlink(const char* value);
  void set_firstbadlink(const char* value, size_t size);
  std::string* mutable_firstbadlink();
  std::string* release_firstbadlink();
  void set_allocated_firstbadlink(std::string* firstbadlink);
  private:
  const std::string& _internal_firstbadlink() const;
  void _internal_set_firstbadlink(const std::string& value);
  std::string* _internal_mutable_firstbadlink();
  public:

  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .Hdfs.Internal.OpBlockChecksumResponseProto checksumResponse = 3;
  bool has_checksumresponse() const;
  private:
  bool _internal_has_checksumresponse() const;
  public:
  void clear_checksumresponse();
  const ::Hdfs::Internal::OpBlockChecksumResponseProto& checksumresponse() const;
  ::Hdfs::Internal::OpBlockChecksumResponseProto* release_checksumresponse();
  ::Hdfs::Internal::OpBlockChecksumResponseProto* mutable_checksumresponse();
  void set_allocated_checksumresponse(::Hdfs::Internal::OpBlockChecksumResponseProto* checksumresponse);
  private:
  const ::Hdfs::Internal::OpBlockChecksumResponseProto& _internal_checksumresponse() const;
  ::Hdfs::Internal::OpBlockChecksumResponseProto* _internal_mutable_checksumresponse();
  public:

  // optional .Hdfs.Internal.ReadOpChecksumInfoProto readOpChecksumInfo = 4;
  bool has_readopchecksuminfo() const;
  private:
  bool _internal_has_readopchecksuminfo() const;
  public:
  void clear_readopchecksuminfo();
  const ::Hdfs::Internal::ReadOpChecksumInfoProto& readopchecksuminfo() const;
  ::Hdfs::Internal::ReadOpChecksumInfoProto* release_readopchecksuminfo();
  ::Hdfs::Internal::ReadOpChecksumInfoProto* mutable_readopchecksuminfo();
  void set_allocated_readopchecksuminfo(::Hdfs::Internal::ReadOpChecksumInfoProto* readopchecksuminfo);
  private:
  const ::Hdfs::Internal::ReadOpChecksumInfoProto& _internal_readopchecksuminfo() const;
  ::Hdfs::Internal::ReadOpChecksumInfoProto* _internal_mutable_readopchecksuminfo();
  public:

  // required .Hdfs.Internal.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Hdfs::Internal::Status status() const;
  void set_status(::Hdfs::Internal::Status value);
  private:
  ::Hdfs::Internal::Status _internal_status() const;
  void _internal_set_status(::Hdfs::Internal::Status value);
  public:

  // optional uint32 shortCircuitAccessVersion = 6;
  bool has_shortcircuitaccessversion() const;
  private:
  bool _internal_has_shortcircuitaccessversion() const;
  public:
  void clear_shortcircuitaccessversion();
  ::PROTOBUF_NAMESPACE_ID::uint32 shortcircuitaccessversion() const;
  void set_shortcircuitaccessversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_shortcircuitaccessversion() const;
  void _internal_set_shortcircuitaccessversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BlockOpResponseProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firstbadlink_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::Hdfs::Internal::OpBlockChecksumResponseProto* checksumresponse_;
  ::Hdfs::Internal::ReadOpChecksumInfoProto* readopchecksuminfo_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shortcircuitaccessversion_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class ClientReadStatusProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ClientReadStatusProto) */ {
 public:
  ClientReadStatusProto();
  virtual ~ClientReadStatusProto();

  ClientReadStatusProto(const ClientReadStatusProto& from);
  ClientReadStatusProto(ClientReadStatusProto&& from) noexcept
    : ClientReadStatusProto() {
    *this = ::std::move(from);
  }

  inline ClientReadStatusProto& operator=(const ClientReadStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientReadStatusProto& operator=(ClientReadStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientReadStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientReadStatusProto* internal_default_instance() {
    return reinterpret_cast<const ClientReadStatusProto*>(
               &_ClientReadStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ClientReadStatusProto& a, ClientReadStatusProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientReadStatusProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientReadStatusProto* New() const final {
    return CreateMaybeMessage<ClientReadStatusProto>(nullptr);
  }

  ClientReadStatusProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientReadStatusProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientReadStatusProto& from);
  void MergeFrom(const ClientReadStatusProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientReadStatusProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ClientReadStatusProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .Hdfs.Internal.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Hdfs::Internal::Status status() const;
  void set_status(::Hdfs::Internal::Status value);
  private:
  ::Hdfs::Internal::Status _internal_status() const;
  void _internal_set_status(::Hdfs::Internal::Status value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ClientReadStatusProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class DNTransferAckProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DNTransferAckProto) */ {
 public:
  DNTransferAckProto();
  virtual ~DNTransferAckProto();

  DNTransferAckProto(const DNTransferAckProto& from);
  DNTransferAckProto(DNTransferAckProto&& from) noexcept
    : DNTransferAckProto() {
    *this = ::std::move(from);
  }

  inline DNTransferAckProto& operator=(const DNTransferAckProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DNTransferAckProto& operator=(DNTransferAckProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DNTransferAckProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DNTransferAckProto* internal_default_instance() {
    return reinterpret_cast<const DNTransferAckProto*>(
               &_DNTransferAckProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DNTransferAckProto& a, DNTransferAckProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DNTransferAckProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DNTransferAckProto* New() const final {
    return CreateMaybeMessage<DNTransferAckProto>(nullptr);
  }

  DNTransferAckProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DNTransferAckProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DNTransferAckProto& from);
  void MergeFrom(const DNTransferAckProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DNTransferAckProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DNTransferAckProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .Hdfs.Internal.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Hdfs::Internal::Status status() const;
  void set_status(::Hdfs::Internal::Status value);
  private:
  ::Hdfs::Internal::Status _internal_status() const;
  void _internal_set_status(::Hdfs::Internal::Status value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DNTransferAckProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// -------------------------------------------------------------------

class OpBlockChecksumResponseProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.OpBlockChecksumResponseProto) */ {
 public:
  OpBlockChecksumResponseProto();
  virtual ~OpBlockChecksumResponseProto();

  OpBlockChecksumResponseProto(const OpBlockChecksumResponseProto& from);
  OpBlockChecksumResponseProto(OpBlockChecksumResponseProto&& from) noexcept
    : OpBlockChecksumResponseProto() {
    *this = ::std::move(from);
  }

  inline OpBlockChecksumResponseProto& operator=(const OpBlockChecksumResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpBlockChecksumResponseProto& operator=(OpBlockChecksumResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpBlockChecksumResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpBlockChecksumResponseProto* internal_default_instance() {
    return reinterpret_cast<const OpBlockChecksumResponseProto*>(
               &_OpBlockChecksumResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OpBlockChecksumResponseProto& a, OpBlockChecksumResponseProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpBlockChecksumResponseProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpBlockChecksumResponseProto* New() const final {
    return CreateMaybeMessage<OpBlockChecksumResponseProto>(nullptr);
  }

  OpBlockChecksumResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpBlockChecksumResponseProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpBlockChecksumResponseProto& from);
  void MergeFrom(const OpBlockChecksumResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpBlockChecksumResponseProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.OpBlockChecksumResponseProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_datatransfer_2eproto);
    return ::descriptor_table_datatransfer_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMd5FieldNumber = 3,
    kCrcPerBlockFieldNumber = 2,
    kBytesPerCrcFieldNumber = 1,
    kCrcTypeFieldNumber = 4,
  };
  // required bytes md5 = 3;
  bool has_md5() const;
  private:
  bool _internal_has_md5() const;
  public:
  void clear_md5();
  const std::string& md5() const;
  void set_md5(const std::string& value);
  void set_md5(std::string&& value);
  void set_md5(const char* value);
  void set_md5(const void* value, size_t size);
  std::string* mutable_md5();
  std::string* release_md5();
  void set_allocated_md5(std::string* md5);
  private:
  const std::string& _internal_md5() const;
  void _internal_set_md5(const std::string& value);
  std::string* _internal_mutable_md5();
  public:

  // required uint64 crcPerBlock = 2;
  bool has_crcperblock() const;
  private:
  bool _internal_has_crcperblock() const;
  public:
  void clear_crcperblock();
  ::PROTOBUF_NAMESPACE_ID::uint64 crcperblock() const;
  void set_crcperblock(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_crcperblock() const;
  void _internal_set_crcperblock(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 bytesPerCrc = 1;
  bool has_bytespercrc() const;
  private:
  bool _internal_has_bytespercrc() const;
  public:
  void clear_bytespercrc();
  ::PROTOBUF_NAMESPACE_ID::uint32 bytespercrc() const;
  void set_bytespercrc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bytespercrc() const;
  void _internal_set_bytespercrc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .Hdfs.Internal.ChecksumTypeProto crcType = 4;
  bool has_crctype() const;
  private:
  bool _internal_has_crctype() const;
  public:
  void clear_crctype();
  ::Hdfs::Internal::ChecksumTypeProto crctype() const;
  void set_crctype(::Hdfs::Internal::ChecksumTypeProto value);
  private:
  ::Hdfs::Internal::ChecksumTypeProto _internal_crctype() const;
  void _internal_set_crctype(::Hdfs::Internal::ChecksumTypeProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.OpBlockChecksumResponseProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::uint64 crcperblock_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bytespercrc_;
  int crctype_;
  friend struct ::TableStruct_datatransfer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataTransferEncryptorMessageProto

// required .Hdfs.Internal.DataTransferEncryptorMessageProto.DataTransferEncryptorStatus status = 1;
inline bool DataTransferEncryptorMessageProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataTransferEncryptorMessageProto::has_status() const {
  return _internal_has_status();
}
inline void DataTransferEncryptorMessageProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus DataTransferEncryptorMessageProto::_internal_status() const {
  return static_cast< ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus >(status_);
}
inline ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus DataTransferEncryptorMessageProto::status() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataTransferEncryptorMessageProto.status)
  return _internal_status();
}
inline void DataTransferEncryptorMessageProto::_internal_set_status(::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus value) {
  assert(::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void DataTransferEncryptorMessageProto::set_status(::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataTransferEncryptorMessageProto.status)
}

// optional bytes payload = 2;
inline bool DataTransferEncryptorMessageProto::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataTransferEncryptorMessageProto::has_payload() const {
  return _internal_has_payload();
}
inline void DataTransferEncryptorMessageProto::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataTransferEncryptorMessageProto::payload() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
  return _internal_payload();
}
inline void DataTransferEncryptorMessageProto::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
}
inline std::string* DataTransferEncryptorMessageProto::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
  return _internal_mutable_payload();
}
inline const std::string& DataTransferEncryptorMessageProto::_internal_payload() const {
  return payload_.GetNoArena();
}
inline void DataTransferEncryptorMessageProto::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataTransferEncryptorMessageProto::set_payload(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
}
inline void DataTransferEncryptorMessageProto::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
}
inline void DataTransferEncryptorMessageProto::set_payload(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
}
inline std::string* DataTransferEncryptorMessageProto::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataTransferEncryptorMessageProto::release_payload() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataTransferEncryptorMessageProto::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataTransferEncryptorMessageProto.payload)
}

// optional string message = 3;
inline bool DataTransferEncryptorMessageProto::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataTransferEncryptorMessageProto::has_message() const {
  return _internal_has_message();
}
inline void DataTransferEncryptorMessageProto::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataTransferEncryptorMessageProto::message() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
  return _internal_message();
}
inline void DataTransferEncryptorMessageProto::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
}
inline std::string* DataTransferEncryptorMessageProto::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
  return _internal_mutable_message();
}
inline const std::string& DataTransferEncryptorMessageProto::_internal_message() const {
  return message_.GetNoArena();
}
inline void DataTransferEncryptorMessageProto::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataTransferEncryptorMessageProto::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
}
inline void DataTransferEncryptorMessageProto::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
}
inline void DataTransferEncryptorMessageProto::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
}
inline std::string* DataTransferEncryptorMessageProto::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataTransferEncryptorMessageProto::release_message() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataTransferEncryptorMessageProto::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataTransferEncryptorMessageProto.message)
}

// repeated .Hdfs.Internal.CipherOptionProto cipherOption = 4;
inline int DataTransferEncryptorMessageProto::_internal_cipheroption_size() const {
  return cipheroption_.size();
}
inline int DataTransferEncryptorMessageProto::cipheroption_size() const {
  return _internal_cipheroption_size();
}
inline ::Hdfs::Internal::CipherOptionProto* DataTransferEncryptorMessageProto::mutable_cipheroption(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataTransferEncryptorMessageProto.cipherOption)
  return cipheroption_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::CipherOptionProto >*
DataTransferEncryptorMessageProto::mutable_cipheroption() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.DataTransferEncryptorMessageProto.cipherOption)
  return &cipheroption_;
}
inline const ::Hdfs::Internal::CipherOptionProto& DataTransferEncryptorMessageProto::_internal_cipheroption(int index) const {
  return cipheroption_.Get(index);
}
inline const ::Hdfs::Internal::CipherOptionProto& DataTransferEncryptorMessageProto::cipheroption(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataTransferEncryptorMessageProto.cipherOption)
  return _internal_cipheroption(index);
}
inline ::Hdfs::Internal::CipherOptionProto* DataTransferEncryptorMessageProto::_internal_add_cipheroption() {
  return cipheroption_.Add();
}
inline ::Hdfs::Internal::CipherOptionProto* DataTransferEncryptorMessageProto::add_cipheroption() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.DataTransferEncryptorMessageProto.cipherOption)
  return _internal_add_cipheroption();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::CipherOptionProto >&
DataTransferEncryptorMessageProto::cipheroption() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.DataTransferEncryptorMessageProto.cipherOption)
  return cipheroption_;
}

// -------------------------------------------------------------------

// BaseHeaderProto

// required .Hdfs.Internal.ExtendedBlockProto block = 1;
inline bool BaseHeaderProto::_internal_has_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || block_ != nullptr);
  return value;
}
inline bool BaseHeaderProto::has_block() const {
  return _internal_has_block();
}
inline const ::Hdfs::Internal::ExtendedBlockProto& BaseHeaderProto::_internal_block() const {
  const ::Hdfs::Internal::ExtendedBlockProto* p = block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ExtendedBlockProto*>(
      &::Hdfs::Internal::_ExtendedBlockProto_default_instance_);
}
inline const ::Hdfs::Internal::ExtendedBlockProto& BaseHeaderProto::block() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BaseHeaderProto.block)
  return _internal_block();
}
inline ::Hdfs::Internal::ExtendedBlockProto* BaseHeaderProto::release_block() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BaseHeaderProto.block)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ExtendedBlockProto* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ExtendedBlockProto* BaseHeaderProto::_internal_mutable_block() {
  _has_bits_[0] |= 0x00000001u;
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ExtendedBlockProto>(GetArenaNoVirtual());
    block_ = p;
  }
  return block_;
}
inline ::Hdfs::Internal::ExtendedBlockProto* BaseHeaderProto::mutable_block() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BaseHeaderProto.block)
  return _internal_mutable_block();
}
inline void BaseHeaderProto::set_allocated_block(::Hdfs::Internal::ExtendedBlockProto* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BaseHeaderProto.block)
}

// optional .Hdfs.Internal.TokenProto token = 2;
inline bool BaseHeaderProto::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || token_ != nullptr);
  return value;
}
inline bool BaseHeaderProto::has_token() const {
  return _internal_has_token();
}
inline const ::Hdfs::Internal::TokenProto& BaseHeaderProto::_internal_token() const {
  const ::Hdfs::Internal::TokenProto* p = token_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::TokenProto*>(
      &::Hdfs::Internal::_TokenProto_default_instance_);
}
inline const ::Hdfs::Internal::TokenProto& BaseHeaderProto::token() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BaseHeaderProto.token)
  return _internal_token();
}
inline ::Hdfs::Internal::TokenProto* BaseHeaderProto::release_token() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BaseHeaderProto.token)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::TokenProto* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::TokenProto* BaseHeaderProto::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000002u;
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::TokenProto>(GetArenaNoVirtual());
    token_ = p;
  }
  return token_;
}
inline ::Hdfs::Internal::TokenProto* BaseHeaderProto::mutable_token() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BaseHeaderProto.token)
  return _internal_mutable_token();
}
inline void BaseHeaderProto::set_allocated_token(::Hdfs::Internal::TokenProto* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BaseHeaderProto.token)
}

// -------------------------------------------------------------------

// ClientOperationHeaderProto

// required .Hdfs.Internal.BaseHeaderProto baseHeader = 1;
inline bool ClientOperationHeaderProto::_internal_has_baseheader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || baseheader_ != nullptr);
  return value;
}
inline bool ClientOperationHeaderProto::has_baseheader() const {
  return _internal_has_baseheader();
}
inline void ClientOperationHeaderProto::clear_baseheader() {
  if (baseheader_ != nullptr) baseheader_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::BaseHeaderProto& ClientOperationHeaderProto::_internal_baseheader() const {
  const ::Hdfs::Internal::BaseHeaderProto* p = baseheader_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BaseHeaderProto*>(
      &::Hdfs::Internal::_BaseHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::BaseHeaderProto& ClientOperationHeaderProto::baseheader() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ClientOperationHeaderProto.baseHeader)
  return _internal_baseheader();
}
inline ::Hdfs::Internal::BaseHeaderProto* ClientOperationHeaderProto::release_baseheader() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ClientOperationHeaderProto.baseHeader)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::BaseHeaderProto* temp = baseheader_;
  baseheader_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BaseHeaderProto* ClientOperationHeaderProto::_internal_mutable_baseheader() {
  _has_bits_[0] |= 0x00000002u;
  if (baseheader_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(GetArenaNoVirtual());
    baseheader_ = p;
  }
  return baseheader_;
}
inline ::Hdfs::Internal::BaseHeaderProto* ClientOperationHeaderProto::mutable_baseheader() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ClientOperationHeaderProto.baseHeader)
  return _internal_mutable_baseheader();
}
inline void ClientOperationHeaderProto::set_allocated_baseheader(::Hdfs::Internal::BaseHeaderProto* baseheader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete baseheader_;
  }
  if (baseheader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      baseheader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseheader, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  baseheader_ = baseheader;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ClientOperationHeaderProto.baseHeader)
}

// required string clientName = 2;
inline bool ClientOperationHeaderProto::_internal_has_clientname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientOperationHeaderProto::has_clientname() const {
  return _internal_has_clientname();
}
inline void ClientOperationHeaderProto::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientOperationHeaderProto::clientname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ClientOperationHeaderProto.clientName)
  return _internal_clientname();
}
inline void ClientOperationHeaderProto::set_clientname(const std::string& value) {
  _internal_set_clientname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ClientOperationHeaderProto.clientName)
}
inline std::string* ClientOperationHeaderProto::mutable_clientname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ClientOperationHeaderProto.clientName)
  return _internal_mutable_clientname();
}
inline const std::string& ClientOperationHeaderProto::_internal_clientname() const {
  return clientname_.GetNoArena();
}
inline void ClientOperationHeaderProto::_internal_set_clientname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ClientOperationHeaderProto::set_clientname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  clientname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.ClientOperationHeaderProto.clientName)
}
inline void ClientOperationHeaderProto::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.ClientOperationHeaderProto.clientName)
}
inline void ClientOperationHeaderProto::set_clientname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.ClientOperationHeaderProto.clientName)
}
inline std::string* ClientOperationHeaderProto::_internal_mutable_clientname() {
  _has_bits_[0] |= 0x00000001u;
  return clientname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClientOperationHeaderProto::release_clientname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ClientOperationHeaderProto.clientName)
  if (!_internal_has_clientname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clientname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClientOperationHeaderProto::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clientname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ClientOperationHeaderProto.clientName)
}

// -------------------------------------------------------------------

// CachingStrategyProto

// optional bool dropBehind = 1;
inline bool CachingStrategyProto::_internal_has_dropbehind() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CachingStrategyProto::has_dropbehind() const {
  return _internal_has_dropbehind();
}
inline void CachingStrategyProto::clear_dropbehind() {
  dropbehind_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CachingStrategyProto::_internal_dropbehind() const {
  return dropbehind_;
}
inline bool CachingStrategyProto::dropbehind() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CachingStrategyProto.dropBehind)
  return _internal_dropbehind();
}
inline void CachingStrategyProto::_internal_set_dropbehind(bool value) {
  _has_bits_[0] |= 0x00000002u;
  dropbehind_ = value;
}
inline void CachingStrategyProto::set_dropbehind(bool value) {
  _internal_set_dropbehind(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CachingStrategyProto.dropBehind)
}

// optional int64 readahead = 2;
inline bool CachingStrategyProto::_internal_has_readahead() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CachingStrategyProto::has_readahead() const {
  return _internal_has_readahead();
}
inline void CachingStrategyProto::clear_readahead() {
  readahead_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CachingStrategyProto::_internal_readahead() const {
  return readahead_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CachingStrategyProto::readahead() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CachingStrategyProto.readahead)
  return _internal_readahead();
}
inline void CachingStrategyProto::_internal_set_readahead(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  readahead_ = value;
}
inline void CachingStrategyProto::set_readahead(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_readahead(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CachingStrategyProto.readahead)
}

// -------------------------------------------------------------------

// OpReadBlockProto

// required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
inline bool OpReadBlockProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpReadBlockProto::has_header() const {
  return _internal_has_header();
}
inline void OpReadBlockProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpReadBlockProto::_internal_header() const {
  const ::Hdfs::Internal::ClientOperationHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ClientOperationHeaderProto*>(
      &::Hdfs::Internal::_ClientOperationHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpReadBlockProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReadBlockProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpReadBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpReadBlockProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ClientOperationHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpReadBlockProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ClientOperationHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpReadBlockProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpReadBlockProto.header)
  return _internal_mutable_header();
}
inline void OpReadBlockProto::set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpReadBlockProto.header)
}

// required uint64 offset = 2;
inline bool OpReadBlockProto::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OpReadBlockProto::has_offset() const {
  return _internal_has_offset();
}
inline void OpReadBlockProto::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpReadBlockProto::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpReadBlockProto::offset() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReadBlockProto.offset)
  return _internal_offset();
}
inline void OpReadBlockProto::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void OpReadBlockProto::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpReadBlockProto.offset)
}

// required uint64 len = 3;
inline bool OpReadBlockProto::_internal_has_len() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OpReadBlockProto::has_len() const {
  return _internal_has_len();
}
inline void OpReadBlockProto::clear_len() {
  len_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpReadBlockProto::_internal_len() const {
  return len_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpReadBlockProto::len() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReadBlockProto.len)
  return _internal_len();
}
inline void OpReadBlockProto::_internal_set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  len_ = value;
}
inline void OpReadBlockProto::set_len(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpReadBlockProto.len)
}

// optional bool sendChecksums = 4 [default = true];
inline bool OpReadBlockProto::_internal_has_sendchecksums() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OpReadBlockProto::has_sendchecksums() const {
  return _internal_has_sendchecksums();
}
inline void OpReadBlockProto::clear_sendchecksums() {
  sendchecksums_ = true;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool OpReadBlockProto::_internal_sendchecksums() const {
  return sendchecksums_;
}
inline bool OpReadBlockProto::sendchecksums() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReadBlockProto.sendChecksums)
  return _internal_sendchecksums();
}
inline void OpReadBlockProto::_internal_set_sendchecksums(bool value) {
  _has_bits_[0] |= 0x00000010u;
  sendchecksums_ = value;
}
inline void OpReadBlockProto::set_sendchecksums(bool value) {
  _internal_set_sendchecksums(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpReadBlockProto.sendChecksums)
}

// optional .Hdfs.Internal.CachingStrategyProto cachingStrategy = 5;
inline bool OpReadBlockProto::_internal_has_cachingstrategy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cachingstrategy_ != nullptr);
  return value;
}
inline bool OpReadBlockProto::has_cachingstrategy() const {
  return _internal_has_cachingstrategy();
}
inline void OpReadBlockProto::clear_cachingstrategy() {
  if (cachingstrategy_ != nullptr) cachingstrategy_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::CachingStrategyProto& OpReadBlockProto::_internal_cachingstrategy() const {
  const ::Hdfs::Internal::CachingStrategyProto* p = cachingstrategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::CachingStrategyProto*>(
      &::Hdfs::Internal::_CachingStrategyProto_default_instance_);
}
inline const ::Hdfs::Internal::CachingStrategyProto& OpReadBlockProto::cachingstrategy() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReadBlockProto.cachingStrategy)
  return _internal_cachingstrategy();
}
inline ::Hdfs::Internal::CachingStrategyProto* OpReadBlockProto::release_cachingstrategy() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpReadBlockProto.cachingStrategy)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::CachingStrategyProto* temp = cachingstrategy_;
  cachingstrategy_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::CachingStrategyProto* OpReadBlockProto::_internal_mutable_cachingstrategy() {
  _has_bits_[0] |= 0x00000002u;
  if (cachingstrategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::CachingStrategyProto>(GetArenaNoVirtual());
    cachingstrategy_ = p;
  }
  return cachingstrategy_;
}
inline ::Hdfs::Internal::CachingStrategyProto* OpReadBlockProto::mutable_cachingstrategy() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpReadBlockProto.cachingStrategy)
  return _internal_mutable_cachingstrategy();
}
inline void OpReadBlockProto::set_allocated_cachingstrategy(::Hdfs::Internal::CachingStrategyProto* cachingstrategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cachingstrategy_;
  }
  if (cachingstrategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cachingstrategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cachingstrategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cachingstrategy_ = cachingstrategy;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpReadBlockProto.cachingStrategy)
}

// -------------------------------------------------------------------

// ChecksumProto

// required .Hdfs.Internal.ChecksumTypeProto type = 1;
inline bool ChecksumProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChecksumProto::has_type() const {
  return _internal_has_type();
}
inline void ChecksumProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::Hdfs::Internal::ChecksumTypeProto ChecksumProto::_internal_type() const {
  return static_cast< ::Hdfs::Internal::ChecksumTypeProto >(type_);
}
inline ::Hdfs::Internal::ChecksumTypeProto ChecksumProto::type() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ChecksumProto.type)
  return _internal_type();
}
inline void ChecksumProto::_internal_set_type(::Hdfs::Internal::ChecksumTypeProto value) {
  assert(::Hdfs::Internal::ChecksumTypeProto_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ChecksumProto::set_type(::Hdfs::Internal::ChecksumTypeProto value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ChecksumProto.type)
}

// required uint32 bytesPerChecksum = 2;
inline bool ChecksumProto::_internal_has_bytesperchecksum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChecksumProto::has_bytesperchecksum() const {
  return _internal_has_bytesperchecksum();
}
inline void ChecksumProto::clear_bytesperchecksum() {
  bytesperchecksum_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChecksumProto::_internal_bytesperchecksum() const {
  return bytesperchecksum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChecksumProto::bytesperchecksum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ChecksumProto.bytesPerChecksum)
  return _internal_bytesperchecksum();
}
inline void ChecksumProto::_internal_set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  bytesperchecksum_ = value;
}
inline void ChecksumProto::set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bytesperchecksum(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ChecksumProto.bytesPerChecksum)
}

// -------------------------------------------------------------------

// OpWriteBlockProto

// required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
inline bool OpWriteBlockProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpWriteBlockProto::has_header() const {
  return _internal_has_header();
}
inline void OpWriteBlockProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpWriteBlockProto::_internal_header() const {
  const ::Hdfs::Internal::ClientOperationHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ClientOperationHeaderProto*>(
      &::Hdfs::Internal::_ClientOperationHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpWriteBlockProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpWriteBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpWriteBlockProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ClientOperationHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpWriteBlockProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ClientOperationHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpWriteBlockProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpWriteBlockProto.header)
  return _internal_mutable_header();
}
inline void OpWriteBlockProto::set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpWriteBlockProto.header)
}

// repeated .Hdfs.Internal.DatanodeInfoProto targets = 2;
inline int OpWriteBlockProto::_internal_targets_size() const {
  return targets_.size();
}
inline int OpWriteBlockProto::targets_size() const {
  return _internal_targets_size();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpWriteBlockProto.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
OpWriteBlockProto::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.OpWriteBlockProto.targets)
  return &targets_;
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpWriteBlockProto::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpWriteBlockProto::targets(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.targets)
  return _internal_targets(index);
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::_internal_add_targets() {
  return targets_.Add();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::add_targets() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.OpWriteBlockProto.targets)
  return _internal_add_targets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
OpWriteBlockProto::targets() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.OpWriteBlockProto.targets)
  return targets_;
}

// optional .Hdfs.Internal.DatanodeInfoProto source = 3;
inline bool OpWriteBlockProto::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || source_ != nullptr);
  return value;
}
inline bool OpWriteBlockProto::has_source() const {
  return _internal_has_source();
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpWriteBlockProto::_internal_source() const {
  const ::Hdfs::Internal::DatanodeInfoProto* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::DatanodeInfoProto*>(
      &::Hdfs::Internal::_DatanodeInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpWriteBlockProto::source() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.source)
  return _internal_source();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::release_source() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpWriteBlockProto.source)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::DatanodeInfoProto* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::DatanodeInfoProto>(GetArenaNoVirtual());
    source_ = p;
  }
  return source_;
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpWriteBlockProto::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpWriteBlockProto.source)
  return _internal_mutable_source();
}
inline void OpWriteBlockProto::set_allocated_source(::Hdfs::Internal::DatanodeInfoProto* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpWriteBlockProto.source)
}

// required .Hdfs.Internal.OpWriteBlockProto.BlockConstructionStage stage = 4;
inline bool OpWriteBlockProto::_internal_has_stage() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OpWriteBlockProto::has_stage() const {
  return _internal_has_stage();
}
inline void OpWriteBlockProto::clear_stage() {
  stage_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage OpWriteBlockProto::_internal_stage() const {
  return static_cast< ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage >(stage_);
}
inline ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage OpWriteBlockProto::stage() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.stage)
  return _internal_stage();
}
inline void OpWriteBlockProto::_internal_set_stage(::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage value) {
  assert(::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  stage_ = value;
}
inline void OpWriteBlockProto::set_stage(::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpWriteBlockProto.stage)
}

// required uint32 pipelineSize = 5;
inline bool OpWriteBlockProto::_internal_has_pipelinesize() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OpWriteBlockProto::has_pipelinesize() const {
  return _internal_has_pipelinesize();
}
inline void OpWriteBlockProto::clear_pipelinesize() {
  pipelinesize_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpWriteBlockProto::_internal_pipelinesize() const {
  return pipelinesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpWriteBlockProto::pipelinesize() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.pipelineSize)
  return _internal_pipelinesize();
}
inline void OpWriteBlockProto::_internal_set_pipelinesize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  pipelinesize_ = value;
}
inline void OpWriteBlockProto::set_pipelinesize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pipelinesize(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpWriteBlockProto.pipelineSize)
}

// required uint64 minBytesRcvd = 6;
inline bool OpWriteBlockProto::_internal_has_minbytesrcvd() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OpWriteBlockProto::has_minbytesrcvd() const {
  return _internal_has_minbytesrcvd();
}
inline void OpWriteBlockProto::clear_minbytesrcvd() {
  minbytesrcvd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::_internal_minbytesrcvd() const {
  return minbytesrcvd_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::minbytesrcvd() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.minBytesRcvd)
  return _internal_minbytesrcvd();
}
inline void OpWriteBlockProto::_internal_set_minbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  minbytesrcvd_ = value;
}
inline void OpWriteBlockProto::set_minbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_minbytesrcvd(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpWriteBlockProto.minBytesRcvd)
}

// required uint64 maxBytesRcvd = 7;
inline bool OpWriteBlockProto::_internal_has_maxbytesrcvd() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OpWriteBlockProto::has_maxbytesrcvd() const {
  return _internal_has_maxbytesrcvd();
}
inline void OpWriteBlockProto::clear_maxbytesrcvd() {
  maxbytesrcvd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::_internal_maxbytesrcvd() const {
  return maxbytesrcvd_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::maxbytesrcvd() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.maxBytesRcvd)
  return _internal_maxbytesrcvd();
}
inline void OpWriteBlockProto::_internal_set_maxbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  maxbytesrcvd_ = value;
}
inline void OpWriteBlockProto::set_maxbytesrcvd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_maxbytesrcvd(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpWriteBlockProto.maxBytesRcvd)
}

// required uint64 latestGenerationStamp = 8;
inline bool OpWriteBlockProto::_internal_has_latestgenerationstamp() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OpWriteBlockProto::has_latestgenerationstamp() const {
  return _internal_has_latestgenerationstamp();
}
inline void OpWriteBlockProto::clear_latestgenerationstamp() {
  latestgenerationstamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::_internal_latestgenerationstamp() const {
  return latestgenerationstamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpWriteBlockProto::latestgenerationstamp() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.latestGenerationStamp)
  return _internal_latestgenerationstamp();
}
inline void OpWriteBlockProto::_internal_set_latestgenerationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  latestgenerationstamp_ = value;
}
inline void OpWriteBlockProto::set_latestgenerationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_latestgenerationstamp(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpWriteBlockProto.latestGenerationStamp)
}

// required .Hdfs.Internal.ChecksumProto requestedChecksum = 9;
inline bool OpWriteBlockProto::_internal_has_requestedchecksum() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || requestedchecksum_ != nullptr);
  return value;
}
inline bool OpWriteBlockProto::has_requestedchecksum() const {
  return _internal_has_requestedchecksum();
}
inline void OpWriteBlockProto::clear_requestedchecksum() {
  if (requestedchecksum_ != nullptr) requestedchecksum_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Hdfs::Internal::ChecksumProto& OpWriteBlockProto::_internal_requestedchecksum() const {
  const ::Hdfs::Internal::ChecksumProto* p = requestedchecksum_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ChecksumProto*>(
      &::Hdfs::Internal::_ChecksumProto_default_instance_);
}
inline const ::Hdfs::Internal::ChecksumProto& OpWriteBlockProto::requestedchecksum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.requestedChecksum)
  return _internal_requestedchecksum();
}
inline ::Hdfs::Internal::ChecksumProto* OpWriteBlockProto::release_requestedchecksum() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpWriteBlockProto.requestedChecksum)
  _has_bits_[0] &= ~0x00000004u;
  ::Hdfs::Internal::ChecksumProto* temp = requestedchecksum_;
  requestedchecksum_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ChecksumProto* OpWriteBlockProto::_internal_mutable_requestedchecksum() {
  _has_bits_[0] |= 0x00000004u;
  if (requestedchecksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ChecksumProto>(GetArenaNoVirtual());
    requestedchecksum_ = p;
  }
  return requestedchecksum_;
}
inline ::Hdfs::Internal::ChecksumProto* OpWriteBlockProto::mutable_requestedchecksum() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpWriteBlockProto.requestedChecksum)
  return _internal_mutable_requestedchecksum();
}
inline void OpWriteBlockProto::set_allocated_requestedchecksum(::Hdfs::Internal::ChecksumProto* requestedchecksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete requestedchecksum_;
  }
  if (requestedchecksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      requestedchecksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestedchecksum, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  requestedchecksum_ = requestedchecksum;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpWriteBlockProto.requestedChecksum)
}

// optional .Hdfs.Internal.CachingStrategyProto cachingStrategy = 10;
inline bool OpWriteBlockProto::_internal_has_cachingstrategy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || cachingstrategy_ != nullptr);
  return value;
}
inline bool OpWriteBlockProto::has_cachingstrategy() const {
  return _internal_has_cachingstrategy();
}
inline void OpWriteBlockProto::clear_cachingstrategy() {
  if (cachingstrategy_ != nullptr) cachingstrategy_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Hdfs::Internal::CachingStrategyProto& OpWriteBlockProto::_internal_cachingstrategy() const {
  const ::Hdfs::Internal::CachingStrategyProto* p = cachingstrategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::CachingStrategyProto*>(
      &::Hdfs::Internal::_CachingStrategyProto_default_instance_);
}
inline const ::Hdfs::Internal::CachingStrategyProto& OpWriteBlockProto::cachingstrategy() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpWriteBlockProto.cachingStrategy)
  return _internal_cachingstrategy();
}
inline ::Hdfs::Internal::CachingStrategyProto* OpWriteBlockProto::release_cachingstrategy() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpWriteBlockProto.cachingStrategy)
  _has_bits_[0] &= ~0x00000008u;
  ::Hdfs::Internal::CachingStrategyProto* temp = cachingstrategy_;
  cachingstrategy_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::CachingStrategyProto* OpWriteBlockProto::_internal_mutable_cachingstrategy() {
  _has_bits_[0] |= 0x00000008u;
  if (cachingstrategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::CachingStrategyProto>(GetArenaNoVirtual());
    cachingstrategy_ = p;
  }
  return cachingstrategy_;
}
inline ::Hdfs::Internal::CachingStrategyProto* OpWriteBlockProto::mutable_cachingstrategy() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpWriteBlockProto.cachingStrategy)
  return _internal_mutable_cachingstrategy();
}
inline void OpWriteBlockProto::set_allocated_cachingstrategy(::Hdfs::Internal::CachingStrategyProto* cachingstrategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cachingstrategy_;
  }
  if (cachingstrategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cachingstrategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cachingstrategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cachingstrategy_ = cachingstrategy;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpWriteBlockProto.cachingStrategy)
}

// -------------------------------------------------------------------

// OpTransferBlockProto

// required .Hdfs.Internal.ClientOperationHeaderProto header = 1;
inline bool OpTransferBlockProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpTransferBlockProto::has_header() const {
  return _internal_has_header();
}
inline void OpTransferBlockProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpTransferBlockProto::_internal_header() const {
  const ::Hdfs::Internal::ClientOperationHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ClientOperationHeaderProto*>(
      &::Hdfs::Internal::_ClientOperationHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::ClientOperationHeaderProto& OpTransferBlockProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpTransferBlockProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpTransferBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpTransferBlockProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ClientOperationHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpTransferBlockProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ClientOperationHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::ClientOperationHeaderProto* OpTransferBlockProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpTransferBlockProto.header)
  return _internal_mutable_header();
}
inline void OpTransferBlockProto::set_allocated_header(::Hdfs::Internal::ClientOperationHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpTransferBlockProto.header)
}

// repeated .Hdfs.Internal.DatanodeInfoProto targets = 2;
inline int OpTransferBlockProto::_internal_targets_size() const {
  return targets_.size();
}
inline int OpTransferBlockProto::targets_size() const {
  return _internal_targets_size();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpTransferBlockProto::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpTransferBlockProto.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
OpTransferBlockProto::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.OpTransferBlockProto.targets)
  return &targets_;
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpTransferBlockProto::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpTransferBlockProto::targets(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpTransferBlockProto.targets)
  return _internal_targets(index);
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpTransferBlockProto::_internal_add_targets() {
  return targets_.Add();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpTransferBlockProto::add_targets() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.OpTransferBlockProto.targets)
  return _internal_add_targets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
OpTransferBlockProto::targets() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.OpTransferBlockProto.targets)
  return targets_;
}

// -------------------------------------------------------------------

// OpReplaceBlockProto

// required .Hdfs.Internal.BaseHeaderProto header = 1;
inline bool OpReplaceBlockProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpReplaceBlockProto::has_header() const {
  return _internal_has_header();
}
inline void OpReplaceBlockProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpReplaceBlockProto::_internal_header() const {
  const ::Hdfs::Internal::BaseHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BaseHeaderProto*>(
      &::Hdfs::Internal::_BaseHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpReplaceBlockProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReplaceBlockProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::BaseHeaderProto* OpReplaceBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpReplaceBlockProto.header)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::BaseHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpReplaceBlockProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpReplaceBlockProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpReplaceBlockProto.header)
  return _internal_mutable_header();
}
inline void OpReplaceBlockProto::set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpReplaceBlockProto.header)
}

// required string delHint = 2;
inline bool OpReplaceBlockProto::_internal_has_delhint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpReplaceBlockProto::has_delhint() const {
  return _internal_has_delhint();
}
inline void OpReplaceBlockProto::clear_delhint() {
  delhint_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpReplaceBlockProto::delhint() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReplaceBlockProto.delHint)
  return _internal_delhint();
}
inline void OpReplaceBlockProto::set_delhint(const std::string& value) {
  _internal_set_delhint(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpReplaceBlockProto.delHint)
}
inline std::string* OpReplaceBlockProto::mutable_delhint() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpReplaceBlockProto.delHint)
  return _internal_mutable_delhint();
}
inline const std::string& OpReplaceBlockProto::_internal_delhint() const {
  return delhint_.GetNoArena();
}
inline void OpReplaceBlockProto::_internal_set_delhint(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  delhint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OpReplaceBlockProto::set_delhint(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  delhint_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.OpReplaceBlockProto.delHint)
}
inline void OpReplaceBlockProto::set_delhint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  delhint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.OpReplaceBlockProto.delHint)
}
inline void OpReplaceBlockProto::set_delhint(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  delhint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.OpReplaceBlockProto.delHint)
}
inline std::string* OpReplaceBlockProto::_internal_mutable_delhint() {
  _has_bits_[0] |= 0x00000001u;
  return delhint_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OpReplaceBlockProto::release_delhint() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpReplaceBlockProto.delHint)
  if (!_internal_has_delhint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return delhint_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OpReplaceBlockProto::set_allocated_delhint(std::string* delhint) {
  if (delhint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  delhint_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), delhint);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpReplaceBlockProto.delHint)
}

// required .Hdfs.Internal.DatanodeInfoProto source = 3;
inline bool OpReplaceBlockProto::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || source_ != nullptr);
  return value;
}
inline bool OpReplaceBlockProto::has_source() const {
  return _internal_has_source();
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpReplaceBlockProto::_internal_source() const {
  const ::Hdfs::Internal::DatanodeInfoProto* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::DatanodeInfoProto*>(
      &::Hdfs::Internal::_DatanodeInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& OpReplaceBlockProto::source() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpReplaceBlockProto.source)
  return _internal_source();
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpReplaceBlockProto::release_source() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpReplaceBlockProto.source)
  _has_bits_[0] &= ~0x00000004u;
  ::Hdfs::Internal::DatanodeInfoProto* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpReplaceBlockProto::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000004u;
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::DatanodeInfoProto>(GetArenaNoVirtual());
    source_ = p;
  }
  return source_;
}
inline ::Hdfs::Internal::DatanodeInfoProto* OpReplaceBlockProto::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpReplaceBlockProto.source)
  return _internal_mutable_source();
}
inline void OpReplaceBlockProto::set_allocated_source(::Hdfs::Internal::DatanodeInfoProto* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpReplaceBlockProto.source)
}

// -------------------------------------------------------------------

// OpCopyBlockProto

// required .Hdfs.Internal.BaseHeaderProto header = 1;
inline bool OpCopyBlockProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpCopyBlockProto::has_header() const {
  return _internal_has_header();
}
inline void OpCopyBlockProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpCopyBlockProto::_internal_header() const {
  const ::Hdfs::Internal::BaseHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BaseHeaderProto*>(
      &::Hdfs::Internal::_BaseHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpCopyBlockProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpCopyBlockProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::BaseHeaderProto* OpCopyBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpCopyBlockProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::BaseHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpCopyBlockProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpCopyBlockProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpCopyBlockProto.header)
  return _internal_mutable_header();
}
inline void OpCopyBlockProto::set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpCopyBlockProto.header)
}

// -------------------------------------------------------------------

// OpBlockChecksumProto

// required .Hdfs.Internal.BaseHeaderProto header = 1;
inline bool OpBlockChecksumProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpBlockChecksumProto::has_header() const {
  return _internal_has_header();
}
inline void OpBlockChecksumProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpBlockChecksumProto::_internal_header() const {
  const ::Hdfs::Internal::BaseHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BaseHeaderProto*>(
      &::Hdfs::Internal::_BaseHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpBlockChecksumProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpBlockChecksumProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::BaseHeaderProto* OpBlockChecksumProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpBlockChecksumProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::BaseHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpBlockChecksumProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpBlockChecksumProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpBlockChecksumProto.header)
  return _internal_mutable_header();
}
inline void OpBlockChecksumProto::set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpBlockChecksumProto.header)
}

// -------------------------------------------------------------------

// OpRequestShortCircuitAccessProto

// required .Hdfs.Internal.BaseHeaderProto header = 1;
inline bool OpRequestShortCircuitAccessProto::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool OpRequestShortCircuitAccessProto::has_header() const {
  return _internal_has_header();
}
inline void OpRequestShortCircuitAccessProto::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpRequestShortCircuitAccessProto::_internal_header() const {
  const ::Hdfs::Internal::BaseHeaderProto* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BaseHeaderProto*>(
      &::Hdfs::Internal::_BaseHeaderProto_default_instance_);
}
inline const ::Hdfs::Internal::BaseHeaderProto& OpRequestShortCircuitAccessProto::header() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpRequestShortCircuitAccessProto.header)
  return _internal_header();
}
inline ::Hdfs::Internal::BaseHeaderProto* OpRequestShortCircuitAccessProto::release_header() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpRequestShortCircuitAccessProto.header)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::BaseHeaderProto* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpRequestShortCircuitAccessProto::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BaseHeaderProto>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::Hdfs::Internal::BaseHeaderProto* OpRequestShortCircuitAccessProto::mutable_header() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpRequestShortCircuitAccessProto.header)
  return _internal_mutable_header();
}
inline void OpRequestShortCircuitAccessProto::set_allocated_header(::Hdfs::Internal::BaseHeaderProto* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpRequestShortCircuitAccessProto.header)
}

// required uint32 maxVersion = 2;
inline bool OpRequestShortCircuitAccessProto::_internal_has_maxversion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpRequestShortCircuitAccessProto::has_maxversion() const {
  return _internal_has_maxversion();
}
inline void OpRequestShortCircuitAccessProto::clear_maxversion() {
  maxversion_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpRequestShortCircuitAccessProto::_internal_maxversion() const {
  return maxversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpRequestShortCircuitAccessProto::maxversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpRequestShortCircuitAccessProto.maxVersion)
  return _internal_maxversion();
}
inline void OpRequestShortCircuitAccessProto::_internal_set_maxversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  maxversion_ = value;
}
inline void OpRequestShortCircuitAccessProto::set_maxversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_maxversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpRequestShortCircuitAccessProto.maxVersion)
}

// -------------------------------------------------------------------

// PacketHeaderProto

// required sfixed64 offsetInBlock = 1;
inline bool PacketHeaderProto::_internal_has_offsetinblock() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PacketHeaderProto::has_offsetinblock() const {
  return _internal_has_offsetinblock();
}
inline void PacketHeaderProto::clear_offsetinblock() {
  offsetinblock_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PacketHeaderProto::_internal_offsetinblock() const {
  return offsetinblock_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PacketHeaderProto::offsetinblock() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PacketHeaderProto.offsetInBlock)
  return _internal_offsetinblock();
}
inline void PacketHeaderProto::_internal_set_offsetinblock(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  offsetinblock_ = value;
}
inline void PacketHeaderProto::set_offsetinblock(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offsetinblock(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PacketHeaderProto.offsetInBlock)
}

// required sfixed64 seqno = 2;
inline bool PacketHeaderProto::_internal_has_seqno() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PacketHeaderProto::has_seqno() const {
  return _internal_has_seqno();
}
inline void PacketHeaderProto::clear_seqno() {
  seqno_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PacketHeaderProto::_internal_seqno() const {
  return seqno_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PacketHeaderProto::seqno() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PacketHeaderProto.seqno)
  return _internal_seqno();
}
inline void PacketHeaderProto::_internal_set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  seqno_ = value;
}
inline void PacketHeaderProto::set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PacketHeaderProto.seqno)
}

// required bool lastPacketInBlock = 3;
inline bool PacketHeaderProto::_internal_has_lastpacketinblock() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PacketHeaderProto::has_lastpacketinblock() const {
  return _internal_has_lastpacketinblock();
}
inline void PacketHeaderProto::clear_lastpacketinblock() {
  lastpacketinblock_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PacketHeaderProto::_internal_lastpacketinblock() const {
  return lastpacketinblock_;
}
inline bool PacketHeaderProto::lastpacketinblock() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PacketHeaderProto.lastPacketInBlock)
  return _internal_lastpacketinblock();
}
inline void PacketHeaderProto::_internal_set_lastpacketinblock(bool value) {
  _has_bits_[0] |= 0x00000008u;
  lastpacketinblock_ = value;
}
inline void PacketHeaderProto::set_lastpacketinblock(bool value) {
  _internal_set_lastpacketinblock(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PacketHeaderProto.lastPacketInBlock)
}

// required sfixed32 dataLen = 4;
inline bool PacketHeaderProto::_internal_has_datalen() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PacketHeaderProto::has_datalen() const {
  return _internal_has_datalen();
}
inline void PacketHeaderProto::clear_datalen() {
  datalen_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PacketHeaderProto::_internal_datalen() const {
  return datalen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PacketHeaderProto::datalen() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PacketHeaderProto.dataLen)
  return _internal_datalen();
}
inline void PacketHeaderProto::_internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  datalen_ = value;
}
inline void PacketHeaderProto::set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datalen(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PacketHeaderProto.dataLen)
}

// optional bool syncBlock = 5 [default = false];
inline bool PacketHeaderProto::_internal_has_syncblock() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PacketHeaderProto::has_syncblock() const {
  return _internal_has_syncblock();
}
inline void PacketHeaderProto::clear_syncblock() {
  syncblock_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PacketHeaderProto::_internal_syncblock() const {
  return syncblock_;
}
inline bool PacketHeaderProto::syncblock() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PacketHeaderProto.syncBlock)
  return _internal_syncblock();
}
inline void PacketHeaderProto::_internal_set_syncblock(bool value) {
  _has_bits_[0] |= 0x00000010u;
  syncblock_ = value;
}
inline void PacketHeaderProto::set_syncblock(bool value) {
  _internal_set_syncblock(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PacketHeaderProto.syncBlock)
}

// -------------------------------------------------------------------

// PipelineAckProto

// required sint64 seqno = 1;
inline bool PipelineAckProto::_internal_has_seqno() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PipelineAckProto::has_seqno() const {
  return _internal_has_seqno();
}
inline void PipelineAckProto::clear_seqno() {
  seqno_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PipelineAckProto::_internal_seqno() const {
  return seqno_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PipelineAckProto::seqno() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PipelineAckProto.seqno)
  return _internal_seqno();
}
inline void PipelineAckProto::_internal_set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  seqno_ = value;
}
inline void PipelineAckProto::set_seqno(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PipelineAckProto.seqno)
}

// repeated .Hdfs.Internal.Status status = 2;
inline int PipelineAckProto::_internal_status_size() const {
  return status_.size();
}
inline int PipelineAckProto::status_size() const {
  return _internal_status_size();
}
inline void PipelineAckProto::clear_status() {
  status_.Clear();
}
inline ::Hdfs::Internal::Status PipelineAckProto::_internal_status(int index) const {
  return static_cast< ::Hdfs::Internal::Status >(status_.Get(index));
}
inline ::Hdfs::Internal::Status PipelineAckProto::status(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PipelineAckProto.status)
  return _internal_status(index);
}
inline void PipelineAckProto::set_status(int index, ::Hdfs::Internal::Status value) {
  assert(::Hdfs::Internal::Status_IsValid(value));
  status_.Set(index, value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PipelineAckProto.status)
}
inline void PipelineAckProto::_internal_add_status(::Hdfs::Internal::Status value) {
  assert(::Hdfs::Internal::Status_IsValid(value));
  status_.Add(value);
}
inline void PipelineAckProto::add_status(::Hdfs::Internal::Status value) {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.PipelineAckProto.status)
  _internal_add_status(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PipelineAckProto::status() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.PipelineAckProto.status)
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PipelineAckProto::_internal_mutable_status() {
  return &status_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PipelineAckProto::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.PipelineAckProto.status)
  return _internal_mutable_status();
}

// optional uint64 downstreamAckTimeNanos = 3 [default = 0];
inline bool PipelineAckProto::_internal_has_downstreamacktimenanos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PipelineAckProto::has_downstreamacktimenanos() const {
  return _internal_has_downstreamacktimenanos();
}
inline void PipelineAckProto::clear_downstreamacktimenanos() {
  downstreamacktimenanos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PipelineAckProto::_internal_downstreamacktimenanos() const {
  return downstreamacktimenanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PipelineAckProto::downstreamacktimenanos() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PipelineAckProto.downstreamAckTimeNanos)
  return _internal_downstreamacktimenanos();
}
inline void PipelineAckProto::_internal_set_downstreamacktimenanos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  downstreamacktimenanos_ = value;
}
inline void PipelineAckProto::set_downstreamacktimenanos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_downstreamacktimenanos(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PipelineAckProto.downstreamAckTimeNanos)
}

// -------------------------------------------------------------------

// ReadOpChecksumInfoProto

// required .Hdfs.Internal.ChecksumProto checksum = 1;
inline bool ReadOpChecksumInfoProto::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || checksum_ != nullptr);
  return value;
}
inline bool ReadOpChecksumInfoProto::has_checksum() const {
  return _internal_has_checksum();
}
inline void ReadOpChecksumInfoProto::clear_checksum() {
  if (checksum_ != nullptr) checksum_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::ChecksumProto& ReadOpChecksumInfoProto::_internal_checksum() const {
  const ::Hdfs::Internal::ChecksumProto* p = checksum_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ChecksumProto*>(
      &::Hdfs::Internal::_ChecksumProto_default_instance_);
}
inline const ::Hdfs::Internal::ChecksumProto& ReadOpChecksumInfoProto::checksum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ReadOpChecksumInfoProto.checksum)
  return _internal_checksum();
}
inline ::Hdfs::Internal::ChecksumProto* ReadOpChecksumInfoProto::release_checksum() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ReadOpChecksumInfoProto.checksum)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ChecksumProto* temp = checksum_;
  checksum_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ChecksumProto* ReadOpChecksumInfoProto::_internal_mutable_checksum() {
  _has_bits_[0] |= 0x00000001u;
  if (checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ChecksumProto>(GetArenaNoVirtual());
    checksum_ = p;
  }
  return checksum_;
}
inline ::Hdfs::Internal::ChecksumProto* ReadOpChecksumInfoProto::mutable_checksum() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ReadOpChecksumInfoProto.checksum)
  return _internal_mutable_checksum();
}
inline void ReadOpChecksumInfoProto::set_allocated_checksum(::Hdfs::Internal::ChecksumProto* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ReadOpChecksumInfoProto.checksum)
}

// required uint64 chunkOffset = 2;
inline bool ReadOpChecksumInfoProto::_internal_has_chunkoffset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReadOpChecksumInfoProto::has_chunkoffset() const {
  return _internal_has_chunkoffset();
}
inline void ReadOpChecksumInfoProto::clear_chunkoffset() {
  chunkoffset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReadOpChecksumInfoProto::_internal_chunkoffset() const {
  return chunkoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReadOpChecksumInfoProto::chunkoffset() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ReadOpChecksumInfoProto.chunkOffset)
  return _internal_chunkoffset();
}
inline void ReadOpChecksumInfoProto::_internal_set_chunkoffset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  chunkoffset_ = value;
}
inline void ReadOpChecksumInfoProto::set_chunkoffset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_chunkoffset(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ReadOpChecksumInfoProto.chunkOffset)
}

// -------------------------------------------------------------------

// BlockOpResponseProto

// required .Hdfs.Internal.Status status = 1;
inline bool BlockOpResponseProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BlockOpResponseProto::has_status() const {
  return _internal_has_status();
}
inline void BlockOpResponseProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Hdfs::Internal::Status BlockOpResponseProto::_internal_status() const {
  return static_cast< ::Hdfs::Internal::Status >(status_);
}
inline ::Hdfs::Internal::Status BlockOpResponseProto::status() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.status)
  return _internal_status();
}
inline void BlockOpResponseProto::_internal_set_status(::Hdfs::Internal::Status value) {
  assert(::Hdfs::Internal::Status_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void BlockOpResponseProto::set_status(::Hdfs::Internal::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockOpResponseProto.status)
}

// optional string firstBadLink = 2;
inline bool BlockOpResponseProto::_internal_has_firstbadlink() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockOpResponseProto::has_firstbadlink() const {
  return _internal_has_firstbadlink();
}
inline void BlockOpResponseProto::clear_firstbadlink() {
  firstbadlink_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockOpResponseProto::firstbadlink() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
  return _internal_firstbadlink();
}
inline void BlockOpResponseProto::set_firstbadlink(const std::string& value) {
  _internal_set_firstbadlink(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
}
inline std::string* BlockOpResponseProto::mutable_firstbadlink() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
  return _internal_mutable_firstbadlink();
}
inline const std::string& BlockOpResponseProto::_internal_firstbadlink() const {
  return firstbadlink_.GetNoArena();
}
inline void BlockOpResponseProto::_internal_set_firstbadlink(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  firstbadlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BlockOpResponseProto::set_firstbadlink(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  firstbadlink_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
}
inline void BlockOpResponseProto::set_firstbadlink(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  firstbadlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
}
inline void BlockOpResponseProto::set_firstbadlink(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  firstbadlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
}
inline std::string* BlockOpResponseProto::_internal_mutable_firstbadlink() {
  _has_bits_[0] |= 0x00000001u;
  return firstbadlink_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BlockOpResponseProto::release_firstbadlink() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
  if (!_internal_has_firstbadlink()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return firstbadlink_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_allocated_firstbadlink(std::string* firstbadlink) {
  if (firstbadlink != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  firstbadlink_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), firstbadlink);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockOpResponseProto.firstBadLink)
}

// optional .Hdfs.Internal.OpBlockChecksumResponseProto checksumResponse = 3;
inline bool BlockOpResponseProto::_internal_has_checksumresponse() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || checksumresponse_ != nullptr);
  return value;
}
inline bool BlockOpResponseProto::has_checksumresponse() const {
  return _internal_has_checksumresponse();
}
inline void BlockOpResponseProto::clear_checksumresponse() {
  if (checksumresponse_ != nullptr) checksumresponse_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Hdfs::Internal::OpBlockChecksumResponseProto& BlockOpResponseProto::_internal_checksumresponse() const {
  const ::Hdfs::Internal::OpBlockChecksumResponseProto* p = checksumresponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::OpBlockChecksumResponseProto*>(
      &::Hdfs::Internal::_OpBlockChecksumResponseProto_default_instance_);
}
inline const ::Hdfs::Internal::OpBlockChecksumResponseProto& BlockOpResponseProto::checksumresponse() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.checksumResponse)
  return _internal_checksumresponse();
}
inline ::Hdfs::Internal::OpBlockChecksumResponseProto* BlockOpResponseProto::release_checksumresponse() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockOpResponseProto.checksumResponse)
  _has_bits_[0] &= ~0x00000004u;
  ::Hdfs::Internal::OpBlockChecksumResponseProto* temp = checksumresponse_;
  checksumresponse_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::OpBlockChecksumResponseProto* BlockOpResponseProto::_internal_mutable_checksumresponse() {
  _has_bits_[0] |= 0x00000004u;
  if (checksumresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::OpBlockChecksumResponseProto>(GetArenaNoVirtual());
    checksumresponse_ = p;
  }
  return checksumresponse_;
}
inline ::Hdfs::Internal::OpBlockChecksumResponseProto* BlockOpResponseProto::mutable_checksumresponse() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockOpResponseProto.checksumResponse)
  return _internal_mutable_checksumresponse();
}
inline void BlockOpResponseProto::set_allocated_checksumresponse(::Hdfs::Internal::OpBlockChecksumResponseProto* checksumresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete checksumresponse_;
  }
  if (checksumresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      checksumresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksumresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  checksumresponse_ = checksumresponse;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockOpResponseProto.checksumResponse)
}

// optional .Hdfs.Internal.ReadOpChecksumInfoProto readOpChecksumInfo = 4;
inline bool BlockOpResponseProto::_internal_has_readopchecksuminfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || readopchecksuminfo_ != nullptr);
  return value;
}
inline bool BlockOpResponseProto::has_readopchecksuminfo() const {
  return _internal_has_readopchecksuminfo();
}
inline void BlockOpResponseProto::clear_readopchecksuminfo() {
  if (readopchecksuminfo_ != nullptr) readopchecksuminfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Hdfs::Internal::ReadOpChecksumInfoProto& BlockOpResponseProto::_internal_readopchecksuminfo() const {
  const ::Hdfs::Internal::ReadOpChecksumInfoProto* p = readopchecksuminfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ReadOpChecksumInfoProto*>(
      &::Hdfs::Internal::_ReadOpChecksumInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::ReadOpChecksumInfoProto& BlockOpResponseProto::readopchecksuminfo() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.readOpChecksumInfo)
  return _internal_readopchecksuminfo();
}
inline ::Hdfs::Internal::ReadOpChecksumInfoProto* BlockOpResponseProto::release_readopchecksuminfo() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockOpResponseProto.readOpChecksumInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::Hdfs::Internal::ReadOpChecksumInfoProto* temp = readopchecksuminfo_;
  readopchecksuminfo_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ReadOpChecksumInfoProto* BlockOpResponseProto::_internal_mutable_readopchecksuminfo() {
  _has_bits_[0] |= 0x00000008u;
  if (readopchecksuminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ReadOpChecksumInfoProto>(GetArenaNoVirtual());
    readopchecksuminfo_ = p;
  }
  return readopchecksuminfo_;
}
inline ::Hdfs::Internal::ReadOpChecksumInfoProto* BlockOpResponseProto::mutable_readopchecksuminfo() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockOpResponseProto.readOpChecksumInfo)
  return _internal_mutable_readopchecksuminfo();
}
inline void BlockOpResponseProto::set_allocated_readopchecksuminfo(::Hdfs::Internal::ReadOpChecksumInfoProto* readopchecksuminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete readopchecksuminfo_;
  }
  if (readopchecksuminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readopchecksuminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readopchecksuminfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  readopchecksuminfo_ = readopchecksuminfo;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockOpResponseProto.readOpChecksumInfo)
}

// optional string message = 5;
inline bool BlockOpResponseProto::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockOpResponseProto::has_message() const {
  return _internal_has_message();
}
inline void BlockOpResponseProto::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockOpResponseProto::message() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.message)
  return _internal_message();
}
inline void BlockOpResponseProto::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockOpResponseProto.message)
}
inline std::string* BlockOpResponseProto::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockOpResponseProto.message)
  return _internal_mutable_message();
}
inline const std::string& BlockOpResponseProto::_internal_message() const {
  return message_.GetNoArena();
}
inline void BlockOpResponseProto::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BlockOpResponseProto::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.BlockOpResponseProto.message)
}
inline void BlockOpResponseProto::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.BlockOpResponseProto.message)
}
inline void BlockOpResponseProto::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.BlockOpResponseProto.message)
}
inline std::string* BlockOpResponseProto::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BlockOpResponseProto::release_message() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockOpResponseProto.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockOpResponseProto.message)
}

// optional uint32 shortCircuitAccessVersion = 6;
inline bool BlockOpResponseProto::_internal_has_shortcircuitaccessversion() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BlockOpResponseProto::has_shortcircuitaccessversion() const {
  return _internal_has_shortcircuitaccessversion();
}
inline void BlockOpResponseProto::clear_shortcircuitaccessversion() {
  shortcircuitaccessversion_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockOpResponseProto::_internal_shortcircuitaccessversion() const {
  return shortcircuitaccessversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockOpResponseProto::shortcircuitaccessversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockOpResponseProto.shortCircuitAccessVersion)
  return _internal_shortcircuitaccessversion();
}
inline void BlockOpResponseProto::_internal_set_shortcircuitaccessversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  shortcircuitaccessversion_ = value;
}
inline void BlockOpResponseProto::set_shortcircuitaccessversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_shortcircuitaccessversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockOpResponseProto.shortCircuitAccessVersion)
}

// -------------------------------------------------------------------

// ClientReadStatusProto

// required .Hdfs.Internal.Status status = 1;
inline bool ClientReadStatusProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientReadStatusProto::has_status() const {
  return _internal_has_status();
}
inline void ClientReadStatusProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::Hdfs::Internal::Status ClientReadStatusProto::_internal_status() const {
  return static_cast< ::Hdfs::Internal::Status >(status_);
}
inline ::Hdfs::Internal::Status ClientReadStatusProto::status() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ClientReadStatusProto.status)
  return _internal_status();
}
inline void ClientReadStatusProto::_internal_set_status(::Hdfs::Internal::Status value) {
  assert(::Hdfs::Internal::Status_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void ClientReadStatusProto::set_status(::Hdfs::Internal::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ClientReadStatusProto.status)
}

// -------------------------------------------------------------------

// DNTransferAckProto

// required .Hdfs.Internal.Status status = 1;
inline bool DNTransferAckProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DNTransferAckProto::has_status() const {
  return _internal_has_status();
}
inline void DNTransferAckProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::Hdfs::Internal::Status DNTransferAckProto::_internal_status() const {
  return static_cast< ::Hdfs::Internal::Status >(status_);
}
inline ::Hdfs::Internal::Status DNTransferAckProto::status() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DNTransferAckProto.status)
  return _internal_status();
}
inline void DNTransferAckProto::_internal_set_status(::Hdfs::Internal::Status value) {
  assert(::Hdfs::Internal::Status_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void DNTransferAckProto::set_status(::Hdfs::Internal::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DNTransferAckProto.status)
}

// -------------------------------------------------------------------

// OpBlockChecksumResponseProto

// required uint32 bytesPerCrc = 1;
inline bool OpBlockChecksumResponseProto::_internal_has_bytespercrc() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OpBlockChecksumResponseProto::has_bytespercrc() const {
  return _internal_has_bytespercrc();
}
inline void OpBlockChecksumResponseProto::clear_bytespercrc() {
  bytespercrc_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpBlockChecksumResponseProto::_internal_bytespercrc() const {
  return bytespercrc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OpBlockChecksumResponseProto::bytespercrc() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpBlockChecksumResponseProto.bytesPerCrc)
  return _internal_bytespercrc();
}
inline void OpBlockChecksumResponseProto::_internal_set_bytespercrc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  bytespercrc_ = value;
}
inline void OpBlockChecksumResponseProto::set_bytespercrc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bytespercrc(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpBlockChecksumResponseProto.bytesPerCrc)
}

// required uint64 crcPerBlock = 2;
inline bool OpBlockChecksumResponseProto::_internal_has_crcperblock() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpBlockChecksumResponseProto::has_crcperblock() const {
  return _internal_has_crcperblock();
}
inline void OpBlockChecksumResponseProto::clear_crcperblock() {
  crcperblock_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpBlockChecksumResponseProto::_internal_crcperblock() const {
  return crcperblock_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpBlockChecksumResponseProto::crcperblock() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpBlockChecksumResponseProto.crcPerBlock)
  return _internal_crcperblock();
}
inline void OpBlockChecksumResponseProto::_internal_set_crcperblock(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  crcperblock_ = value;
}
inline void OpBlockChecksumResponseProto::set_crcperblock(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_crcperblock(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpBlockChecksumResponseProto.crcPerBlock)
}

// required bytes md5 = 3;
inline bool OpBlockChecksumResponseProto::_internal_has_md5() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpBlockChecksumResponseProto::has_md5() const {
  return _internal_has_md5();
}
inline void OpBlockChecksumResponseProto::clear_md5() {
  md5_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpBlockChecksumResponseProto::md5() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
  return _internal_md5();
}
inline void OpBlockChecksumResponseProto::set_md5(const std::string& value) {
  _internal_set_md5(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
}
inline std::string* OpBlockChecksumResponseProto::mutable_md5() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
  return _internal_mutable_md5();
}
inline const std::string& OpBlockChecksumResponseProto::_internal_md5() const {
  return md5_.GetNoArena();
}
inline void OpBlockChecksumResponseProto::_internal_set_md5(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OpBlockChecksumResponseProto::set_md5(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
}
inline void OpBlockChecksumResponseProto::set_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
}
inline void OpBlockChecksumResponseProto::set_md5(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
}
inline std::string* OpBlockChecksumResponseProto::_internal_mutable_md5() {
  _has_bits_[0] |= 0x00000001u;
  return md5_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OpBlockChecksumResponseProto::release_md5() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
  if (!_internal_has_md5()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return md5_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OpBlockChecksumResponseProto::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  md5_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.OpBlockChecksumResponseProto.md5)
}

// optional .Hdfs.Internal.ChecksumTypeProto crcType = 4;
inline bool OpBlockChecksumResponseProto::_internal_has_crctype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OpBlockChecksumResponseProto::has_crctype() const {
  return _internal_has_crctype();
}
inline void OpBlockChecksumResponseProto::clear_crctype() {
  crctype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::Hdfs::Internal::ChecksumTypeProto OpBlockChecksumResponseProto::_internal_crctype() const {
  return static_cast< ::Hdfs::Internal::ChecksumTypeProto >(crctype_);
}
inline ::Hdfs::Internal::ChecksumTypeProto OpBlockChecksumResponseProto::crctype() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.OpBlockChecksumResponseProto.crcType)
  return _internal_crctype();
}
inline void OpBlockChecksumResponseProto::_internal_set_crctype(::Hdfs::Internal::ChecksumTypeProto value) {
  assert(::Hdfs::Internal::ChecksumTypeProto_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  crctype_ = value;
}
inline void OpBlockChecksumResponseProto::set_crctype(::Hdfs::Internal::ChecksumTypeProto value) {
  _internal_set_crctype(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.OpBlockChecksumResponseProto.crcType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Internal
}  // namespace Hdfs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>() {
  return ::Hdfs::Internal::DataTransferEncryptorMessageProto_DataTransferEncryptorStatus_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage>() {
  return ::Hdfs::Internal::OpWriteBlockProto_BlockConstructionStage_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::Status>() {
  return ::Hdfs::Internal::Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_datatransfer_2eproto
