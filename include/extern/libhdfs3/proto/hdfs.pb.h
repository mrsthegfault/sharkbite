// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hdfs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hdfs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Security.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hdfs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hdfs_2eproto;
namespace Hdfs {
namespace Internal {
class BlockKeyProto;
class BlockKeyProtoDefaultTypeInternal;
extern BlockKeyProtoDefaultTypeInternal _BlockKeyProto_default_instance_;
class BlockProto;
class BlockProtoDefaultTypeInternal;
extern BlockProtoDefaultTypeInternal _BlockProto_default_instance_;
class BlockWithLocationsProto;
class BlockWithLocationsProtoDefaultTypeInternal;
extern BlockWithLocationsProtoDefaultTypeInternal _BlockWithLocationsProto_default_instance_;
class BlocksWithLocationsProto;
class BlocksWithLocationsProtoDefaultTypeInternal;
extern BlocksWithLocationsProtoDefaultTypeInternal _BlocksWithLocationsProto_default_instance_;
class CheckpointCommandProto;
class CheckpointCommandProtoDefaultTypeInternal;
extern CheckpointCommandProtoDefaultTypeInternal _CheckpointCommandProto_default_instance_;
class CheckpointSignatureProto;
class CheckpointSignatureProtoDefaultTypeInternal;
extern CheckpointSignatureProtoDefaultTypeInternal _CheckpointSignatureProto_default_instance_;
class CipherOptionProto;
class CipherOptionProtoDefaultTypeInternal;
extern CipherOptionProtoDefaultTypeInternal _CipherOptionProto_default_instance_;
class ContentSummaryProto;
class ContentSummaryProtoDefaultTypeInternal;
extern ContentSummaryProtoDefaultTypeInternal _ContentSummaryProto_default_instance_;
class CorruptFileBlocksProto;
class CorruptFileBlocksProtoDefaultTypeInternal;
extern CorruptFileBlocksProtoDefaultTypeInternal _CorruptFileBlocksProto_default_instance_;
class DataEncryptionKeyProto;
class DataEncryptionKeyProtoDefaultTypeInternal;
extern DataEncryptionKeyProtoDefaultTypeInternal _DataEncryptionKeyProto_default_instance_;
class DatanodeIDProto;
class DatanodeIDProtoDefaultTypeInternal;
extern DatanodeIDProtoDefaultTypeInternal _DatanodeIDProto_default_instance_;
class DatanodeInfoProto;
class DatanodeInfoProtoDefaultTypeInternal;
extern DatanodeInfoProtoDefaultTypeInternal _DatanodeInfoProto_default_instance_;
class DatanodeInfosProto;
class DatanodeInfosProtoDefaultTypeInternal;
extern DatanodeInfosProtoDefaultTypeInternal _DatanodeInfosProto_default_instance_;
class DirectoryListingProto;
class DirectoryListingProtoDefaultTypeInternal;
extern DirectoryListingProtoDefaultTypeInternal _DirectoryListingProto_default_instance_;
class ExportedBlockKeysProto;
class ExportedBlockKeysProtoDefaultTypeInternal;
extern ExportedBlockKeysProtoDefaultTypeInternal _ExportedBlockKeysProto_default_instance_;
class ExtendedBlockProto;
class ExtendedBlockProtoDefaultTypeInternal;
extern ExtendedBlockProtoDefaultTypeInternal _ExtendedBlockProto_default_instance_;
class FileEncryptionInfoProto;
class FileEncryptionInfoProtoDefaultTypeInternal;
extern FileEncryptionInfoProtoDefaultTypeInternal _FileEncryptionInfoProto_default_instance_;
class FsPermissionProto;
class FsPermissionProtoDefaultTypeInternal;
extern FsPermissionProtoDefaultTypeInternal _FsPermissionProto_default_instance_;
class FsServerDefaultsProto;
class FsServerDefaultsProtoDefaultTypeInternal;
extern FsServerDefaultsProtoDefaultTypeInternal _FsServerDefaultsProto_default_instance_;
class HdfsFileStatusProto;
class HdfsFileStatusProtoDefaultTypeInternal;
extern HdfsFileStatusProtoDefaultTypeInternal _HdfsFileStatusProto_default_instance_;
class LocatedBlockProto;
class LocatedBlockProtoDefaultTypeInternal;
extern LocatedBlockProtoDefaultTypeInternal _LocatedBlockProto_default_instance_;
class LocatedBlocksProto;
class LocatedBlocksProtoDefaultTypeInternal;
extern LocatedBlocksProtoDefaultTypeInternal _LocatedBlocksProto_default_instance_;
class NamenodeCommandProto;
class NamenodeCommandProtoDefaultTypeInternal;
extern NamenodeCommandProtoDefaultTypeInternal _NamenodeCommandProto_default_instance_;
class NamenodeRegistrationProto;
class NamenodeRegistrationProtoDefaultTypeInternal;
extern NamenodeRegistrationProtoDefaultTypeInternal _NamenodeRegistrationProto_default_instance_;
class NamespaceInfoProto;
class NamespaceInfoProtoDefaultTypeInternal;
extern NamespaceInfoProtoDefaultTypeInternal _NamespaceInfoProto_default_instance_;
class PerFileEncryptionInfoProto;
class PerFileEncryptionInfoProtoDefaultTypeInternal;
extern PerFileEncryptionInfoProtoDefaultTypeInternal _PerFileEncryptionInfoProto_default_instance_;
class RecoveringBlockProto;
class RecoveringBlockProtoDefaultTypeInternal;
extern RecoveringBlockProtoDefaultTypeInternal _RecoveringBlockProto_default_instance_;
class RemoteEditLogManifestProto;
class RemoteEditLogManifestProtoDefaultTypeInternal;
extern RemoteEditLogManifestProtoDefaultTypeInternal _RemoteEditLogManifestProto_default_instance_;
class RemoteEditLogProto;
class RemoteEditLogProtoDefaultTypeInternal;
extern RemoteEditLogProtoDefaultTypeInternal _RemoteEditLogProto_default_instance_;
class SnapshotDiffReportEntryProto;
class SnapshotDiffReportEntryProtoDefaultTypeInternal;
extern SnapshotDiffReportEntryProtoDefaultTypeInternal _SnapshotDiffReportEntryProto_default_instance_;
class SnapshotDiffReportProto;
class SnapshotDiffReportProtoDefaultTypeInternal;
extern SnapshotDiffReportProtoDefaultTypeInternal _SnapshotDiffReportProto_default_instance_;
class SnapshotInfoProto;
class SnapshotInfoProtoDefaultTypeInternal;
extern SnapshotInfoProtoDefaultTypeInternal _SnapshotInfoProto_default_instance_;
class SnapshottableDirectoryListingProto;
class SnapshottableDirectoryListingProtoDefaultTypeInternal;
extern SnapshottableDirectoryListingProtoDefaultTypeInternal _SnapshottableDirectoryListingProto_default_instance_;
class SnapshottableDirectoryStatusProto;
class SnapshottableDirectoryStatusProtoDefaultTypeInternal;
extern SnapshottableDirectoryStatusProtoDefaultTypeInternal _SnapshottableDirectoryStatusProto_default_instance_;
class StorageInfoProto;
class StorageInfoProtoDefaultTypeInternal;
extern StorageInfoProtoDefaultTypeInternal _StorageInfoProto_default_instance_;
class StorageUuidsProto;
class StorageUuidsProtoDefaultTypeInternal;
extern StorageUuidsProtoDefaultTypeInternal _StorageUuidsProto_default_instance_;
class VersionRequestProto;
class VersionRequestProtoDefaultTypeInternal;
extern VersionRequestProtoDefaultTypeInternal _VersionRequestProto_default_instance_;
class VersionResponseProto;
class VersionResponseProtoDefaultTypeInternal;
extern VersionResponseProtoDefaultTypeInternal _VersionResponseProto_default_instance_;
class ZoneEncryptionInfoProto;
class ZoneEncryptionInfoProtoDefaultTypeInternal;
extern ZoneEncryptionInfoProtoDefaultTypeInternal _ZoneEncryptionInfoProto_default_instance_;
}  // namespace Internal
}  // namespace Hdfs
PROTOBUF_NAMESPACE_OPEN
template<> ::Hdfs::Internal::BlockKeyProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BlockKeyProto>(Arena*);
template<> ::Hdfs::Internal::BlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BlockProto>(Arena*);
template<> ::Hdfs::Internal::BlockWithLocationsProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BlockWithLocationsProto>(Arena*);
template<> ::Hdfs::Internal::BlocksWithLocationsProto* Arena::CreateMaybeMessage<::Hdfs::Internal::BlocksWithLocationsProto>(Arena*);
template<> ::Hdfs::Internal::CheckpointCommandProto* Arena::CreateMaybeMessage<::Hdfs::Internal::CheckpointCommandProto>(Arena*);
template<> ::Hdfs::Internal::CheckpointSignatureProto* Arena::CreateMaybeMessage<::Hdfs::Internal::CheckpointSignatureProto>(Arena*);
template<> ::Hdfs::Internal::CipherOptionProto* Arena::CreateMaybeMessage<::Hdfs::Internal::CipherOptionProto>(Arena*);
template<> ::Hdfs::Internal::ContentSummaryProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ContentSummaryProto>(Arena*);
template<> ::Hdfs::Internal::CorruptFileBlocksProto* Arena::CreateMaybeMessage<::Hdfs::Internal::CorruptFileBlocksProto>(Arena*);
template<> ::Hdfs::Internal::DataEncryptionKeyProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DataEncryptionKeyProto>(Arena*);
template<> ::Hdfs::Internal::DatanodeIDProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeIDProto>(Arena*);
template<> ::Hdfs::Internal::DatanodeInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeInfoProto>(Arena*);
template<> ::Hdfs::Internal::DatanodeInfosProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeInfosProto>(Arena*);
template<> ::Hdfs::Internal::DirectoryListingProto* Arena::CreateMaybeMessage<::Hdfs::Internal::DirectoryListingProto>(Arena*);
template<> ::Hdfs::Internal::ExportedBlockKeysProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ExportedBlockKeysProto>(Arena*);
template<> ::Hdfs::Internal::ExtendedBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ExtendedBlockProto>(Arena*);
template<> ::Hdfs::Internal::FileEncryptionInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::FileEncryptionInfoProto>(Arena*);
template<> ::Hdfs::Internal::FsPermissionProto* Arena::CreateMaybeMessage<::Hdfs::Internal::FsPermissionProto>(Arena*);
template<> ::Hdfs::Internal::FsServerDefaultsProto* Arena::CreateMaybeMessage<::Hdfs::Internal::FsServerDefaultsProto>(Arena*);
template<> ::Hdfs::Internal::HdfsFileStatusProto* Arena::CreateMaybeMessage<::Hdfs::Internal::HdfsFileStatusProto>(Arena*);
template<> ::Hdfs::Internal::LocatedBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::LocatedBlockProto>(Arena*);
template<> ::Hdfs::Internal::LocatedBlocksProto* Arena::CreateMaybeMessage<::Hdfs::Internal::LocatedBlocksProto>(Arena*);
template<> ::Hdfs::Internal::NamenodeCommandProto* Arena::CreateMaybeMessage<::Hdfs::Internal::NamenodeCommandProto>(Arena*);
template<> ::Hdfs::Internal::NamenodeRegistrationProto* Arena::CreateMaybeMessage<::Hdfs::Internal::NamenodeRegistrationProto>(Arena*);
template<> ::Hdfs::Internal::NamespaceInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::NamespaceInfoProto>(Arena*);
template<> ::Hdfs::Internal::PerFileEncryptionInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::PerFileEncryptionInfoProto>(Arena*);
template<> ::Hdfs::Internal::RecoveringBlockProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RecoveringBlockProto>(Arena*);
template<> ::Hdfs::Internal::RemoteEditLogManifestProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RemoteEditLogManifestProto>(Arena*);
template<> ::Hdfs::Internal::RemoteEditLogProto* Arena::CreateMaybeMessage<::Hdfs::Internal::RemoteEditLogProto>(Arena*);
template<> ::Hdfs::Internal::SnapshotDiffReportEntryProto* Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotDiffReportEntryProto>(Arena*);
template<> ::Hdfs::Internal::SnapshotDiffReportProto* Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotDiffReportProto>(Arena*);
template<> ::Hdfs::Internal::SnapshotInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotInfoProto>(Arena*);
template<> ::Hdfs::Internal::SnapshottableDirectoryListingProto* Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshottableDirectoryListingProto>(Arena*);
template<> ::Hdfs::Internal::SnapshottableDirectoryStatusProto* Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshottableDirectoryStatusProto>(Arena*);
template<> ::Hdfs::Internal::StorageInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::StorageInfoProto>(Arena*);
template<> ::Hdfs::Internal::StorageUuidsProto* Arena::CreateMaybeMessage<::Hdfs::Internal::StorageUuidsProto>(Arena*);
template<> ::Hdfs::Internal::VersionRequestProto* Arena::CreateMaybeMessage<::Hdfs::Internal::VersionRequestProto>(Arena*);
template<> ::Hdfs::Internal::VersionResponseProto* Arena::CreateMaybeMessage<::Hdfs::Internal::VersionResponseProto>(Arena*);
template<> ::Hdfs::Internal::ZoneEncryptionInfoProto* Arena::CreateMaybeMessage<::Hdfs::Internal::ZoneEncryptionInfoProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Hdfs {
namespace Internal {

enum DatanodeInfoProto_AdminState : int {
  DatanodeInfoProto_AdminState_NORMAL = 0,
  DatanodeInfoProto_AdminState_DECOMMISSION_INPROGRESS = 1,
  DatanodeInfoProto_AdminState_DECOMMISSIONED = 2
};
bool DatanodeInfoProto_AdminState_IsValid(int value);
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState_AdminState_MIN = DatanodeInfoProto_AdminState_NORMAL;
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState_AdminState_MAX = DatanodeInfoProto_AdminState_DECOMMISSIONED;
constexpr int DatanodeInfoProto_AdminState_AdminState_ARRAYSIZE = DatanodeInfoProto_AdminState_AdminState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor();
template<typename T>
inline const std::string& DatanodeInfoProto_AdminState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatanodeInfoProto_AdminState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatanodeInfoProto_AdminState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatanodeInfoProto_AdminState_descriptor(), enum_t_value);
}
inline bool DatanodeInfoProto_AdminState_Parse(
    const std::string& name, DatanodeInfoProto_AdminState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatanodeInfoProto_AdminState>(
    DatanodeInfoProto_AdminState_descriptor(), name, value);
}
enum HdfsFileStatusProto_FileType : int {
  HdfsFileStatusProto_FileType_IS_DIR = 1,
  HdfsFileStatusProto_FileType_IS_FILE = 2,
  HdfsFileStatusProto_FileType_IS_SYMLINK = 3
};
bool HdfsFileStatusProto_FileType_IsValid(int value);
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto_FileType_FileType_MIN = HdfsFileStatusProto_FileType_IS_DIR;
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto_FileType_FileType_MAX = HdfsFileStatusProto_FileType_IS_SYMLINK;
constexpr int HdfsFileStatusProto_FileType_FileType_ARRAYSIZE = HdfsFileStatusProto_FileType_FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HdfsFileStatusProto_FileType_descriptor();
template<typename T>
inline const std::string& HdfsFileStatusProto_FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HdfsFileStatusProto_FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HdfsFileStatusProto_FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HdfsFileStatusProto_FileType_descriptor(), enum_t_value);
}
inline bool HdfsFileStatusProto_FileType_Parse(
    const std::string& name, HdfsFileStatusProto_FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HdfsFileStatusProto_FileType>(
    HdfsFileStatusProto_FileType_descriptor(), name, value);
}
enum NamenodeRegistrationProto_NamenodeRoleProto : int {
  NamenodeRegistrationProto_NamenodeRoleProto_NAMENODE = 1,
  NamenodeRegistrationProto_NamenodeRoleProto_BACKUP = 2,
  NamenodeRegistrationProto_NamenodeRoleProto_CHECKPOINT = 3
};
bool NamenodeRegistrationProto_NamenodeRoleProto_IsValid(int value);
constexpr NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_MIN = NamenodeRegistrationProto_NamenodeRoleProto_NAMENODE;
constexpr NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_MAX = NamenodeRegistrationProto_NamenodeRoleProto_CHECKPOINT;
constexpr int NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_ARRAYSIZE = NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NamenodeRegistrationProto_NamenodeRoleProto_descriptor();
template<typename T>
inline const std::string& NamenodeRegistrationProto_NamenodeRoleProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NamenodeRegistrationProto_NamenodeRoleProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NamenodeRegistrationProto_NamenodeRoleProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NamenodeRegistrationProto_NamenodeRoleProto_descriptor(), enum_t_value);
}
inline bool NamenodeRegistrationProto_NamenodeRoleProto_Parse(
    const std::string& name, NamenodeRegistrationProto_NamenodeRoleProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NamenodeRegistrationProto_NamenodeRoleProto>(
    NamenodeRegistrationProto_NamenodeRoleProto_descriptor(), name, value);
}
enum NamenodeCommandProto_Type : int {
  NamenodeCommandProto_Type_NamenodeCommand = 0,
  NamenodeCommandProto_Type_CheckPointCommand = 1
};
bool NamenodeCommandProto_Type_IsValid(int value);
constexpr NamenodeCommandProto_Type NamenodeCommandProto_Type_Type_MIN = NamenodeCommandProto_Type_NamenodeCommand;
constexpr NamenodeCommandProto_Type NamenodeCommandProto_Type_Type_MAX = NamenodeCommandProto_Type_CheckPointCommand;
constexpr int NamenodeCommandProto_Type_Type_ARRAYSIZE = NamenodeCommandProto_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NamenodeCommandProto_Type_descriptor();
template<typename T>
inline const std::string& NamenodeCommandProto_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NamenodeCommandProto_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NamenodeCommandProto_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NamenodeCommandProto_Type_descriptor(), enum_t_value);
}
inline bool NamenodeCommandProto_Type_Parse(
    const std::string& name, NamenodeCommandProto_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NamenodeCommandProto_Type>(
    NamenodeCommandProto_Type_descriptor(), name, value);
}
enum StorageTypeProto : int {
  DISK = 1,
  SSD = 2
};
bool StorageTypeProto_IsValid(int value);
constexpr StorageTypeProto StorageTypeProto_MIN = DISK;
constexpr StorageTypeProto StorageTypeProto_MAX = SSD;
constexpr int StorageTypeProto_ARRAYSIZE = StorageTypeProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageTypeProto_descriptor();
template<typename T>
inline const std::string& StorageTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StorageTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StorageTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StorageTypeProto_descriptor(), enum_t_value);
}
inline bool StorageTypeProto_Parse(
    const std::string& name, StorageTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StorageTypeProto>(
    StorageTypeProto_descriptor(), name, value);
}
enum CipherSuiteProto : int {
  UNKNOWN = 1,
  AES_CTR_NOPADDING = 2
};
bool CipherSuiteProto_IsValid(int value);
constexpr CipherSuiteProto CipherSuiteProto_MIN = UNKNOWN;
constexpr CipherSuiteProto CipherSuiteProto_MAX = AES_CTR_NOPADDING;
constexpr int CipherSuiteProto_ARRAYSIZE = CipherSuiteProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CipherSuiteProto_descriptor();
template<typename T>
inline const std::string& CipherSuiteProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CipherSuiteProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CipherSuiteProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CipherSuiteProto_descriptor(), enum_t_value);
}
inline bool CipherSuiteProto_Parse(
    const std::string& name, CipherSuiteProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CipherSuiteProto>(
    CipherSuiteProto_descriptor(), name, value);
}
enum CryptoProtocolVersionProto : int {
  UNKNOWN_PROTOCOL_VERSION = 1,
  ENCRYPTION_ZONES = 2
};
bool CryptoProtocolVersionProto_IsValid(int value);
constexpr CryptoProtocolVersionProto CryptoProtocolVersionProto_MIN = UNKNOWN_PROTOCOL_VERSION;
constexpr CryptoProtocolVersionProto CryptoProtocolVersionProto_MAX = ENCRYPTION_ZONES;
constexpr int CryptoProtocolVersionProto_ARRAYSIZE = CryptoProtocolVersionProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CryptoProtocolVersionProto_descriptor();
template<typename T>
inline const std::string& CryptoProtocolVersionProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CryptoProtocolVersionProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CryptoProtocolVersionProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CryptoProtocolVersionProto_descriptor(), enum_t_value);
}
inline bool CryptoProtocolVersionProto_Parse(
    const std::string& name, CryptoProtocolVersionProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CryptoProtocolVersionProto>(
    CryptoProtocolVersionProto_descriptor(), name, value);
}
enum ChecksumTypeProto : int {
  CHECKSUM_NULL = 0,
  CHECKSUM_CRC32 = 1,
  CHECKSUM_CRC32C = 2
};
bool ChecksumTypeProto_IsValid(int value);
constexpr ChecksumTypeProto ChecksumTypeProto_MIN = CHECKSUM_NULL;
constexpr ChecksumTypeProto ChecksumTypeProto_MAX = CHECKSUM_CRC32C;
constexpr int ChecksumTypeProto_ARRAYSIZE = ChecksumTypeProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChecksumTypeProto_descriptor();
template<typename T>
inline const std::string& ChecksumTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChecksumTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChecksumTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChecksumTypeProto_descriptor(), enum_t_value);
}
inline bool ChecksumTypeProto_Parse(
    const std::string& name, ChecksumTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChecksumTypeProto>(
    ChecksumTypeProto_descriptor(), name, value);
}
enum ReplicaStateProto : int {
  FINALIZED = 0,
  RBW = 1,
  RWR = 2,
  RUR = 3,
  TEMPORARY = 4
};
bool ReplicaStateProto_IsValid(int value);
constexpr ReplicaStateProto ReplicaStateProto_MIN = FINALIZED;
constexpr ReplicaStateProto ReplicaStateProto_MAX = TEMPORARY;
constexpr int ReplicaStateProto_ARRAYSIZE = ReplicaStateProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplicaStateProto_descriptor();
template<typename T>
inline const std::string& ReplicaStateProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReplicaStateProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReplicaStateProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReplicaStateProto_descriptor(), enum_t_value);
}
inline bool ReplicaStateProto_Parse(
    const std::string& name, ReplicaStateProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReplicaStateProto>(
    ReplicaStateProto_descriptor(), name, value);
}
// ===================================================================

class ExtendedBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ExtendedBlockProto) */ {
 public:
  ExtendedBlockProto();
  virtual ~ExtendedBlockProto();

  ExtendedBlockProto(const ExtendedBlockProto& from);
  ExtendedBlockProto(ExtendedBlockProto&& from) noexcept
    : ExtendedBlockProto() {
    *this = ::std::move(from);
  }

  inline ExtendedBlockProto& operator=(const ExtendedBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedBlockProto& operator=(ExtendedBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExtendedBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendedBlockProto* internal_default_instance() {
    return reinterpret_cast<const ExtendedBlockProto*>(
               &_ExtendedBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExtendedBlockProto& a, ExtendedBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtendedBlockProto* New() const final {
    return CreateMaybeMessage<ExtendedBlockProto>(nullptr);
  }

  ExtendedBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtendedBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExtendedBlockProto& from);
  void MergeFrom(const ExtendedBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ExtendedBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolIdFieldNumber = 1,
    kBlockIdFieldNumber = 2,
    kGenerationStampFieldNumber = 3,
    kNumBytesFieldNumber = 4,
  };
  // required string poolId = 1;
  bool has_poolid() const;
  private:
  bool _internal_has_poolid() const;
  public:
  void clear_poolid();
  const std::string& poolid() const;
  void set_poolid(const std::string& value);
  void set_poolid(std::string&& value);
  void set_poolid(const char* value);
  void set_poolid(const char* value, size_t size);
  std::string* mutable_poolid();
  std::string* release_poolid();
  void set_allocated_poolid(std::string* poolid);
  private:
  const std::string& _internal_poolid() const;
  void _internal_set_poolid(const std::string& value);
  std::string* _internal_mutable_poolid();
  public:

  // required uint64 blockId = 2;
  bool has_blockid() const;
  private:
  bool _internal_has_blockid() const;
  public:
  void clear_blockid();
  ::PROTOBUF_NAMESPACE_ID::uint64 blockid() const;
  void set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blockid() const;
  void _internal_set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 generationStamp = 3;
  bool has_generationstamp() const;
  private:
  bool _internal_has_generationstamp() const;
  public:
  void clear_generationstamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 generationstamp() const;
  void set_generationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_generationstamp() const;
  void _internal_set_generationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 numBytes = 4 [default = 0];
  bool has_numbytes() const;
  private:
  bool _internal_has_numbytes() const;
  public:
  void clear_numbytes();
  ::PROTOBUF_NAMESPACE_ID::uint64 numbytes() const;
  void set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_numbytes() const;
  void _internal_set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ExtendedBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poolid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blockid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 generationstamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 numbytes_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class DatanodeIDProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DatanodeIDProto) */ {
 public:
  DatanodeIDProto();
  virtual ~DatanodeIDProto();

  DatanodeIDProto(const DatanodeIDProto& from);
  DatanodeIDProto(DatanodeIDProto&& from) noexcept
    : DatanodeIDProto() {
    *this = ::std::move(from);
  }

  inline DatanodeIDProto& operator=(const DatanodeIDProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeIDProto& operator=(DatanodeIDProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DatanodeIDProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatanodeIDProto* internal_default_instance() {
    return reinterpret_cast<const DatanodeIDProto*>(
               &_DatanodeIDProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatanodeIDProto& a, DatanodeIDProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeIDProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DatanodeIDProto* New() const final {
    return CreateMaybeMessage<DatanodeIDProto>(nullptr);
  }

  DatanodeIDProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DatanodeIDProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DatanodeIDProto& from);
  void MergeFrom(const DatanodeIDProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeIDProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DatanodeIDProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddrFieldNumber = 1,
    kHostNameFieldNumber = 2,
    kDatanodeUuidFieldNumber = 3,
    kXferPortFieldNumber = 4,
    kInfoPortFieldNumber = 5,
    kIpcPortFieldNumber = 6,
    kInfoSecurePortFieldNumber = 7,
  };
  // required string ipAddr = 1;
  bool has_ipaddr() const;
  private:
  bool _internal_has_ipaddr() const;
  public:
  void clear_ipaddr();
  const std::string& ipaddr() const;
  void set_ipaddr(const std::string& value);
  void set_ipaddr(std::string&& value);
  void set_ipaddr(const char* value);
  void set_ipaddr(const char* value, size_t size);
  std::string* mutable_ipaddr();
  std::string* release_ipaddr();
  void set_allocated_ipaddr(std::string* ipaddr);
  private:
  const std::string& _internal_ipaddr() const;
  void _internal_set_ipaddr(const std::string& value);
  std::string* _internal_mutable_ipaddr();
  public:

  // required string hostName = 2;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // required string datanodeUuid = 3;
  bool has_datanodeuuid() const;
  private:
  bool _internal_has_datanodeuuid() const;
  public:
  void clear_datanodeuuid();
  const std::string& datanodeuuid() const;
  void set_datanodeuuid(const std::string& value);
  void set_datanodeuuid(std::string&& value);
  void set_datanodeuuid(const char* value);
  void set_datanodeuuid(const char* value, size_t size);
  std::string* mutable_datanodeuuid();
  std::string* release_datanodeuuid();
  void set_allocated_datanodeuuid(std::string* datanodeuuid);
  private:
  const std::string& _internal_datanodeuuid() const;
  void _internal_set_datanodeuuid(const std::string& value);
  std::string* _internal_mutable_datanodeuuid();
  public:

  // required uint32 xferPort = 4;
  bool has_xferport() const;
  private:
  bool _internal_has_xferport() const;
  public:
  void clear_xferport();
  ::PROTOBUF_NAMESPACE_ID::uint32 xferport() const;
  void set_xferport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_xferport() const;
  void _internal_set_xferport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 infoPort = 5;
  bool has_infoport() const;
  private:
  bool _internal_has_infoport() const;
  public:
  void clear_infoport();
  ::PROTOBUF_NAMESPACE_ID::uint32 infoport() const;
  void set_infoport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_infoport() const;
  void _internal_set_infoport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 ipcPort = 6;
  bool has_ipcport() const;
  private:
  bool _internal_has_ipcport() const;
  public:
  void clear_ipcport();
  ::PROTOBUF_NAMESPACE_ID::uint32 ipcport() const;
  void set_ipcport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ipcport() const;
  void _internal_set_ipcport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 infoSecurePort = 7 [default = 0];
  bool has_infosecureport() const;
  private:
  bool _internal_has_infosecureport() const;
  public:
  void clear_infosecureport();
  ::PROTOBUF_NAMESPACE_ID::uint32 infosecureport() const;
  void set_infosecureport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_infosecureport() const;
  void _internal_set_infosecureport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DatanodeIDProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datanodeuuid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 xferport_;
  ::PROTOBUF_NAMESPACE_ID::uint32 infoport_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ipcport_;
  ::PROTOBUF_NAMESPACE_ID::uint32 infosecureport_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class DatanodeInfosProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DatanodeInfosProto) */ {
 public:
  DatanodeInfosProto();
  virtual ~DatanodeInfosProto();

  DatanodeInfosProto(const DatanodeInfosProto& from);
  DatanodeInfosProto(DatanodeInfosProto&& from) noexcept
    : DatanodeInfosProto() {
    *this = ::std::move(from);
  }

  inline DatanodeInfosProto& operator=(const DatanodeInfosProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeInfosProto& operator=(DatanodeInfosProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DatanodeInfosProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatanodeInfosProto* internal_default_instance() {
    return reinterpret_cast<const DatanodeInfosProto*>(
               &_DatanodeInfosProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DatanodeInfosProto& a, DatanodeInfosProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeInfosProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DatanodeInfosProto* New() const final {
    return CreateMaybeMessage<DatanodeInfosProto>(nullptr);
  }

  DatanodeInfosProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DatanodeInfosProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DatanodeInfosProto& from);
  void MergeFrom(const DatanodeInfosProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeInfosProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DatanodeInfosProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatanodesFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.DatanodeInfoProto datanodes = 1;
  int datanodes_size() const;
  private:
  int _internal_datanodes_size() const;
  public:
  void clear_datanodes();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_datanodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
      mutable_datanodes();
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_datanodes(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_add_datanodes();
  public:
  const ::Hdfs::Internal::DatanodeInfoProto& datanodes(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* add_datanodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
      datanodes() const;

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DatanodeInfosProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto > datanodes_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class DatanodeInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DatanodeInfoProto) */ {
 public:
  DatanodeInfoProto();
  virtual ~DatanodeInfoProto();

  DatanodeInfoProto(const DatanodeInfoProto& from);
  DatanodeInfoProto(DatanodeInfoProto&& from) noexcept
    : DatanodeInfoProto() {
    *this = ::std::move(from);
  }

  inline DatanodeInfoProto& operator=(const DatanodeInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeInfoProto& operator=(DatanodeInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DatanodeInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatanodeInfoProto* internal_default_instance() {
    return reinterpret_cast<const DatanodeInfoProto*>(
               &_DatanodeInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DatanodeInfoProto& a, DatanodeInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DatanodeInfoProto* New() const final {
    return CreateMaybeMessage<DatanodeInfoProto>(nullptr);
  }

  DatanodeInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DatanodeInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DatanodeInfoProto& from);
  void MergeFrom(const DatanodeInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DatanodeInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DatanodeInfoProto_AdminState AdminState;
  static constexpr AdminState NORMAL =
    DatanodeInfoProto_AdminState_NORMAL;
  static constexpr AdminState DECOMMISSION_INPROGRESS =
    DatanodeInfoProto_AdminState_DECOMMISSION_INPROGRESS;
  static constexpr AdminState DECOMMISSIONED =
    DatanodeInfoProto_AdminState_DECOMMISSIONED;
  static inline bool AdminState_IsValid(int value) {
    return DatanodeInfoProto_AdminState_IsValid(value);
  }
  static constexpr AdminState AdminState_MIN =
    DatanodeInfoProto_AdminState_AdminState_MIN;
  static constexpr AdminState AdminState_MAX =
    DatanodeInfoProto_AdminState_AdminState_MAX;
  static constexpr int AdminState_ARRAYSIZE =
    DatanodeInfoProto_AdminState_AdminState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AdminState_descriptor() {
    return DatanodeInfoProto_AdminState_descriptor();
  }
  template<typename T>
  static inline const std::string& AdminState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdminState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdminState_Name.");
    return DatanodeInfoProto_AdminState_Name(enum_t_value);
  }
  static inline bool AdminState_Parse(const std::string& name,
      AdminState* value) {
    return DatanodeInfoProto_AdminState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 8,
    kIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kDfsUsedFieldNumber = 3,
    kRemainingFieldNumber = 4,
    kBlockPoolUsedFieldNumber = 5,
    kLastUpdateFieldNumber = 6,
    kXceiverCountFieldNumber = 7,
    kAdminStateFieldNumber = 10,
    kCacheCapacityFieldNumber = 11,
    kCacheUsedFieldNumber = 12,
  };
  // optional string location = 8;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  void set_location(const std::string& value);
  void set_location(std::string&& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  std::string* mutable_location();
  std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // required .Hdfs.Internal.DatanodeIDProto id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::Hdfs::Internal::DatanodeIDProto& id() const;
  ::Hdfs::Internal::DatanodeIDProto* release_id();
  ::Hdfs::Internal::DatanodeIDProto* mutable_id();
  void set_allocated_id(::Hdfs::Internal::DatanodeIDProto* id);
  private:
  const ::Hdfs::Internal::DatanodeIDProto& _internal_id() const;
  ::Hdfs::Internal::DatanodeIDProto* _internal_mutable_id();
  public:

  // optional uint64 capacity = 2 [default = 0];
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  ::PROTOBUF_NAMESPACE_ID::uint64 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_capacity() const;
  void _internal_set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 dfsUsed = 3 [default = 0];
  bool has_dfsused() const;
  private:
  bool _internal_has_dfsused() const;
  public:
  void clear_dfsused();
  ::PROTOBUF_NAMESPACE_ID::uint64 dfsused() const;
  void set_dfsused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_dfsused() const;
  void _internal_set_dfsused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 remaining = 4 [default = 0];
  bool has_remaining() const;
  private:
  bool _internal_has_remaining() const;
  public:
  void clear_remaining();
  ::PROTOBUF_NAMESPACE_ID::uint64 remaining() const;
  void set_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_remaining() const;
  void _internal_set_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 blockPoolUsed = 5 [default = 0];
  bool has_blockpoolused() const;
  private:
  bool _internal_has_blockpoolused() const;
  public:
  void clear_blockpoolused();
  ::PROTOBUF_NAMESPACE_ID::uint64 blockpoolused() const;
  void set_blockpoolused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blockpoolused() const;
  void _internal_set_blockpoolused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 lastUpdate = 6 [default = 0];
  bool has_lastupdate() const;
  private:
  bool _internal_has_lastupdate() const;
  public:
  void clear_lastupdate();
  ::PROTOBUF_NAMESPACE_ID::uint64 lastupdate() const;
  void set_lastupdate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_lastupdate() const;
  void _internal_set_lastupdate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 xceiverCount = 7 [default = 0];
  bool has_xceivercount() const;
  private:
  bool _internal_has_xceivercount() const;
  public:
  void clear_xceivercount();
  ::PROTOBUF_NAMESPACE_ID::uint32 xceivercount() const;
  void set_xceivercount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_xceivercount() const;
  void _internal_set_xceivercount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .Hdfs.Internal.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  bool has_adminstate() const;
  private:
  bool _internal_has_adminstate() const;
  public:
  void clear_adminstate();
  ::Hdfs::Internal::DatanodeInfoProto_AdminState adminstate() const;
  void set_adminstate(::Hdfs::Internal::DatanodeInfoProto_AdminState value);
  private:
  ::Hdfs::Internal::DatanodeInfoProto_AdminState _internal_adminstate() const;
  void _internal_set_adminstate(::Hdfs::Internal::DatanodeInfoProto_AdminState value);
  public:

  // optional uint64 cacheCapacity = 11 [default = 0];
  bool has_cachecapacity() const;
  private:
  bool _internal_has_cachecapacity() const;
  public:
  void clear_cachecapacity();
  ::PROTOBUF_NAMESPACE_ID::uint64 cachecapacity() const;
  void set_cachecapacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cachecapacity() const;
  void _internal_set_cachecapacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 cacheUsed = 12 [default = 0];
  bool has_cacheused() const;
  private:
  bool _internal_has_cacheused() const;
  public:
  void clear_cacheused();
  ::PROTOBUF_NAMESPACE_ID::uint64 cacheused() const;
  void set_cacheused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cacheused() const;
  void _internal_set_cacheused(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DatanodeInfoProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::Hdfs::Internal::DatanodeIDProto* id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dfsused_;
  ::PROTOBUF_NAMESPACE_ID::uint64 remaining_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blockpoolused_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lastupdate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 xceivercount_;
  int adminstate_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cachecapacity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cacheused_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class ContentSummaryProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ContentSummaryProto) */ {
 public:
  ContentSummaryProto();
  virtual ~ContentSummaryProto();

  ContentSummaryProto(const ContentSummaryProto& from);
  ContentSummaryProto(ContentSummaryProto&& from) noexcept
    : ContentSummaryProto() {
    *this = ::std::move(from);
  }

  inline ContentSummaryProto& operator=(const ContentSummaryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentSummaryProto& operator=(ContentSummaryProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContentSummaryProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContentSummaryProto* internal_default_instance() {
    return reinterpret_cast<const ContentSummaryProto*>(
               &_ContentSummaryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContentSummaryProto& a, ContentSummaryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentSummaryProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContentSummaryProto* New() const final {
    return CreateMaybeMessage<ContentSummaryProto>(nullptr);
  }

  ContentSummaryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContentSummaryProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContentSummaryProto& from);
  void MergeFrom(const ContentSummaryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContentSummaryProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ContentSummaryProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kFileCountFieldNumber = 2,
    kDirectoryCountFieldNumber = 3,
    kQuotaFieldNumber = 4,
    kSpaceConsumedFieldNumber = 5,
    kSpaceQuotaFieldNumber = 6,
  };
  // required uint64 length = 1;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_length() const;
  void _internal_set_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 fileCount = 2;
  bool has_filecount() const;
  private:
  bool _internal_has_filecount() const;
  public:
  void clear_filecount();
  ::PROTOBUF_NAMESPACE_ID::uint64 filecount() const;
  void set_filecount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_filecount() const;
  void _internal_set_filecount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 directoryCount = 3;
  bool has_directorycount() const;
  private:
  bool _internal_has_directorycount() const;
  public:
  void clear_directorycount();
  ::PROTOBUF_NAMESPACE_ID::uint64 directorycount() const;
  void set_directorycount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_directorycount() const;
  void _internal_set_directorycount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 quota = 4;
  bool has_quota() const;
  private:
  bool _internal_has_quota() const;
  public:
  void clear_quota();
  ::PROTOBUF_NAMESPACE_ID::uint64 quota() const;
  void set_quota(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_quota() const;
  void _internal_set_quota(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 spaceConsumed = 5;
  bool has_spaceconsumed() const;
  private:
  bool _internal_has_spaceconsumed() const;
  public:
  void clear_spaceconsumed();
  ::PROTOBUF_NAMESPACE_ID::uint64 spaceconsumed() const;
  void set_spaceconsumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_spaceconsumed() const;
  void _internal_set_spaceconsumed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 spaceQuota = 6;
  bool has_spacequota() const;
  private:
  bool _internal_has_spacequota() const;
  public:
  void clear_spacequota();
  ::PROTOBUF_NAMESPACE_ID::uint64 spacequota() const;
  void set_spacequota(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_spacequota() const;
  void _internal_set_spacequota(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ContentSummaryProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 length_;
  ::PROTOBUF_NAMESPACE_ID::uint64 filecount_;
  ::PROTOBUF_NAMESPACE_ID::uint64 directorycount_;
  ::PROTOBUF_NAMESPACE_ID::uint64 quota_;
  ::PROTOBUF_NAMESPACE_ID::uint64 spaceconsumed_;
  ::PROTOBUF_NAMESPACE_ID::uint64 spacequota_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class CorruptFileBlocksProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.CorruptFileBlocksProto) */ {
 public:
  CorruptFileBlocksProto();
  virtual ~CorruptFileBlocksProto();

  CorruptFileBlocksProto(const CorruptFileBlocksProto& from);
  CorruptFileBlocksProto(CorruptFileBlocksProto&& from) noexcept
    : CorruptFileBlocksProto() {
    *this = ::std::move(from);
  }

  inline CorruptFileBlocksProto& operator=(const CorruptFileBlocksProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorruptFileBlocksProto& operator=(CorruptFileBlocksProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CorruptFileBlocksProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CorruptFileBlocksProto* internal_default_instance() {
    return reinterpret_cast<const CorruptFileBlocksProto*>(
               &_CorruptFileBlocksProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CorruptFileBlocksProto& a, CorruptFileBlocksProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CorruptFileBlocksProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CorruptFileBlocksProto* New() const final {
    return CreateMaybeMessage<CorruptFileBlocksProto>(nullptr);
  }

  CorruptFileBlocksProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CorruptFileBlocksProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CorruptFileBlocksProto& from);
  void MergeFrom(const CorruptFileBlocksProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorruptFileBlocksProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.CorruptFileBlocksProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
    kCookieFieldNumber = 2,
  };
  // repeated string files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // required string cookie = 2;
  bool has_cookie() const;
  private:
  bool _internal_has_cookie() const;
  public:
  void clear_cookie();
  const std::string& cookie() const;
  void set_cookie(const std::string& value);
  void set_cookie(std::string&& value);
  void set_cookie(const char* value);
  void set_cookie(const char* value, size_t size);
  std::string* mutable_cookie();
  std::string* release_cookie();
  void set_allocated_cookie(std::string* cookie);
  private:
  const std::string& _internal_cookie() const;
  void _internal_set_cookie(const std::string& value);
  std::string* _internal_mutable_cookie();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.CorruptFileBlocksProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cookie_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class FsPermissionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.FsPermissionProto) */ {
 public:
  FsPermissionProto();
  virtual ~FsPermissionProto();

  FsPermissionProto(const FsPermissionProto& from);
  FsPermissionProto(FsPermissionProto&& from) noexcept
    : FsPermissionProto() {
    *this = ::std::move(from);
  }

  inline FsPermissionProto& operator=(const FsPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsPermissionProto& operator=(FsPermissionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FsPermissionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FsPermissionProto* internal_default_instance() {
    return reinterpret_cast<const FsPermissionProto*>(
               &_FsPermissionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FsPermissionProto& a, FsPermissionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FsPermissionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FsPermissionProto* New() const final {
    return CreateMaybeMessage<FsPermissionProto>(nullptr);
  }

  FsPermissionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FsPermissionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FsPermissionProto& from);
  void MergeFrom(const FsPermissionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsPermissionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.FsPermissionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermFieldNumber = 1,
  };
  // required uint32 perm = 1;
  bool has_perm() const;
  private:
  bool _internal_has_perm() const;
  public:
  void clear_perm();
  ::PROTOBUF_NAMESPACE_ID::uint32 perm() const;
  void set_perm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_perm() const;
  void _internal_set_perm(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.FsPermissionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 perm_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class StorageUuidsProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.StorageUuidsProto) */ {
 public:
  StorageUuidsProto();
  virtual ~StorageUuidsProto();

  StorageUuidsProto(const StorageUuidsProto& from);
  StorageUuidsProto(StorageUuidsProto&& from) noexcept
    : StorageUuidsProto() {
    *this = ::std::move(from);
  }

  inline StorageUuidsProto& operator=(const StorageUuidsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageUuidsProto& operator=(StorageUuidsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StorageUuidsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageUuidsProto* internal_default_instance() {
    return reinterpret_cast<const StorageUuidsProto*>(
               &_StorageUuidsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StorageUuidsProto& a, StorageUuidsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageUuidsProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StorageUuidsProto* New() const final {
    return CreateMaybeMessage<StorageUuidsProto>(nullptr);
  }

  StorageUuidsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StorageUuidsProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StorageUuidsProto& from);
  void MergeFrom(const StorageUuidsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageUuidsProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.StorageUuidsProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageUuidsFieldNumber = 1,
  };
  // repeated string storageUuids = 1;
  int storageuuids_size() const;
  private:
  int _internal_storageuuids_size() const;
  public:
  void clear_storageuuids();
  const std::string& storageuuids(int index) const;
  std::string* mutable_storageuuids(int index);
  void set_storageuuids(int index, const std::string& value);
  void set_storageuuids(int index, std::string&& value);
  void set_storageuuids(int index, const char* value);
  void set_storageuuids(int index, const char* value, size_t size);
  std::string* add_storageuuids();
  void add_storageuuids(const std::string& value);
  void add_storageuuids(std::string&& value);
  void add_storageuuids(const char* value);
  void add_storageuuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& storageuuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_storageuuids();
  private:
  const std::string& _internal_storageuuids(int index) const;
  std::string* _internal_add_storageuuids();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.StorageUuidsProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> storageuuids_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.LocatedBlockProto) */ {
 public:
  LocatedBlockProto();
  virtual ~LocatedBlockProto();

  LocatedBlockProto(const LocatedBlockProto& from);
  LocatedBlockProto(LocatedBlockProto&& from) noexcept
    : LocatedBlockProto() {
    *this = ::std::move(from);
  }

  inline LocatedBlockProto& operator=(const LocatedBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlockProto& operator=(LocatedBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlockProto* internal_default_instance() {
    return reinterpret_cast<const LocatedBlockProto*>(
               &_LocatedBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LocatedBlockProto& a, LocatedBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlockProto* New() const final {
    return CreateMaybeMessage<LocatedBlockProto>(nullptr);
  }

  LocatedBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlockProto& from);
  void MergeFrom(const LocatedBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.LocatedBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocsFieldNumber = 3,
    kIsCachedFieldNumber = 6,
    kStorageTypesFieldNumber = 7,
    kStorageIDsFieldNumber = 8,
    kBFieldNumber = 1,
    kBlockTokenFieldNumber = 5,
    kOffsetFieldNumber = 2,
    kCorruptFieldNumber = 4,
  };
  // repeated .Hdfs.Internal.DatanodeInfoProto locs = 3;
  int locs_size() const;
  private:
  int _internal_locs_size() const;
  public:
  void clear_locs();
  ::Hdfs::Internal::DatanodeInfoProto* mutable_locs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
      mutable_locs();
  private:
  const ::Hdfs::Internal::DatanodeInfoProto& _internal_locs(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* _internal_add_locs();
  public:
  const ::Hdfs::Internal::DatanodeInfoProto& locs(int index) const;
  ::Hdfs::Internal::DatanodeInfoProto* add_locs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
      locs() const;

  // repeated bool isCached = 6 [packed = true];
  int iscached_size() const;
  private:
  int _internal_iscached_size() const;
  public:
  void clear_iscached();
  private:
  bool _internal_iscached(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_iscached() const;
  void _internal_add_iscached(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_iscached();
  public:
  bool iscached(int index) const;
  void set_iscached(int index, bool value);
  void add_iscached(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      iscached() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_iscached();

  // repeated .Hdfs.Internal.StorageTypeProto storageTypes = 7;
  int storagetypes_size() const;
  private:
  int _internal_storagetypes_size() const;
  public:
  void clear_storagetypes();
  private:
  ::Hdfs::Internal::StorageTypeProto _internal_storagetypes(int index) const;
  void _internal_add_storagetypes(::Hdfs::Internal::StorageTypeProto value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_storagetypes();
  public:
  ::Hdfs::Internal::StorageTypeProto storagetypes(int index) const;
  void set_storagetypes(int index, ::Hdfs::Internal::StorageTypeProto value);
  void add_storagetypes(::Hdfs::Internal::StorageTypeProto value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& storagetypes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_storagetypes();

  // repeated string storageIDs = 8;
  int storageids_size() const;
  private:
  int _internal_storageids_size() const;
  public:
  void clear_storageids();
  const std::string& storageids(int index) const;
  std::string* mutable_storageids(int index);
  void set_storageids(int index, const std::string& value);
  void set_storageids(int index, std::string&& value);
  void set_storageids(int index, const char* value);
  void set_storageids(int index, const char* value, size_t size);
  std::string* add_storageids();
  void add_storageids(const std::string& value);
  void add_storageids(std::string&& value);
  void add_storageids(const char* value);
  void add_storageids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& storageids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_storageids();
  private:
  const std::string& _internal_storageids(int index) const;
  std::string* _internal_add_storageids();
  public:

  // required .Hdfs.Internal.ExtendedBlockProto b = 1;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const ::Hdfs::Internal::ExtendedBlockProto& b() const;
  ::Hdfs::Internal::ExtendedBlockProto* release_b();
  ::Hdfs::Internal::ExtendedBlockProto* mutable_b();
  void set_allocated_b(::Hdfs::Internal::ExtendedBlockProto* b);
  private:
  const ::Hdfs::Internal::ExtendedBlockProto& _internal_b() const;
  ::Hdfs::Internal::ExtendedBlockProto* _internal_mutable_b();
  public:

  // required .Hdfs.Internal.TokenProto blockToken = 5;
  bool has_blocktoken() const;
  private:
  bool _internal_has_blocktoken() const;
  public:
  void clear_blocktoken();
  const ::Hdfs::Internal::TokenProto& blocktoken() const;
  ::Hdfs::Internal::TokenProto* release_blocktoken();
  ::Hdfs::Internal::TokenProto* mutable_blocktoken();
  void set_allocated_blocktoken(::Hdfs::Internal::TokenProto* blocktoken);
  private:
  const ::Hdfs::Internal::TokenProto& _internal_blocktoken() const;
  ::Hdfs::Internal::TokenProto* _internal_mutable_blocktoken();
  public:

  // required uint64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required bool corrupt = 4;
  bool has_corrupt() const;
  private:
  bool _internal_has_corrupt() const;
  public:
  void clear_corrupt();
  bool corrupt() const;
  void set_corrupt(bool value);
  private:
  bool _internal_corrupt() const;
  void _internal_set_corrupt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.LocatedBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto > locs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > iscached_;
  mutable std::atomic<int> _iscached_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> storagetypes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> storageids_;
  ::Hdfs::Internal::ExtendedBlockProto* b_;
  ::Hdfs::Internal::TokenProto* blocktoken_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  bool corrupt_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class DataEncryptionKeyProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DataEncryptionKeyProto) */ {
 public:
  DataEncryptionKeyProto();
  virtual ~DataEncryptionKeyProto();

  DataEncryptionKeyProto(const DataEncryptionKeyProto& from);
  DataEncryptionKeyProto(DataEncryptionKeyProto&& from) noexcept
    : DataEncryptionKeyProto() {
    *this = ::std::move(from);
  }

  inline DataEncryptionKeyProto& operator=(const DataEncryptionKeyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataEncryptionKeyProto& operator=(DataEncryptionKeyProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataEncryptionKeyProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataEncryptionKeyProto* internal_default_instance() {
    return reinterpret_cast<const DataEncryptionKeyProto*>(
               &_DataEncryptionKeyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataEncryptionKeyProto& a, DataEncryptionKeyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DataEncryptionKeyProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataEncryptionKeyProto* New() const final {
    return CreateMaybeMessage<DataEncryptionKeyProto>(nullptr);
  }

  DataEncryptionKeyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataEncryptionKeyProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataEncryptionKeyProto& from);
  void MergeFrom(const DataEncryptionKeyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataEncryptionKeyProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DataEncryptionKeyProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockPoolIdFieldNumber = 2,
    kNonceFieldNumber = 3,
    kEncryptionKeyFieldNumber = 4,
    kEncryptionAlgorithmFieldNumber = 6,
    kExpiryDateFieldNumber = 5,
    kKeyIdFieldNumber = 1,
  };
  // required string blockPoolId = 2;
  bool has_blockpoolid() const;
  private:
  bool _internal_has_blockpoolid() const;
  public:
  void clear_blockpoolid();
  const std::string& blockpoolid() const;
  void set_blockpoolid(const std::string& value);
  void set_blockpoolid(std::string&& value);
  void set_blockpoolid(const char* value);
  void set_blockpoolid(const char* value, size_t size);
  std::string* mutable_blockpoolid();
  std::string* release_blockpoolid();
  void set_allocated_blockpoolid(std::string* blockpoolid);
  private:
  const std::string& _internal_blockpoolid() const;
  void _internal_set_blockpoolid(const std::string& value);
  std::string* _internal_mutable_blockpoolid();
  public:

  // required bytes nonce = 3;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  const std::string& nonce() const;
  void set_nonce(const std::string& value);
  void set_nonce(std::string&& value);
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  std::string* mutable_nonce();
  std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // required bytes encryptionKey = 4;
  bool has_encryptionkey() const;
  private:
  bool _internal_has_encryptionkey() const;
  public:
  void clear_encryptionkey();
  const std::string& encryptionkey() const;
  void set_encryptionkey(const std::string& value);
  void set_encryptionkey(std::string&& value);
  void set_encryptionkey(const char* value);
  void set_encryptionkey(const void* value, size_t size);
  std::string* mutable_encryptionkey();
  std::string* release_encryptionkey();
  void set_allocated_encryptionkey(std::string* encryptionkey);
  private:
  const std::string& _internal_encryptionkey() const;
  void _internal_set_encryptionkey(const std::string& value);
  std::string* _internal_mutable_encryptionkey();
  public:

  // optional string encryptionAlgorithm = 6;
  bool has_encryptionalgorithm() const;
  private:
  bool _internal_has_encryptionalgorithm() const;
  public:
  void clear_encryptionalgorithm();
  const std::string& encryptionalgorithm() const;
  void set_encryptionalgorithm(const std::string& value);
  void set_encryptionalgorithm(std::string&& value);
  void set_encryptionalgorithm(const char* value);
  void set_encryptionalgorithm(const char* value, size_t size);
  std::string* mutable_encryptionalgorithm();
  std::string* release_encryptionalgorithm();
  void set_allocated_encryptionalgorithm(std::string* encryptionalgorithm);
  private:
  const std::string& _internal_encryptionalgorithm() const;
  void _internal_set_encryptionalgorithm(const std::string& value);
  std::string* _internal_mutable_encryptionalgorithm();
  public:

  // required uint64 expiryDate = 5;
  bool has_expirydate() const;
  private:
  bool _internal_has_expirydate() const;
  public:
  void clear_expirydate();
  ::PROTOBUF_NAMESPACE_ID::uint64 expirydate() const;
  void set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_expirydate() const;
  void _internal_set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 keyId = 1;
  bool has_keyid() const;
  private:
  bool _internal_has_keyid() const;
  public:
  void clear_keyid();
  ::PROTOBUF_NAMESPACE_ID::uint32 keyid() const;
  void set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_keyid() const;
  void _internal_set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DataEncryptionKeyProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockpoolid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryptionkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryptionalgorithm_;
  ::PROTOBUF_NAMESPACE_ID::uint64 expirydate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 keyid_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class FileEncryptionInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.FileEncryptionInfoProto) */ {
 public:
  FileEncryptionInfoProto();
  virtual ~FileEncryptionInfoProto();

  FileEncryptionInfoProto(const FileEncryptionInfoProto& from);
  FileEncryptionInfoProto(FileEncryptionInfoProto&& from) noexcept
    : FileEncryptionInfoProto() {
    *this = ::std::move(from);
  }

  inline FileEncryptionInfoProto& operator=(const FileEncryptionInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileEncryptionInfoProto& operator=(FileEncryptionInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileEncryptionInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileEncryptionInfoProto* internal_default_instance() {
    return reinterpret_cast<const FileEncryptionInfoProto*>(
               &_FileEncryptionInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FileEncryptionInfoProto& a, FileEncryptionInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FileEncryptionInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileEncryptionInfoProto* New() const final {
    return CreateMaybeMessage<FileEncryptionInfoProto>(nullptr);
  }

  FileEncryptionInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileEncryptionInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileEncryptionInfoProto& from);
  void MergeFrom(const FileEncryptionInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileEncryptionInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.FileEncryptionInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 3,
    kIvFieldNumber = 4,
    kKeyNameFieldNumber = 5,
    kEzKeyVersionNameFieldNumber = 6,
    kSuiteFieldNumber = 1,
    kCryptoProtocolVersionFieldNumber = 2,
  };
  // required bytes key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required bytes iv = 4;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  void set_iv(const std::string& value);
  void set_iv(std::string&& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  std::string* mutable_iv();
  std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // required string keyName = 5;
  bool has_keyname() const;
  private:
  bool _internal_has_keyname() const;
  public:
  void clear_keyname();
  const std::string& keyname() const;
  void set_keyname(const std::string& value);
  void set_keyname(std::string&& value);
  void set_keyname(const char* value);
  void set_keyname(const char* value, size_t size);
  std::string* mutable_keyname();
  std::string* release_keyname();
  void set_allocated_keyname(std::string* keyname);
  private:
  const std::string& _internal_keyname() const;
  void _internal_set_keyname(const std::string& value);
  std::string* _internal_mutable_keyname();
  public:

  // required string ezKeyVersionName = 6;
  bool has_ezkeyversionname() const;
  private:
  bool _internal_has_ezkeyversionname() const;
  public:
  void clear_ezkeyversionname();
  const std::string& ezkeyversionname() const;
  void set_ezkeyversionname(const std::string& value);
  void set_ezkeyversionname(std::string&& value);
  void set_ezkeyversionname(const char* value);
  void set_ezkeyversionname(const char* value, size_t size);
  std::string* mutable_ezkeyversionname();
  std::string* release_ezkeyversionname();
  void set_allocated_ezkeyversionname(std::string* ezkeyversionname);
  private:
  const std::string& _internal_ezkeyversionname() const;
  void _internal_set_ezkeyversionname(const std::string& value);
  std::string* _internal_mutable_ezkeyversionname();
  public:

  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  bool has_suite() const;
  private:
  bool _internal_has_suite() const;
  public:
  void clear_suite();
  ::Hdfs::Internal::CipherSuiteProto suite() const;
  void set_suite(::Hdfs::Internal::CipherSuiteProto value);
  private:
  ::Hdfs::Internal::CipherSuiteProto _internal_suite() const;
  void _internal_set_suite(::Hdfs::Internal::CipherSuiteProto value);
  public:

  // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion = 2;
  bool has_cryptoprotocolversion() const;
  private:
  bool _internal_has_cryptoprotocolversion() const;
  public:
  void clear_cryptoprotocolversion();
  ::Hdfs::Internal::CryptoProtocolVersionProto cryptoprotocolversion() const;
  void set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value);
  private:
  ::Hdfs::Internal::CryptoProtocolVersionProto _internal_cryptoprotocolversion() const;
  void _internal_set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.FileEncryptionInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ezkeyversionname_;
  int suite_;
  int cryptoprotocolversion_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class PerFileEncryptionInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.PerFileEncryptionInfoProto) */ {
 public:
  PerFileEncryptionInfoProto();
  virtual ~PerFileEncryptionInfoProto();

  PerFileEncryptionInfoProto(const PerFileEncryptionInfoProto& from);
  PerFileEncryptionInfoProto(PerFileEncryptionInfoProto&& from) noexcept
    : PerFileEncryptionInfoProto() {
    *this = ::std::move(from);
  }

  inline PerFileEncryptionInfoProto& operator=(const PerFileEncryptionInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerFileEncryptionInfoProto& operator=(PerFileEncryptionInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PerFileEncryptionInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerFileEncryptionInfoProto* internal_default_instance() {
    return reinterpret_cast<const PerFileEncryptionInfoProto*>(
               &_PerFileEncryptionInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PerFileEncryptionInfoProto& a, PerFileEncryptionInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(PerFileEncryptionInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PerFileEncryptionInfoProto* New() const final {
    return CreateMaybeMessage<PerFileEncryptionInfoProto>(nullptr);
  }

  PerFileEncryptionInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PerFileEncryptionInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PerFileEncryptionInfoProto& from);
  void MergeFrom(const PerFileEncryptionInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerFileEncryptionInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.PerFileEncryptionInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIvFieldNumber = 2,
    kEzKeyVersionNameFieldNumber = 3,
  };
  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required bytes iv = 2;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  void set_iv(const std::string& value);
  void set_iv(std::string&& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  std::string* mutable_iv();
  std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // required string ezKeyVersionName = 3;
  bool has_ezkeyversionname() const;
  private:
  bool _internal_has_ezkeyversionname() const;
  public:
  void clear_ezkeyversionname();
  const std::string& ezkeyversionname() const;
  void set_ezkeyversionname(const std::string& value);
  void set_ezkeyversionname(std::string&& value);
  void set_ezkeyversionname(const char* value);
  void set_ezkeyversionname(const char* value, size_t size);
  std::string* mutable_ezkeyversionname();
  std::string* release_ezkeyversionname();
  void set_allocated_ezkeyversionname(std::string* ezkeyversionname);
  private:
  const std::string& _internal_ezkeyversionname() const;
  void _internal_set_ezkeyversionname(const std::string& value);
  std::string* _internal_mutable_ezkeyversionname();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.PerFileEncryptionInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ezkeyversionname_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class ZoneEncryptionInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ZoneEncryptionInfoProto) */ {
 public:
  ZoneEncryptionInfoProto();
  virtual ~ZoneEncryptionInfoProto();

  ZoneEncryptionInfoProto(const ZoneEncryptionInfoProto& from);
  ZoneEncryptionInfoProto(ZoneEncryptionInfoProto&& from) noexcept
    : ZoneEncryptionInfoProto() {
    *this = ::std::move(from);
  }

  inline ZoneEncryptionInfoProto& operator=(const ZoneEncryptionInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneEncryptionInfoProto& operator=(ZoneEncryptionInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ZoneEncryptionInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ZoneEncryptionInfoProto* internal_default_instance() {
    return reinterpret_cast<const ZoneEncryptionInfoProto*>(
               &_ZoneEncryptionInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ZoneEncryptionInfoProto& a, ZoneEncryptionInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneEncryptionInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZoneEncryptionInfoProto* New() const final {
    return CreateMaybeMessage<ZoneEncryptionInfoProto>(nullptr);
  }

  ZoneEncryptionInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZoneEncryptionInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ZoneEncryptionInfoProto& from);
  void MergeFrom(const ZoneEncryptionInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoneEncryptionInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ZoneEncryptionInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyNameFieldNumber = 3,
    kSuiteFieldNumber = 1,
    kCryptoProtocolVersionFieldNumber = 2,
  };
  // required string keyName = 3;
  bool has_keyname() const;
  private:
  bool _internal_has_keyname() const;
  public:
  void clear_keyname();
  const std::string& keyname() const;
  void set_keyname(const std::string& value);
  void set_keyname(std::string&& value);
  void set_keyname(const char* value);
  void set_keyname(const char* value, size_t size);
  std::string* mutable_keyname();
  std::string* release_keyname();
  void set_allocated_keyname(std::string* keyname);
  private:
  const std::string& _internal_keyname() const;
  void _internal_set_keyname(const std::string& value);
  std::string* _internal_mutable_keyname();
  public:

  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  bool has_suite() const;
  private:
  bool _internal_has_suite() const;
  public:
  void clear_suite();
  ::Hdfs::Internal::CipherSuiteProto suite() const;
  void set_suite(::Hdfs::Internal::CipherSuiteProto value);
  private:
  ::Hdfs::Internal::CipherSuiteProto _internal_suite() const;
  void _internal_set_suite(::Hdfs::Internal::CipherSuiteProto value);
  public:

  // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion = 2;
  bool has_cryptoprotocolversion() const;
  private:
  bool _internal_has_cryptoprotocolversion() const;
  public:
  void clear_cryptoprotocolversion();
  ::Hdfs::Internal::CryptoProtocolVersionProto cryptoprotocolversion() const;
  void set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value);
  private:
  ::Hdfs::Internal::CryptoProtocolVersionProto _internal_cryptoprotocolversion() const;
  void _internal_set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ZoneEncryptionInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyname_;
  int suite_;
  int cryptoprotocolversion_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class CipherOptionProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.CipherOptionProto) */ {
 public:
  CipherOptionProto();
  virtual ~CipherOptionProto();

  CipherOptionProto(const CipherOptionProto& from);
  CipherOptionProto(CipherOptionProto&& from) noexcept
    : CipherOptionProto() {
    *this = ::std::move(from);
  }

  inline CipherOptionProto& operator=(const CipherOptionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CipherOptionProto& operator=(CipherOptionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CipherOptionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CipherOptionProto* internal_default_instance() {
    return reinterpret_cast<const CipherOptionProto*>(
               &_CipherOptionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CipherOptionProto& a, CipherOptionProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CipherOptionProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CipherOptionProto* New() const final {
    return CreateMaybeMessage<CipherOptionProto>(nullptr);
  }

  CipherOptionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CipherOptionProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CipherOptionProto& from);
  void MergeFrom(const CipherOptionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CipherOptionProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.CipherOptionProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInKeyFieldNumber = 2,
    kInIvFieldNumber = 3,
    kOutKeyFieldNumber = 4,
    kOutIvFieldNumber = 5,
    kSuiteFieldNumber = 1,
  };
  // optional bytes inKey = 2;
  bool has_inkey() const;
  private:
  bool _internal_has_inkey() const;
  public:
  void clear_inkey();
  const std::string& inkey() const;
  void set_inkey(const std::string& value);
  void set_inkey(std::string&& value);
  void set_inkey(const char* value);
  void set_inkey(const void* value, size_t size);
  std::string* mutable_inkey();
  std::string* release_inkey();
  void set_allocated_inkey(std::string* inkey);
  private:
  const std::string& _internal_inkey() const;
  void _internal_set_inkey(const std::string& value);
  std::string* _internal_mutable_inkey();
  public:

  // optional bytes inIv = 3;
  bool has_iniv() const;
  private:
  bool _internal_has_iniv() const;
  public:
  void clear_iniv();
  const std::string& iniv() const;
  void set_iniv(const std::string& value);
  void set_iniv(std::string&& value);
  void set_iniv(const char* value);
  void set_iniv(const void* value, size_t size);
  std::string* mutable_iniv();
  std::string* release_iniv();
  void set_allocated_iniv(std::string* iniv);
  private:
  const std::string& _internal_iniv() const;
  void _internal_set_iniv(const std::string& value);
  std::string* _internal_mutable_iniv();
  public:

  // optional bytes outKey = 4;
  bool has_outkey() const;
  private:
  bool _internal_has_outkey() const;
  public:
  void clear_outkey();
  const std::string& outkey() const;
  void set_outkey(const std::string& value);
  void set_outkey(std::string&& value);
  void set_outkey(const char* value);
  void set_outkey(const void* value, size_t size);
  std::string* mutable_outkey();
  std::string* release_outkey();
  void set_allocated_outkey(std::string* outkey);
  private:
  const std::string& _internal_outkey() const;
  void _internal_set_outkey(const std::string& value);
  std::string* _internal_mutable_outkey();
  public:

  // optional bytes outIv = 5;
  bool has_outiv() const;
  private:
  bool _internal_has_outiv() const;
  public:
  void clear_outiv();
  const std::string& outiv() const;
  void set_outiv(const std::string& value);
  void set_outiv(std::string&& value);
  void set_outiv(const char* value);
  void set_outiv(const void* value, size_t size);
  std::string* mutable_outiv();
  std::string* release_outiv();
  void set_allocated_outiv(std::string* outiv);
  private:
  const std::string& _internal_outiv() const;
  void _internal_set_outiv(const std::string& value);
  std::string* _internal_mutable_outiv();
  public:

  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  bool has_suite() const;
  private:
  bool _internal_has_suite() const;
  public:
  void clear_suite();
  ::Hdfs::Internal::CipherSuiteProto suite() const;
  void set_suite(::Hdfs::Internal::CipherSuiteProto value);
  private:
  ::Hdfs::Internal::CipherSuiteProto _internal_suite() const;
  void _internal_set_suite(::Hdfs::Internal::CipherSuiteProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.CipherOptionProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iniv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outiv_;
  int suite_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlocksProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.LocatedBlocksProto) */ {
 public:
  LocatedBlocksProto();
  virtual ~LocatedBlocksProto();

  LocatedBlocksProto(const LocatedBlocksProto& from);
  LocatedBlocksProto(LocatedBlocksProto&& from) noexcept
    : LocatedBlocksProto() {
    *this = ::std::move(from);
  }

  inline LocatedBlocksProto& operator=(const LocatedBlocksProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlocksProto& operator=(LocatedBlocksProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocatedBlocksProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocatedBlocksProto* internal_default_instance() {
    return reinterpret_cast<const LocatedBlocksProto*>(
               &_LocatedBlocksProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LocatedBlocksProto& a, LocatedBlocksProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlocksProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocatedBlocksProto* New() const final {
    return CreateMaybeMessage<LocatedBlocksProto>(nullptr);
  }

  LocatedBlocksProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocatedBlocksProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocatedBlocksProto& from);
  void MergeFrom(const LocatedBlocksProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlocksProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.LocatedBlocksProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 2,
    kLastBlockFieldNumber = 4,
    kFileLengthFieldNumber = 1,
    kUnderConstructionFieldNumber = 3,
    kIsLastBlockCompleteFieldNumber = 5,
  };
  // repeated .Hdfs.Internal.LocatedBlockProto blocks = 2;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::Hdfs::Internal::LocatedBlockProto* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::LocatedBlockProto >*
      mutable_blocks();
  private:
  const ::Hdfs::Internal::LocatedBlockProto& _internal_blocks(int index) const;
  ::Hdfs::Internal::LocatedBlockProto* _internal_add_blocks();
  public:
  const ::Hdfs::Internal::LocatedBlockProto& blocks(int index) const;
  ::Hdfs::Internal::LocatedBlockProto* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::LocatedBlockProto >&
      blocks() const;

  // optional .Hdfs.Internal.LocatedBlockProto lastBlock = 4;
  bool has_lastblock() const;
  private:
  bool _internal_has_lastblock() const;
  public:
  void clear_lastblock();
  const ::Hdfs::Internal::LocatedBlockProto& lastblock() const;
  ::Hdfs::Internal::LocatedBlockProto* release_lastblock();
  ::Hdfs::Internal::LocatedBlockProto* mutable_lastblock();
  void set_allocated_lastblock(::Hdfs::Internal::LocatedBlockProto* lastblock);
  private:
  const ::Hdfs::Internal::LocatedBlockProto& _internal_lastblock() const;
  ::Hdfs::Internal::LocatedBlockProto* _internal_mutable_lastblock();
  public:

  // required uint64 fileLength = 1;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  ::PROTOBUF_NAMESPACE_ID::uint64 filelength() const;
  void set_filelength(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_filelength() const;
  void _internal_set_filelength(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required bool underConstruction = 3;
  bool has_underconstruction() const;
  private:
  bool _internal_has_underconstruction() const;
  public:
  void clear_underconstruction();
  bool underconstruction() const;
  void set_underconstruction(bool value);
  private:
  bool _internal_underconstruction() const;
  void _internal_set_underconstruction(bool value);
  public:

  // required bool isLastBlockComplete = 5;
  bool has_islastblockcomplete() const;
  private:
  bool _internal_has_islastblockcomplete() const;
  public:
  void clear_islastblockcomplete();
  bool islastblockcomplete() const;
  void set_islastblockcomplete(bool value);
  private:
  bool _internal_islastblockcomplete() const;
  void _internal_set_islastblockcomplete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.LocatedBlocksProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::LocatedBlockProto > blocks_;
  ::Hdfs::Internal::LocatedBlockProto* lastblock_;
  ::PROTOBUF_NAMESPACE_ID::uint64 filelength_;
  bool underconstruction_;
  bool islastblockcomplete_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class HdfsFileStatusProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.HdfsFileStatusProto) */ {
 public:
  HdfsFileStatusProto();
  virtual ~HdfsFileStatusProto();

  HdfsFileStatusProto(const HdfsFileStatusProto& from);
  HdfsFileStatusProto(HdfsFileStatusProto&& from) noexcept
    : HdfsFileStatusProto() {
    *this = ::std::move(from);
  }

  inline HdfsFileStatusProto& operator=(const HdfsFileStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline HdfsFileStatusProto& operator=(HdfsFileStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HdfsFileStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HdfsFileStatusProto* internal_default_instance() {
    return reinterpret_cast<const HdfsFileStatusProto*>(
               &_HdfsFileStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HdfsFileStatusProto& a, HdfsFileStatusProto& b) {
    a.Swap(&b);
  }
  inline void Swap(HdfsFileStatusProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HdfsFileStatusProto* New() const final {
    return CreateMaybeMessage<HdfsFileStatusProto>(nullptr);
  }

  HdfsFileStatusProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HdfsFileStatusProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HdfsFileStatusProto& from);
  void MergeFrom(const HdfsFileStatusProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HdfsFileStatusProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.HdfsFileStatusProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HdfsFileStatusProto_FileType FileType;
  static constexpr FileType IS_DIR =
    HdfsFileStatusProto_FileType_IS_DIR;
  static constexpr FileType IS_FILE =
    HdfsFileStatusProto_FileType_IS_FILE;
  static constexpr FileType IS_SYMLINK =
    HdfsFileStatusProto_FileType_IS_SYMLINK;
  static inline bool FileType_IsValid(int value) {
    return HdfsFileStatusProto_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN =
    HdfsFileStatusProto_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX =
    HdfsFileStatusProto_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE =
    HdfsFileStatusProto_FileType_FileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileType_descriptor() {
    return HdfsFileStatusProto_FileType_descriptor();
  }
  template<typename T>
  static inline const std::string& FileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileType_Name.");
    return HdfsFileStatusProto_FileType_Name(enum_t_value);
  }
  static inline bool FileType_Parse(const std::string& name,
      FileType* value) {
    return HdfsFileStatusProto_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOwnerFieldNumber = 5,
    kGroupFieldNumber = 6,
    kSymlinkFieldNumber = 9,
    kPermissionFieldNumber = 4,
    kLocationsFieldNumber = 12,
    kFileEncryptionInfoFieldNumber = 15,
    kLengthFieldNumber = 3,
    kModificationTimeFieldNumber = 7,
    kAccessTimeFieldNumber = 8,
    kBlocksizeFieldNumber = 11,
    kFileIdFieldNumber = 13,
    kBlockReplicationFieldNumber = 10,
    kFileTypeFieldNumber = 1,
    kChildrenNumFieldNumber = 14,
  };
  // required bytes path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const void* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // required string owner = 5;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // required string group = 6;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional bytes symlink = 9;
  bool has_symlink() const;
  private:
  bool _internal_has_symlink() const;
  public:
  void clear_symlink();
  const std::string& symlink() const;
  void set_symlink(const std::string& value);
  void set_symlink(std::string&& value);
  void set_symlink(const char* value);
  void set_symlink(const void* value, size_t size);
  std::string* mutable_symlink();
  std::string* release_symlink();
  void set_allocated_symlink(std::string* symlink);
  private:
  const std::string& _internal_symlink() const;
  void _internal_set_symlink(const std::string& value);
  std::string* _internal_mutable_symlink();
  public:

  // required .Hdfs.Internal.FsPermissionProto permission = 4;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Hdfs::Internal::FsPermissionProto& permission() const;
  ::Hdfs::Internal::FsPermissionProto* release_permission();
  ::Hdfs::Internal::FsPermissionProto* mutable_permission();
  void set_allocated_permission(::Hdfs::Internal::FsPermissionProto* permission);
  private:
  const ::Hdfs::Internal::FsPermissionProto& _internal_permission() const;
  ::Hdfs::Internal::FsPermissionProto* _internal_mutable_permission();
  public:

  // optional .Hdfs.Internal.LocatedBlocksProto locations = 12;
  bool has_locations() const;
  private:
  bool _internal_has_locations() const;
  public:
  void clear_locations();
  const ::Hdfs::Internal::LocatedBlocksProto& locations() const;
  ::Hdfs::Internal::LocatedBlocksProto* release_locations();
  ::Hdfs::Internal::LocatedBlocksProto* mutable_locations();
  void set_allocated_locations(::Hdfs::Internal::LocatedBlocksProto* locations);
  private:
  const ::Hdfs::Internal::LocatedBlocksProto& _internal_locations() const;
  ::Hdfs::Internal::LocatedBlocksProto* _internal_mutable_locations();
  public:

  // optional .Hdfs.Internal.FileEncryptionInfoProto fileEncryptionInfo = 15;
  bool has_fileencryptioninfo() const;
  private:
  bool _internal_has_fileencryptioninfo() const;
  public:
  void clear_fileencryptioninfo();
  const ::Hdfs::Internal::FileEncryptionInfoProto& fileencryptioninfo() const;
  ::Hdfs::Internal::FileEncryptionInfoProto* release_fileencryptioninfo();
  ::Hdfs::Internal::FileEncryptionInfoProto* mutable_fileencryptioninfo();
  void set_allocated_fileencryptioninfo(::Hdfs::Internal::FileEncryptionInfoProto* fileencryptioninfo);
  private:
  const ::Hdfs::Internal::FileEncryptionInfoProto& _internal_fileencryptioninfo() const;
  ::Hdfs::Internal::FileEncryptionInfoProto* _internal_mutable_fileencryptioninfo();
  public:

  // required uint64 length = 3;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_length() const;
  void _internal_set_length(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 modification_time = 7;
  bool has_modification_time() const;
  private:
  bool _internal_has_modification_time() const;
  public:
  void clear_modification_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 modification_time() const;
  void set_modification_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_modification_time() const;
  void _internal_set_modification_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 access_time = 8;
  bool has_access_time() const;
  private:
  bool _internal_has_access_time() const;
  public:
  void clear_access_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 access_time() const;
  void set_access_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_access_time() const;
  void _internal_set_access_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 blocksize = 11 [default = 0];
  bool has_blocksize() const;
  private:
  bool _internal_has_blocksize() const;
  public:
  void clear_blocksize();
  ::PROTOBUF_NAMESPACE_ID::uint64 blocksize() const;
  void set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blocksize() const;
  void _internal_set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 fileId = 13 [default = 0];
  bool has_fileid() const;
  private:
  bool _internal_has_fileid() const;
  public:
  void clear_fileid();
  ::PROTOBUF_NAMESPACE_ID::uint64 fileid() const;
  void set_fileid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fileid() const;
  void _internal_set_fileid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 block_replication = 10 [default = 0];
  bool has_block_replication() const;
  private:
  bool _internal_has_block_replication() const;
  public:
  void clear_block_replication();
  ::PROTOBUF_NAMESPACE_ID::uint32 block_replication() const;
  void set_block_replication(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_block_replication() const;
  void _internal_set_block_replication(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
  bool has_filetype() const;
  private:
  bool _internal_has_filetype() const;
  public:
  void clear_filetype();
  ::Hdfs::Internal::HdfsFileStatusProto_FileType filetype() const;
  void set_filetype(::Hdfs::Internal::HdfsFileStatusProto_FileType value);
  private:
  ::Hdfs::Internal::HdfsFileStatusProto_FileType _internal_filetype() const;
  void _internal_set_filetype(::Hdfs::Internal::HdfsFileStatusProto_FileType value);
  public:

  // optional int32 childrenNum = 14 [default = -1];
  bool has_childrennum() const;
  private:
  bool _internal_has_childrennum() const;
  public:
  void clear_childrennum();
  ::PROTOBUF_NAMESPACE_ID::int32 childrennum() const;
  void set_childrennum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_childrennum() const;
  void _internal_set_childrennum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.HdfsFileStatusProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symlink_;
  ::Hdfs::Internal::FsPermissionProto* permission_;
  ::Hdfs::Internal::LocatedBlocksProto* locations_;
  ::Hdfs::Internal::FileEncryptionInfoProto* fileencryptioninfo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 length_;
  ::PROTOBUF_NAMESPACE_ID::uint64 modification_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 access_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blocksize_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fileid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 block_replication_;
  int filetype_;
  ::PROTOBUF_NAMESPACE_ID::int32 childrennum_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class FsServerDefaultsProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.FsServerDefaultsProto) */ {
 public:
  FsServerDefaultsProto();
  virtual ~FsServerDefaultsProto();

  FsServerDefaultsProto(const FsServerDefaultsProto& from);
  FsServerDefaultsProto(FsServerDefaultsProto&& from) noexcept
    : FsServerDefaultsProto() {
    *this = ::std::move(from);
  }

  inline FsServerDefaultsProto& operator=(const FsServerDefaultsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsServerDefaultsProto& operator=(FsServerDefaultsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FsServerDefaultsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FsServerDefaultsProto* internal_default_instance() {
    return reinterpret_cast<const FsServerDefaultsProto*>(
               &_FsServerDefaultsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FsServerDefaultsProto& a, FsServerDefaultsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FsServerDefaultsProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FsServerDefaultsProto* New() const final {
    return CreateMaybeMessage<FsServerDefaultsProto>(nullptr);
  }

  FsServerDefaultsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FsServerDefaultsProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FsServerDefaultsProto& from);
  void MergeFrom(const FsServerDefaultsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsServerDefaultsProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.FsServerDefaultsProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockSizeFieldNumber = 1,
    kBytesPerChecksumFieldNumber = 2,
    kWritePacketSizeFieldNumber = 3,
    kReplicationFieldNumber = 4,
    kFileBufferSizeFieldNumber = 5,
    kTrashIntervalFieldNumber = 7,
    kEncryptDataTransferFieldNumber = 6,
    kChecksumTypeFieldNumber = 8,
  };
  // required uint64 blockSize = 1;
  bool has_blocksize() const;
  private:
  bool _internal_has_blocksize() const;
  public:
  void clear_blocksize();
  ::PROTOBUF_NAMESPACE_ID::uint64 blocksize() const;
  void set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blocksize() const;
  void _internal_set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 bytesPerChecksum = 2;
  bool has_bytesperchecksum() const;
  private:
  bool _internal_has_bytesperchecksum() const;
  public:
  void clear_bytesperchecksum();
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperchecksum() const;
  void set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bytesperchecksum() const;
  void _internal_set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 writePacketSize = 3;
  bool has_writepacketsize() const;
  private:
  bool _internal_has_writepacketsize() const;
  public:
  void clear_writepacketsize();
  ::PROTOBUF_NAMESPACE_ID::uint32 writepacketsize() const;
  void set_writepacketsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_writepacketsize() const;
  void _internal_set_writepacketsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 replication = 4;
  bool has_replication() const;
  private:
  bool _internal_has_replication() const;
  public:
  void clear_replication();
  ::PROTOBUF_NAMESPACE_ID::uint32 replication() const;
  void set_replication(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_replication() const;
  void _internal_set_replication(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 fileBufferSize = 5;
  bool has_filebuffersize() const;
  private:
  bool _internal_has_filebuffersize() const;
  public:
  void clear_filebuffersize();
  ::PROTOBUF_NAMESPACE_ID::uint32 filebuffersize() const;
  void set_filebuffersize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_filebuffersize() const;
  void _internal_set_filebuffersize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 trashInterval = 7 [default = 0];
  bool has_trashinterval() const;
  private:
  bool _internal_has_trashinterval() const;
  public:
  void clear_trashinterval();
  ::PROTOBUF_NAMESPACE_ID::uint64 trashinterval() const;
  void set_trashinterval(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_trashinterval() const;
  void _internal_set_trashinterval(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool encryptDataTransfer = 6 [default = false];
  bool has_encryptdatatransfer() const;
  private:
  bool _internal_has_encryptdatatransfer() const;
  public:
  void clear_encryptdatatransfer();
  bool encryptdatatransfer() const;
  void set_encryptdatatransfer(bool value);
  private:
  bool _internal_encryptdatatransfer() const;
  void _internal_set_encryptdatatransfer(bool value);
  public:

  // optional .Hdfs.Internal.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
  bool has_checksumtype() const;
  private:
  bool _internal_has_checksumtype() const;
  public:
  void clear_checksumtype();
  ::Hdfs::Internal::ChecksumTypeProto checksumtype() const;
  void set_checksumtype(::Hdfs::Internal::ChecksumTypeProto value);
  private:
  ::Hdfs::Internal::ChecksumTypeProto _internal_checksumtype() const;
  void _internal_set_checksumtype(::Hdfs::Internal::ChecksumTypeProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.FsServerDefaultsProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blocksize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bytesperchecksum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 writepacketsize_;
  ::PROTOBUF_NAMESPACE_ID::uint32 replication_;
  ::PROTOBUF_NAMESPACE_ID::uint32 filebuffersize_;
  ::PROTOBUF_NAMESPACE_ID::uint64 trashinterval_;
  bool encryptdatatransfer_;
  int checksumtype_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class DirectoryListingProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.DirectoryListingProto) */ {
 public:
  DirectoryListingProto();
  virtual ~DirectoryListingProto();

  DirectoryListingProto(const DirectoryListingProto& from);
  DirectoryListingProto(DirectoryListingProto&& from) noexcept
    : DirectoryListingProto() {
    *this = ::std::move(from);
  }

  inline DirectoryListingProto& operator=(const DirectoryListingProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryListingProto& operator=(DirectoryListingProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectoryListingProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryListingProto* internal_default_instance() {
    return reinterpret_cast<const DirectoryListingProto*>(
               &_DirectoryListingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DirectoryListingProto& a, DirectoryListingProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectoryListingProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectoryListingProto* New() const final {
    return CreateMaybeMessage<DirectoryListingProto>(nullptr);
  }

  DirectoryListingProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryListingProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryListingProto& from);
  void MergeFrom(const DirectoryListingProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryListingProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.DirectoryListingProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartialListingFieldNumber = 1,
    kRemainingEntriesFieldNumber = 2,
  };
  // repeated .Hdfs.Internal.HdfsFileStatusProto partialListing = 1;
  int partiallisting_size() const;
  private:
  int _internal_partiallisting_size() const;
  public:
  void clear_partiallisting();
  ::Hdfs::Internal::HdfsFileStatusProto* mutable_partiallisting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::HdfsFileStatusProto >*
      mutable_partiallisting();
  private:
  const ::Hdfs::Internal::HdfsFileStatusProto& _internal_partiallisting(int index) const;
  ::Hdfs::Internal::HdfsFileStatusProto* _internal_add_partiallisting();
  public:
  const ::Hdfs::Internal::HdfsFileStatusProto& partiallisting(int index) const;
  ::Hdfs::Internal::HdfsFileStatusProto* add_partiallisting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::HdfsFileStatusProto >&
      partiallisting() const;

  // required uint32 remainingEntries = 2;
  bool has_remainingentries() const;
  private:
  bool _internal_has_remainingentries() const;
  public:
  void clear_remainingentries();
  ::PROTOBUF_NAMESPACE_ID::uint32 remainingentries() const;
  void set_remainingentries(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_remainingentries() const;
  void _internal_set_remainingentries(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.DirectoryListingProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::HdfsFileStatusProto > partiallisting_;
  ::PROTOBUF_NAMESPACE_ID::uint32 remainingentries_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class SnapshottableDirectoryStatusProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.SnapshottableDirectoryStatusProto) */ {
 public:
  SnapshottableDirectoryStatusProto();
  virtual ~SnapshottableDirectoryStatusProto();

  SnapshottableDirectoryStatusProto(const SnapshottableDirectoryStatusProto& from);
  SnapshottableDirectoryStatusProto(SnapshottableDirectoryStatusProto&& from) noexcept
    : SnapshottableDirectoryStatusProto() {
    *this = ::std::move(from);
  }

  inline SnapshottableDirectoryStatusProto& operator=(const SnapshottableDirectoryStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshottableDirectoryStatusProto& operator=(SnapshottableDirectoryStatusProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshottableDirectoryStatusProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshottableDirectoryStatusProto* internal_default_instance() {
    return reinterpret_cast<const SnapshottableDirectoryStatusProto*>(
               &_SnapshottableDirectoryStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SnapshottableDirectoryStatusProto& a, SnapshottableDirectoryStatusProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshottableDirectoryStatusProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshottableDirectoryStatusProto* New() const final {
    return CreateMaybeMessage<SnapshottableDirectoryStatusProto>(nullptr);
  }

  SnapshottableDirectoryStatusProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshottableDirectoryStatusProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshottableDirectoryStatusProto& from);
  void MergeFrom(const SnapshottableDirectoryStatusProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshottableDirectoryStatusProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.SnapshottableDirectoryStatusProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFullpathFieldNumber = 4,
    kDirStatusFieldNumber = 1,
    kSnapshotQuotaFieldNumber = 2,
    kSnapshotNumberFieldNumber = 3,
  };
  // required bytes parent_fullpath = 4;
  bool has_parent_fullpath() const;
  private:
  bool _internal_has_parent_fullpath() const;
  public:
  void clear_parent_fullpath();
  const std::string& parent_fullpath() const;
  void set_parent_fullpath(const std::string& value);
  void set_parent_fullpath(std::string&& value);
  void set_parent_fullpath(const char* value);
  void set_parent_fullpath(const void* value, size_t size);
  std::string* mutable_parent_fullpath();
  std::string* release_parent_fullpath();
  void set_allocated_parent_fullpath(std::string* parent_fullpath);
  private:
  const std::string& _internal_parent_fullpath() const;
  void _internal_set_parent_fullpath(const std::string& value);
  std::string* _internal_mutable_parent_fullpath();
  public:

  // required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
  bool has_dirstatus() const;
  private:
  bool _internal_has_dirstatus() const;
  public:
  void clear_dirstatus();
  const ::Hdfs::Internal::HdfsFileStatusProto& dirstatus() const;
  ::Hdfs::Internal::HdfsFileStatusProto* release_dirstatus();
  ::Hdfs::Internal::HdfsFileStatusProto* mutable_dirstatus();
  void set_allocated_dirstatus(::Hdfs::Internal::HdfsFileStatusProto* dirstatus);
  private:
  const ::Hdfs::Internal::HdfsFileStatusProto& _internal_dirstatus() const;
  ::Hdfs::Internal::HdfsFileStatusProto* _internal_mutable_dirstatus();
  public:

  // required uint32 snapshot_quota = 2;
  bool has_snapshot_quota() const;
  private:
  bool _internal_has_snapshot_quota() const;
  public:
  void clear_snapshot_quota();
  ::PROTOBUF_NAMESPACE_ID::uint32 snapshot_quota() const;
  void set_snapshot_quota(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_snapshot_quota() const;
  void _internal_set_snapshot_quota(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 snapshot_number = 3;
  bool has_snapshot_number() const;
  private:
  bool _internal_has_snapshot_number() const;
  public:
  void clear_snapshot_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 snapshot_number() const;
  void set_snapshot_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_snapshot_number() const;
  void _internal_set_snapshot_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.SnapshottableDirectoryStatusProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_fullpath_;
  ::Hdfs::Internal::HdfsFileStatusProto* dirstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 snapshot_quota_;
  ::PROTOBUF_NAMESPACE_ID::uint32 snapshot_number_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class SnapshottableDirectoryListingProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.SnapshottableDirectoryListingProto) */ {
 public:
  SnapshottableDirectoryListingProto();
  virtual ~SnapshottableDirectoryListingProto();

  SnapshottableDirectoryListingProto(const SnapshottableDirectoryListingProto& from);
  SnapshottableDirectoryListingProto(SnapshottableDirectoryListingProto&& from) noexcept
    : SnapshottableDirectoryListingProto() {
    *this = ::std::move(from);
  }

  inline SnapshottableDirectoryListingProto& operator=(const SnapshottableDirectoryListingProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshottableDirectoryListingProto& operator=(SnapshottableDirectoryListingProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshottableDirectoryListingProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshottableDirectoryListingProto* internal_default_instance() {
    return reinterpret_cast<const SnapshottableDirectoryListingProto*>(
               &_SnapshottableDirectoryListingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SnapshottableDirectoryListingProto& a, SnapshottableDirectoryListingProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshottableDirectoryListingProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshottableDirectoryListingProto* New() const final {
    return CreateMaybeMessage<SnapshottableDirectoryListingProto>(nullptr);
  }

  SnapshottableDirectoryListingProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshottableDirectoryListingProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshottableDirectoryListingProto& from);
  void MergeFrom(const SnapshottableDirectoryListingProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshottableDirectoryListingProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.SnapshottableDirectoryListingProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshottableDirListingFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
  int snapshottabledirlisting_size() const;
  private:
  int _internal_snapshottabledirlisting_size() const;
  public:
  void clear_snapshottabledirlisting();
  ::Hdfs::Internal::SnapshottableDirectoryStatusProto* mutable_snapshottabledirlisting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshottableDirectoryStatusProto >*
      mutable_snapshottabledirlisting();
  private:
  const ::Hdfs::Internal::SnapshottableDirectoryStatusProto& _internal_snapshottabledirlisting(int index) const;
  ::Hdfs::Internal::SnapshottableDirectoryStatusProto* _internal_add_snapshottabledirlisting();
  public:
  const ::Hdfs::Internal::SnapshottableDirectoryStatusProto& snapshottabledirlisting(int index) const;
  ::Hdfs::Internal::SnapshottableDirectoryStatusProto* add_snapshottabledirlisting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshottableDirectoryStatusProto >&
      snapshottabledirlisting() const;

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.SnapshottableDirectoryListingProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshottableDirectoryStatusProto > snapshottabledirlisting_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class SnapshotDiffReportEntryProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.SnapshotDiffReportEntryProto) */ {
 public:
  SnapshotDiffReportEntryProto();
  virtual ~SnapshotDiffReportEntryProto();

  SnapshotDiffReportEntryProto(const SnapshotDiffReportEntryProto& from);
  SnapshotDiffReportEntryProto(SnapshotDiffReportEntryProto&& from) noexcept
    : SnapshotDiffReportEntryProto() {
    *this = ::std::move(from);
  }

  inline SnapshotDiffReportEntryProto& operator=(const SnapshotDiffReportEntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotDiffReportEntryProto& operator=(SnapshotDiffReportEntryProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshotDiffReportEntryProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshotDiffReportEntryProto* internal_default_instance() {
    return reinterpret_cast<const SnapshotDiffReportEntryProto*>(
               &_SnapshotDiffReportEntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SnapshotDiffReportEntryProto& a, SnapshotDiffReportEntryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotDiffReportEntryProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshotDiffReportEntryProto* New() const final {
    return CreateMaybeMessage<SnapshotDiffReportEntryProto>(nullptr);
  }

  SnapshotDiffReportEntryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshotDiffReportEntryProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshotDiffReportEntryProto& from);
  void MergeFrom(const SnapshotDiffReportEntryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotDiffReportEntryProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.SnapshotDiffReportEntryProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullpathFieldNumber = 1,
    kModificationLabelFieldNumber = 2,
  };
  // required bytes fullpath = 1;
  bool has_fullpath() const;
  private:
  bool _internal_has_fullpath() const;
  public:
  void clear_fullpath();
  const std::string& fullpath() const;
  void set_fullpath(const std::string& value);
  void set_fullpath(std::string&& value);
  void set_fullpath(const char* value);
  void set_fullpath(const void* value, size_t size);
  std::string* mutable_fullpath();
  std::string* release_fullpath();
  void set_allocated_fullpath(std::string* fullpath);
  private:
  const std::string& _internal_fullpath() const;
  void _internal_set_fullpath(const std::string& value);
  std::string* _internal_mutable_fullpath();
  public:

  // required string modificationLabel = 2;
  bool has_modificationlabel() const;
  private:
  bool _internal_has_modificationlabel() const;
  public:
  void clear_modificationlabel();
  const std::string& modificationlabel() const;
  void set_modificationlabel(const std::string& value);
  void set_modificationlabel(std::string&& value);
  void set_modificationlabel(const char* value);
  void set_modificationlabel(const char* value, size_t size);
  std::string* mutable_modificationlabel();
  std::string* release_modificationlabel();
  void set_allocated_modificationlabel(std::string* modificationlabel);
  private:
  const std::string& _internal_modificationlabel() const;
  void _internal_set_modificationlabel(const std::string& value);
  std::string* _internal_mutable_modificationlabel();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.SnapshotDiffReportEntryProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modificationlabel_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class SnapshotDiffReportProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.SnapshotDiffReportProto) */ {
 public:
  SnapshotDiffReportProto();
  virtual ~SnapshotDiffReportProto();

  SnapshotDiffReportProto(const SnapshotDiffReportProto& from);
  SnapshotDiffReportProto(SnapshotDiffReportProto&& from) noexcept
    : SnapshotDiffReportProto() {
    *this = ::std::move(from);
  }

  inline SnapshotDiffReportProto& operator=(const SnapshotDiffReportProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotDiffReportProto& operator=(SnapshotDiffReportProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshotDiffReportProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshotDiffReportProto* internal_default_instance() {
    return reinterpret_cast<const SnapshotDiffReportProto*>(
               &_SnapshotDiffReportProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SnapshotDiffReportProto& a, SnapshotDiffReportProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotDiffReportProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshotDiffReportProto* New() const final {
    return CreateMaybeMessage<SnapshotDiffReportProto>(nullptr);
  }

  SnapshotDiffReportProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshotDiffReportProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshotDiffReportProto& from);
  void MergeFrom(const SnapshotDiffReportProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotDiffReportProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.SnapshotDiffReportProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffReportEntriesFieldNumber = 4,
    kSnapshotRootFieldNumber = 1,
    kFromSnapshotFieldNumber = 2,
    kToSnapshotFieldNumber = 3,
  };
  // repeated .Hdfs.Internal.SnapshotDiffReportEntryProto diffReportEntries = 4;
  int diffreportentries_size() const;
  private:
  int _internal_diffreportentries_size() const;
  public:
  void clear_diffreportentries();
  ::Hdfs::Internal::SnapshotDiffReportEntryProto* mutable_diffreportentries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshotDiffReportEntryProto >*
      mutable_diffreportentries();
  private:
  const ::Hdfs::Internal::SnapshotDiffReportEntryProto& _internal_diffreportentries(int index) const;
  ::Hdfs::Internal::SnapshotDiffReportEntryProto* _internal_add_diffreportentries();
  public:
  const ::Hdfs::Internal::SnapshotDiffReportEntryProto& diffreportentries(int index) const;
  ::Hdfs::Internal::SnapshotDiffReportEntryProto* add_diffreportentries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshotDiffReportEntryProto >&
      diffreportentries() const;

  // required string snapshotRoot = 1;
  bool has_snapshotroot() const;
  private:
  bool _internal_has_snapshotroot() const;
  public:
  void clear_snapshotroot();
  const std::string& snapshotroot() const;
  void set_snapshotroot(const std::string& value);
  void set_snapshotroot(std::string&& value);
  void set_snapshotroot(const char* value);
  void set_snapshotroot(const char* value, size_t size);
  std::string* mutable_snapshotroot();
  std::string* release_snapshotroot();
  void set_allocated_snapshotroot(std::string* snapshotroot);
  private:
  const std::string& _internal_snapshotroot() const;
  void _internal_set_snapshotroot(const std::string& value);
  std::string* _internal_mutable_snapshotroot();
  public:

  // required string fromSnapshot = 2;
  bool has_fromsnapshot() const;
  private:
  bool _internal_has_fromsnapshot() const;
  public:
  void clear_fromsnapshot();
  const std::string& fromsnapshot() const;
  void set_fromsnapshot(const std::string& value);
  void set_fromsnapshot(std::string&& value);
  void set_fromsnapshot(const char* value);
  void set_fromsnapshot(const char* value, size_t size);
  std::string* mutable_fromsnapshot();
  std::string* release_fromsnapshot();
  void set_allocated_fromsnapshot(std::string* fromsnapshot);
  private:
  const std::string& _internal_fromsnapshot() const;
  void _internal_set_fromsnapshot(const std::string& value);
  std::string* _internal_mutable_fromsnapshot();
  public:

  // required string toSnapshot = 3;
  bool has_tosnapshot() const;
  private:
  bool _internal_has_tosnapshot() const;
  public:
  void clear_tosnapshot();
  const std::string& tosnapshot() const;
  void set_tosnapshot(const std::string& value);
  void set_tosnapshot(std::string&& value);
  void set_tosnapshot(const char* value);
  void set_tosnapshot(const char* value, size_t size);
  std::string* mutable_tosnapshot();
  std::string* release_tosnapshot();
  void set_allocated_tosnapshot(std::string* tosnapshot);
  private:
  const std::string& _internal_tosnapshot() const;
  void _internal_set_tosnapshot(const std::string& value);
  std::string* _internal_mutable_tosnapshot();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.SnapshotDiffReportProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshotDiffReportEntryProto > diffreportentries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshotroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromsnapshot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tosnapshot_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class StorageInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.StorageInfoProto) */ {
 public:
  StorageInfoProto();
  virtual ~StorageInfoProto();

  StorageInfoProto(const StorageInfoProto& from);
  StorageInfoProto(StorageInfoProto&& from) noexcept
    : StorageInfoProto() {
    *this = ::std::move(from);
  }

  inline StorageInfoProto& operator=(const StorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageInfoProto& operator=(StorageInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StorageInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageInfoProto* internal_default_instance() {
    return reinterpret_cast<const StorageInfoProto*>(
               &_StorageInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StorageInfoProto& a, StorageInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StorageInfoProto* New() const final {
    return CreateMaybeMessage<StorageInfoProto>(nullptr);
  }

  StorageInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StorageInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StorageInfoProto& from);
  void MergeFrom(const StorageInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.StorageInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterIDFieldNumber = 3,
    kLayoutVersionFieldNumber = 1,
    kNamespceIDFieldNumber = 2,
    kCTimeFieldNumber = 4,
  };
  // required string clusterID = 3;
  bool has_clusterid() const;
  private:
  bool _internal_has_clusterid() const;
  public:
  void clear_clusterid();
  const std::string& clusterid() const;
  void set_clusterid(const std::string& value);
  void set_clusterid(std::string&& value);
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  std::string* mutable_clusterid();
  std::string* release_clusterid();
  void set_allocated_clusterid(std::string* clusterid);
  private:
  const std::string& _internal_clusterid() const;
  void _internal_set_clusterid(const std::string& value);
  std::string* _internal_mutable_clusterid();
  public:

  // required uint32 layoutVersion = 1;
  bool has_layoutversion() const;
  private:
  bool _internal_has_layoutversion() const;
  public:
  void clear_layoutversion();
  ::PROTOBUF_NAMESPACE_ID::uint32 layoutversion() const;
  void set_layoutversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_layoutversion() const;
  void _internal_set_layoutversion(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 namespceID = 2;
  bool has_namespceid() const;
  private:
  bool _internal_has_namespceid() const;
  public:
  void clear_namespceid();
  ::PROTOBUF_NAMESPACE_ID::uint32 namespceid() const;
  void set_namespceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_namespceid() const;
  void _internal_set_namespceid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint64 cTime = 4;
  bool has_ctime() const;
  private:
  bool _internal_has_ctime() const;
  public:
  void clear_ctime();
  ::PROTOBUF_NAMESPACE_ID::uint64 ctime() const;
  void set_ctime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ctime() const;
  void _internal_set_ctime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.StorageInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clusterid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 layoutversion_;
  ::PROTOBUF_NAMESPACE_ID::uint32 namespceid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ctime_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class NamenodeRegistrationProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.NamenodeRegistrationProto) */ {
 public:
  NamenodeRegistrationProto();
  virtual ~NamenodeRegistrationProto();

  NamenodeRegistrationProto(const NamenodeRegistrationProto& from);
  NamenodeRegistrationProto(NamenodeRegistrationProto&& from) noexcept
    : NamenodeRegistrationProto() {
    *this = ::std::move(from);
  }

  inline NamenodeRegistrationProto& operator=(const NamenodeRegistrationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamenodeRegistrationProto& operator=(NamenodeRegistrationProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamenodeRegistrationProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamenodeRegistrationProto* internal_default_instance() {
    return reinterpret_cast<const NamenodeRegistrationProto*>(
               &_NamenodeRegistrationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NamenodeRegistrationProto& a, NamenodeRegistrationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NamenodeRegistrationProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamenodeRegistrationProto* New() const final {
    return CreateMaybeMessage<NamenodeRegistrationProto>(nullptr);
  }

  NamenodeRegistrationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamenodeRegistrationProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamenodeRegistrationProto& from);
  void MergeFrom(const NamenodeRegistrationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamenodeRegistrationProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.NamenodeRegistrationProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NamenodeRegistrationProto_NamenodeRoleProto NamenodeRoleProto;
  static constexpr NamenodeRoleProto NAMENODE =
    NamenodeRegistrationProto_NamenodeRoleProto_NAMENODE;
  static constexpr NamenodeRoleProto BACKUP =
    NamenodeRegistrationProto_NamenodeRoleProto_BACKUP;
  static constexpr NamenodeRoleProto CHECKPOINT =
    NamenodeRegistrationProto_NamenodeRoleProto_CHECKPOINT;
  static inline bool NamenodeRoleProto_IsValid(int value) {
    return NamenodeRegistrationProto_NamenodeRoleProto_IsValid(value);
  }
  static constexpr NamenodeRoleProto NamenodeRoleProto_MIN =
    NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_MIN;
  static constexpr NamenodeRoleProto NamenodeRoleProto_MAX =
    NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_MAX;
  static constexpr int NamenodeRoleProto_ARRAYSIZE =
    NamenodeRegistrationProto_NamenodeRoleProto_NamenodeRoleProto_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NamenodeRoleProto_descriptor() {
    return NamenodeRegistrationProto_NamenodeRoleProto_descriptor();
  }
  template<typename T>
  static inline const std::string& NamenodeRoleProto_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NamenodeRoleProto>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NamenodeRoleProto_Name.");
    return NamenodeRegistrationProto_NamenodeRoleProto_Name(enum_t_value);
  }
  static inline bool NamenodeRoleProto_Parse(const std::string& name,
      NamenodeRoleProto* value) {
    return NamenodeRegistrationProto_NamenodeRoleProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRpcAddressFieldNumber = 1,
    kHttpAddressFieldNumber = 2,
    kStorageInfoFieldNumber = 3,
    kRoleFieldNumber = 4,
  };
  // required string rpcAddress = 1;
  bool has_rpcaddress() const;
  private:
  bool _internal_has_rpcaddress() const;
  public:
  void clear_rpcaddress();
  const std::string& rpcaddress() const;
  void set_rpcaddress(const std::string& value);
  void set_rpcaddress(std::string&& value);
  void set_rpcaddress(const char* value);
  void set_rpcaddress(const char* value, size_t size);
  std::string* mutable_rpcaddress();
  std::string* release_rpcaddress();
  void set_allocated_rpcaddress(std::string* rpcaddress);
  private:
  const std::string& _internal_rpcaddress() const;
  void _internal_set_rpcaddress(const std::string& value);
  std::string* _internal_mutable_rpcaddress();
  public:

  // required string httpAddress = 2;
  bool has_httpaddress() const;
  private:
  bool _internal_has_httpaddress() const;
  public:
  void clear_httpaddress();
  const std::string& httpaddress() const;
  void set_httpaddress(const std::string& value);
  void set_httpaddress(std::string&& value);
  void set_httpaddress(const char* value);
  void set_httpaddress(const char* value, size_t size);
  std::string* mutable_httpaddress();
  std::string* release_httpaddress();
  void set_allocated_httpaddress(std::string* httpaddress);
  private:
  const std::string& _internal_httpaddress() const;
  void _internal_set_httpaddress(const std::string& value);
  std::string* _internal_mutable_httpaddress();
  public:

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
  bool has_storageinfo() const;
  private:
  bool _internal_has_storageinfo() const;
  public:
  void clear_storageinfo();
  const ::Hdfs::Internal::StorageInfoProto& storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* release_storageinfo();
  ::Hdfs::Internal::StorageInfoProto* mutable_storageinfo();
  void set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo);
  private:
  const ::Hdfs::Internal::StorageInfoProto& _internal_storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* _internal_mutable_storageinfo();
  public:

  // optional .Hdfs.Internal.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto role() const;
  void set_role(::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto value);
  private:
  ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto _internal_role() const;
  void _internal_set_role(::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.NamenodeRegistrationProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpcaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr httpaddress_;
  ::Hdfs::Internal::StorageInfoProto* storageinfo_;
  int role_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class CheckpointSignatureProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.CheckpointSignatureProto) */ {
 public:
  CheckpointSignatureProto();
  virtual ~CheckpointSignatureProto();

  CheckpointSignatureProto(const CheckpointSignatureProto& from);
  CheckpointSignatureProto(CheckpointSignatureProto&& from) noexcept
    : CheckpointSignatureProto() {
    *this = ::std::move(from);
  }

  inline CheckpointSignatureProto& operator=(const CheckpointSignatureProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointSignatureProto& operator=(CheckpointSignatureProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckpointSignatureProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckpointSignatureProto* internal_default_instance() {
    return reinterpret_cast<const CheckpointSignatureProto*>(
               &_CheckpointSignatureProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CheckpointSignatureProto& a, CheckpointSignatureProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointSignatureProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointSignatureProto* New() const final {
    return CreateMaybeMessage<CheckpointSignatureProto>(nullptr);
  }

  CheckpointSignatureProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointSignatureProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckpointSignatureProto& from);
  void MergeFrom(const CheckpointSignatureProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointSignatureProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.CheckpointSignatureProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockPoolIdFieldNumber = 1,
    kStorageInfoFieldNumber = 4,
    kMostRecentCheckpointTxIdFieldNumber = 2,
    kCurSegmentTxIdFieldNumber = 3,
  };
  // required string blockPoolId = 1;
  bool has_blockpoolid() const;
  private:
  bool _internal_has_blockpoolid() const;
  public:
  void clear_blockpoolid();
  const std::string& blockpoolid() const;
  void set_blockpoolid(const std::string& value);
  void set_blockpoolid(std::string&& value);
  void set_blockpoolid(const char* value);
  void set_blockpoolid(const char* value, size_t size);
  std::string* mutable_blockpoolid();
  std::string* release_blockpoolid();
  void set_allocated_blockpoolid(std::string* blockpoolid);
  private:
  const std::string& _internal_blockpoolid() const;
  void _internal_set_blockpoolid(const std::string& value);
  std::string* _internal_mutable_blockpoolid();
  public:

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
  bool has_storageinfo() const;
  private:
  bool _internal_has_storageinfo() const;
  public:
  void clear_storageinfo();
  const ::Hdfs::Internal::StorageInfoProto& storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* release_storageinfo();
  ::Hdfs::Internal::StorageInfoProto* mutable_storageinfo();
  void set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo);
  private:
  const ::Hdfs::Internal::StorageInfoProto& _internal_storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* _internal_mutable_storageinfo();
  public:

  // required uint64 mostRecentCheckpointTxId = 2;
  bool has_mostrecentcheckpointtxid() const;
  private:
  bool _internal_has_mostrecentcheckpointtxid() const;
  public:
  void clear_mostrecentcheckpointtxid();
  ::PROTOBUF_NAMESPACE_ID::uint64 mostrecentcheckpointtxid() const;
  void set_mostrecentcheckpointtxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_mostrecentcheckpointtxid() const;
  void _internal_set_mostrecentcheckpointtxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 curSegmentTxId = 3;
  bool has_cursegmenttxid() const;
  private:
  bool _internal_has_cursegmenttxid() const;
  public:
  void clear_cursegmenttxid();
  ::PROTOBUF_NAMESPACE_ID::uint64 cursegmenttxid() const;
  void set_cursegmenttxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cursegmenttxid() const;
  void _internal_set_cursegmenttxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.CheckpointSignatureProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockpoolid_;
  ::Hdfs::Internal::StorageInfoProto* storageinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 mostrecentcheckpointtxid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cursegmenttxid_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class NamenodeCommandProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.NamenodeCommandProto) */ {
 public:
  NamenodeCommandProto();
  virtual ~NamenodeCommandProto();

  NamenodeCommandProto(const NamenodeCommandProto& from);
  NamenodeCommandProto(NamenodeCommandProto&& from) noexcept
    : NamenodeCommandProto() {
    *this = ::std::move(from);
  }

  inline NamenodeCommandProto& operator=(const NamenodeCommandProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamenodeCommandProto& operator=(NamenodeCommandProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamenodeCommandProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamenodeCommandProto* internal_default_instance() {
    return reinterpret_cast<const NamenodeCommandProto*>(
               &_NamenodeCommandProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NamenodeCommandProto& a, NamenodeCommandProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NamenodeCommandProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamenodeCommandProto* New() const final {
    return CreateMaybeMessage<NamenodeCommandProto>(nullptr);
  }

  NamenodeCommandProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamenodeCommandProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamenodeCommandProto& from);
  void MergeFrom(const NamenodeCommandProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamenodeCommandProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.NamenodeCommandProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NamenodeCommandProto_Type Type;
  static constexpr Type NamenodeCommand =
    NamenodeCommandProto_Type_NamenodeCommand;
  static constexpr Type CheckPointCommand =
    NamenodeCommandProto_Type_CheckPointCommand;
  static inline bool Type_IsValid(int value) {
    return NamenodeCommandProto_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    NamenodeCommandProto_Type_Type_MIN;
  static constexpr Type Type_MAX =
    NamenodeCommandProto_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    NamenodeCommandProto_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return NamenodeCommandProto_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return NamenodeCommandProto_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return NamenodeCommandProto_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCheckpointCmdFieldNumber = 3,
    kActionFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .Hdfs.Internal.CheckpointCommandProto checkpointCmd = 3;
  bool has_checkpointcmd() const;
  private:
  bool _internal_has_checkpointcmd() const;
  public:
  void clear_checkpointcmd();
  const ::Hdfs::Internal::CheckpointCommandProto& checkpointcmd() const;
  ::Hdfs::Internal::CheckpointCommandProto* release_checkpointcmd();
  ::Hdfs::Internal::CheckpointCommandProto* mutable_checkpointcmd();
  void set_allocated_checkpointcmd(::Hdfs::Internal::CheckpointCommandProto* checkpointcmd);
  private:
  const ::Hdfs::Internal::CheckpointCommandProto& _internal_checkpointcmd() const;
  ::Hdfs::Internal::CheckpointCommandProto* _internal_mutable_checkpointcmd();
  public:

  // required uint32 action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::PROTOBUF_NAMESPACE_ID::uint32 action() const;
  void set_action(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action() const;
  void _internal_set_action(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Hdfs::Internal::NamenodeCommandProto_Type type() const;
  void set_type(::Hdfs::Internal::NamenodeCommandProto_Type value);
  private:
  ::Hdfs::Internal::NamenodeCommandProto_Type _internal_type() const;
  void _internal_set_type(::Hdfs::Internal::NamenodeCommandProto_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.NamenodeCommandProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::CheckpointCommandProto* checkpointcmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_;
  int type_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class CheckpointCommandProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.CheckpointCommandProto) */ {
 public:
  CheckpointCommandProto();
  virtual ~CheckpointCommandProto();

  CheckpointCommandProto(const CheckpointCommandProto& from);
  CheckpointCommandProto(CheckpointCommandProto&& from) noexcept
    : CheckpointCommandProto() {
    *this = ::std::move(from);
  }

  inline CheckpointCommandProto& operator=(const CheckpointCommandProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointCommandProto& operator=(CheckpointCommandProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckpointCommandProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckpointCommandProto* internal_default_instance() {
    return reinterpret_cast<const CheckpointCommandProto*>(
               &_CheckpointCommandProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CheckpointCommandProto& a, CheckpointCommandProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointCommandProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointCommandProto* New() const final {
    return CreateMaybeMessage<CheckpointCommandProto>(nullptr);
  }

  CheckpointCommandProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointCommandProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckpointCommandProto& from);
  void MergeFrom(const CheckpointCommandProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointCommandProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.CheckpointCommandProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kNeedToReturnImageFieldNumber = 2,
  };
  // required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::Hdfs::Internal::CheckpointSignatureProto& signature() const;
  ::Hdfs::Internal::CheckpointSignatureProto* release_signature();
  ::Hdfs::Internal::CheckpointSignatureProto* mutable_signature();
  void set_allocated_signature(::Hdfs::Internal::CheckpointSignatureProto* signature);
  private:
  const ::Hdfs::Internal::CheckpointSignatureProto& _internal_signature() const;
  ::Hdfs::Internal::CheckpointSignatureProto* _internal_mutable_signature();
  public:

  // required bool needToReturnImage = 2;
  bool has_needtoreturnimage() const;
  private:
  bool _internal_has_needtoreturnimage() const;
  public:
  void clear_needtoreturnimage();
  bool needtoreturnimage() const;
  void set_needtoreturnimage(bool value);
  private:
  bool _internal_needtoreturnimage() const;
  void _internal_set_needtoreturnimage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.CheckpointCommandProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::CheckpointSignatureProto* signature_;
  bool needtoreturnimage_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class BlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BlockProto) */ {
 public:
  BlockProto();
  virtual ~BlockProto();

  BlockProto(const BlockProto& from);
  BlockProto(BlockProto&& from) noexcept
    : BlockProto() {
    *this = ::std::move(from);
  }

  inline BlockProto& operator=(const BlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockProto& operator=(BlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockProto* internal_default_instance() {
    return reinterpret_cast<const BlockProto*>(
               &_BlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(BlockProto& a, BlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockProto* New() const final {
    return CreateMaybeMessage<BlockProto>(nullptr);
  }

  BlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockProto& from);
  void MergeFrom(const BlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kGenStampFieldNumber = 2,
    kNumBytesFieldNumber = 3,
  };
  // required uint64 blockId = 1;
  bool has_blockid() const;
  private:
  bool _internal_has_blockid() const;
  public:
  void clear_blockid();
  ::PROTOBUF_NAMESPACE_ID::uint64 blockid() const;
  void set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_blockid() const;
  void _internal_set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 genStamp = 2;
  bool has_genstamp() const;
  private:
  bool _internal_has_genstamp() const;
  public:
  void clear_genstamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 genstamp() const;
  void set_genstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_genstamp() const;
  void _internal_set_genstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 numBytes = 3 [default = 0];
  bool has_numbytes() const;
  private:
  bool _internal_has_numbytes() const;
  public:
  void clear_numbytes();
  ::PROTOBUF_NAMESPACE_ID::uint64 numbytes() const;
  void set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_numbytes() const;
  void _internal_set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 blockid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 genstamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 numbytes_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class BlockWithLocationsProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BlockWithLocationsProto) */ {
 public:
  BlockWithLocationsProto();
  virtual ~BlockWithLocationsProto();

  BlockWithLocationsProto(const BlockWithLocationsProto& from);
  BlockWithLocationsProto(BlockWithLocationsProto&& from) noexcept
    : BlockWithLocationsProto() {
    *this = ::std::move(from);
  }

  inline BlockWithLocationsProto& operator=(const BlockWithLocationsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockWithLocationsProto& operator=(BlockWithLocationsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockWithLocationsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockWithLocationsProto* internal_default_instance() {
    return reinterpret_cast<const BlockWithLocationsProto*>(
               &_BlockWithLocationsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(BlockWithLocationsProto& a, BlockWithLocationsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockWithLocationsProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockWithLocationsProto* New() const final {
    return CreateMaybeMessage<BlockWithLocationsProto>(nullptr);
  }

  BlockWithLocationsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockWithLocationsProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockWithLocationsProto& from);
  void MergeFrom(const BlockWithLocationsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockWithLocationsProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BlockWithLocationsProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatanodeUuidsFieldNumber = 2,
    kStorageUuidsFieldNumber = 3,
    kBlockFieldNumber = 1,
  };
  // repeated string datanodeUuids = 2;
  int datanodeuuids_size() const;
  private:
  int _internal_datanodeuuids_size() const;
  public:
  void clear_datanodeuuids();
  const std::string& datanodeuuids(int index) const;
  std::string* mutable_datanodeuuids(int index);
  void set_datanodeuuids(int index, const std::string& value);
  void set_datanodeuuids(int index, std::string&& value);
  void set_datanodeuuids(int index, const char* value);
  void set_datanodeuuids(int index, const char* value, size_t size);
  std::string* add_datanodeuuids();
  void add_datanodeuuids(const std::string& value);
  void add_datanodeuuids(std::string&& value);
  void add_datanodeuuids(const char* value);
  void add_datanodeuuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& datanodeuuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_datanodeuuids();
  private:
  const std::string& _internal_datanodeuuids(int index) const;
  std::string* _internal_add_datanodeuuids();
  public:

  // repeated string storageUuids = 3;
  int storageuuids_size() const;
  private:
  int _internal_storageuuids_size() const;
  public:
  void clear_storageuuids();
  const std::string& storageuuids(int index) const;
  std::string* mutable_storageuuids(int index);
  void set_storageuuids(int index, const std::string& value);
  void set_storageuuids(int index, std::string&& value);
  void set_storageuuids(int index, const char* value);
  void set_storageuuids(int index, const char* value, size_t size);
  std::string* add_storageuuids();
  void add_storageuuids(const std::string& value);
  void add_storageuuids(std::string&& value);
  void add_storageuuids(const char* value);
  void add_storageuuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& storageuuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_storageuuids();
  private:
  const std::string& _internal_storageuuids(int index) const;
  std::string* _internal_add_storageuuids();
  public:

  // required .Hdfs.Internal.BlockProto block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Hdfs::Internal::BlockProto& block() const;
  ::Hdfs::Internal::BlockProto* release_block();
  ::Hdfs::Internal::BlockProto* mutable_block();
  void set_allocated_block(::Hdfs::Internal::BlockProto* block);
  private:
  const ::Hdfs::Internal::BlockProto& _internal_block() const;
  ::Hdfs::Internal::BlockProto* _internal_mutable_block();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BlockWithLocationsProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> datanodeuuids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> storageuuids_;
  ::Hdfs::Internal::BlockProto* block_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class BlocksWithLocationsProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BlocksWithLocationsProto) */ {
 public:
  BlocksWithLocationsProto();
  virtual ~BlocksWithLocationsProto();

  BlocksWithLocationsProto(const BlocksWithLocationsProto& from);
  BlocksWithLocationsProto(BlocksWithLocationsProto&& from) noexcept
    : BlocksWithLocationsProto() {
    *this = ::std::move(from);
  }

  inline BlocksWithLocationsProto& operator=(const BlocksWithLocationsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlocksWithLocationsProto& operator=(BlocksWithLocationsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlocksWithLocationsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlocksWithLocationsProto* internal_default_instance() {
    return reinterpret_cast<const BlocksWithLocationsProto*>(
               &_BlocksWithLocationsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(BlocksWithLocationsProto& a, BlocksWithLocationsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlocksWithLocationsProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlocksWithLocationsProto* New() const final {
    return CreateMaybeMessage<BlocksWithLocationsProto>(nullptr);
  }

  BlocksWithLocationsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlocksWithLocationsProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlocksWithLocationsProto& from);
  void MergeFrom(const BlocksWithLocationsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlocksWithLocationsProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BlocksWithLocationsProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.BlockWithLocationsProto blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::Hdfs::Internal::BlockWithLocationsProto* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockWithLocationsProto >*
      mutable_blocks();
  private:
  const ::Hdfs::Internal::BlockWithLocationsProto& _internal_blocks(int index) const;
  ::Hdfs::Internal::BlockWithLocationsProto* _internal_add_blocks();
  public:
  const ::Hdfs::Internal::BlockWithLocationsProto& blocks(int index) const;
  ::Hdfs::Internal::BlockWithLocationsProto* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockWithLocationsProto >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BlocksWithLocationsProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockWithLocationsProto > blocks_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteEditLogProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RemoteEditLogProto) */ {
 public:
  RemoteEditLogProto();
  virtual ~RemoteEditLogProto();

  RemoteEditLogProto(const RemoteEditLogProto& from);
  RemoteEditLogProto(RemoteEditLogProto&& from) noexcept
    : RemoteEditLogProto() {
    *this = ::std::move(from);
  }

  inline RemoteEditLogProto& operator=(const RemoteEditLogProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteEditLogProto& operator=(RemoteEditLogProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteEditLogProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteEditLogProto* internal_default_instance() {
    return reinterpret_cast<const RemoteEditLogProto*>(
               &_RemoteEditLogProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RemoteEditLogProto& a, RemoteEditLogProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteEditLogProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteEditLogProto* New() const final {
    return CreateMaybeMessage<RemoteEditLogProto>(nullptr);
  }

  RemoteEditLogProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteEditLogProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteEditLogProto& from);
  void MergeFrom(const RemoteEditLogProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteEditLogProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RemoteEditLogProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTxIdFieldNumber = 1,
    kEndTxIdFieldNumber = 2,
    kIsInProgressFieldNumber = 3,
  };
  // required uint64 startTxId = 1;
  bool has_starttxid() const;
  private:
  bool _internal_has_starttxid() const;
  public:
  void clear_starttxid();
  ::PROTOBUF_NAMESPACE_ID::uint64 starttxid() const;
  void set_starttxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_starttxid() const;
  void _internal_set_starttxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 endTxId = 2;
  bool has_endtxid() const;
  private:
  bool _internal_has_endtxid() const;
  public:
  void clear_endtxid();
  ::PROTOBUF_NAMESPACE_ID::uint64 endtxid() const;
  void set_endtxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_endtxid() const;
  void _internal_set_endtxid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool isInProgress = 3 [default = false];
  bool has_isinprogress() const;
  private:
  bool _internal_has_isinprogress() const;
  public:
  void clear_isinprogress();
  bool isinprogress() const;
  void set_isinprogress(bool value);
  private:
  bool _internal_isinprogress() const;
  void _internal_set_isinprogress(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RemoteEditLogProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 starttxid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 endtxid_;
  bool isinprogress_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class RemoteEditLogManifestProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RemoteEditLogManifestProto) */ {
 public:
  RemoteEditLogManifestProto();
  virtual ~RemoteEditLogManifestProto();

  RemoteEditLogManifestProto(const RemoteEditLogManifestProto& from);
  RemoteEditLogManifestProto(RemoteEditLogManifestProto&& from) noexcept
    : RemoteEditLogManifestProto() {
    *this = ::std::move(from);
  }

  inline RemoteEditLogManifestProto& operator=(const RemoteEditLogManifestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteEditLogManifestProto& operator=(RemoteEditLogManifestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteEditLogManifestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteEditLogManifestProto* internal_default_instance() {
    return reinterpret_cast<const RemoteEditLogManifestProto*>(
               &_RemoteEditLogManifestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RemoteEditLogManifestProto& a, RemoteEditLogManifestProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteEditLogManifestProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteEditLogManifestProto* New() const final {
    return CreateMaybeMessage<RemoteEditLogManifestProto>(nullptr);
  }

  RemoteEditLogManifestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteEditLogManifestProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteEditLogManifestProto& from);
  void MergeFrom(const RemoteEditLogManifestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteEditLogManifestProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RemoteEditLogManifestProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.RemoteEditLogProto logs = 1;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::Hdfs::Internal::RemoteEditLogProto* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RemoteEditLogProto >*
      mutable_logs();
  private:
  const ::Hdfs::Internal::RemoteEditLogProto& _internal_logs(int index) const;
  ::Hdfs::Internal::RemoteEditLogProto* _internal_add_logs();
  public:
  const ::Hdfs::Internal::RemoteEditLogProto& logs(int index) const;
  ::Hdfs::Internal::RemoteEditLogProto* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RemoteEditLogProto >&
      logs() const;

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RemoteEditLogManifestProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RemoteEditLogProto > logs_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class NamespaceInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.NamespaceInfoProto) */ {
 public:
  NamespaceInfoProto();
  virtual ~NamespaceInfoProto();

  NamespaceInfoProto(const NamespaceInfoProto& from);
  NamespaceInfoProto(NamespaceInfoProto&& from) noexcept
    : NamespaceInfoProto() {
    *this = ::std::move(from);
  }

  inline NamespaceInfoProto& operator=(const NamespaceInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespaceInfoProto& operator=(NamespaceInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamespaceInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamespaceInfoProto* internal_default_instance() {
    return reinterpret_cast<const NamespaceInfoProto*>(
               &_NamespaceInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(NamespaceInfoProto& a, NamespaceInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespaceInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamespaceInfoProto* New() const final {
    return CreateMaybeMessage<NamespaceInfoProto>(nullptr);
  }

  NamespaceInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamespaceInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamespaceInfoProto& from);
  void MergeFrom(const NamespaceInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamespaceInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.NamespaceInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildVersionFieldNumber = 1,
    kBlockPoolIDFieldNumber = 3,
    kSoftwareVersionFieldNumber = 5,
    kStorageInfoFieldNumber = 4,
    kUnusedFieldNumber = 2,
  };
  // required string buildVersion = 1;
  bool has_buildversion() const;
  private:
  bool _internal_has_buildversion() const;
  public:
  void clear_buildversion();
  const std::string& buildversion() const;
  void set_buildversion(const std::string& value);
  void set_buildversion(std::string&& value);
  void set_buildversion(const char* value);
  void set_buildversion(const char* value, size_t size);
  std::string* mutable_buildversion();
  std::string* release_buildversion();
  void set_allocated_buildversion(std::string* buildversion);
  private:
  const std::string& _internal_buildversion() const;
  void _internal_set_buildversion(const std::string& value);
  std::string* _internal_mutable_buildversion();
  public:

  // required string blockPoolID = 3;
  bool has_blockpoolid() const;
  private:
  bool _internal_has_blockpoolid() const;
  public:
  void clear_blockpoolid();
  const std::string& blockpoolid() const;
  void set_blockpoolid(const std::string& value);
  void set_blockpoolid(std::string&& value);
  void set_blockpoolid(const char* value);
  void set_blockpoolid(const char* value, size_t size);
  std::string* mutable_blockpoolid();
  std::string* release_blockpoolid();
  void set_allocated_blockpoolid(std::string* blockpoolid);
  private:
  const std::string& _internal_blockpoolid() const;
  void _internal_set_blockpoolid(const std::string& value);
  std::string* _internal_mutable_blockpoolid();
  public:

  // required string softwareVersion = 5;
  bool has_softwareversion() const;
  private:
  bool _internal_has_softwareversion() const;
  public:
  void clear_softwareversion();
  const std::string& softwareversion() const;
  void set_softwareversion(const std::string& value);
  void set_softwareversion(std::string&& value);
  void set_softwareversion(const char* value);
  void set_softwareversion(const char* value, size_t size);
  std::string* mutable_softwareversion();
  std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* softwareversion);
  private:
  const std::string& _internal_softwareversion() const;
  void _internal_set_softwareversion(const std::string& value);
  std::string* _internal_mutable_softwareversion();
  public:

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
  bool has_storageinfo() const;
  private:
  bool _internal_has_storageinfo() const;
  public:
  void clear_storageinfo();
  const ::Hdfs::Internal::StorageInfoProto& storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* release_storageinfo();
  ::Hdfs::Internal::StorageInfoProto* mutable_storageinfo();
  void set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo);
  private:
  const ::Hdfs::Internal::StorageInfoProto& _internal_storageinfo() const;
  ::Hdfs::Internal::StorageInfoProto* _internal_mutable_storageinfo();
  public:

  // required uint32 unused = 2;
  bool has_unused() const;
  private:
  bool _internal_has_unused() const;
  public:
  void clear_unused();
  ::PROTOBUF_NAMESPACE_ID::uint32 unused() const;
  void set_unused(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unused() const;
  void _internal_set_unused(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.NamespaceInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockpoolid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwareversion_;
  ::Hdfs::Internal::StorageInfoProto* storageinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unused_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class BlockKeyProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.BlockKeyProto) */ {
 public:
  BlockKeyProto();
  virtual ~BlockKeyProto();

  BlockKeyProto(const BlockKeyProto& from);
  BlockKeyProto(BlockKeyProto&& from) noexcept
    : BlockKeyProto() {
    *this = ::std::move(from);
  }

  inline BlockKeyProto& operator=(const BlockKeyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockKeyProto& operator=(BlockKeyProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockKeyProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockKeyProto* internal_default_instance() {
    return reinterpret_cast<const BlockKeyProto*>(
               &_BlockKeyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(BlockKeyProto& a, BlockKeyProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockKeyProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockKeyProto* New() const final {
    return CreateMaybeMessage<BlockKeyProto>(nullptr);
  }

  BlockKeyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockKeyProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockKeyProto& from);
  void MergeFrom(const BlockKeyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockKeyProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.BlockKeyProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyBytesFieldNumber = 3,
    kExpiryDateFieldNumber = 2,
    kKeyIdFieldNumber = 1,
  };
  // optional bytes keyBytes = 3;
  bool has_keybytes() const;
  private:
  bool _internal_has_keybytes() const;
  public:
  void clear_keybytes();
  const std::string& keybytes() const;
  void set_keybytes(const std::string& value);
  void set_keybytes(std::string&& value);
  void set_keybytes(const char* value);
  void set_keybytes(const void* value, size_t size);
  std::string* mutable_keybytes();
  std::string* release_keybytes();
  void set_allocated_keybytes(std::string* keybytes);
  private:
  const std::string& _internal_keybytes() const;
  void _internal_set_keybytes(const std::string& value);
  std::string* _internal_mutable_keybytes();
  public:

  // required uint64 expiryDate = 2;
  bool has_expirydate() const;
  private:
  bool _internal_has_expirydate() const;
  public:
  void clear_expirydate();
  ::PROTOBUF_NAMESPACE_ID::uint64 expirydate() const;
  void set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_expirydate() const;
  void _internal_set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 keyId = 1;
  bool has_keyid() const;
  private:
  bool _internal_has_keyid() const;
  public:
  void clear_keyid();
  ::PROTOBUF_NAMESPACE_ID::uint32 keyid() const;
  void set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_keyid() const;
  void _internal_set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.BlockKeyProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keybytes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 expirydate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 keyid_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class ExportedBlockKeysProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.ExportedBlockKeysProto) */ {
 public:
  ExportedBlockKeysProto();
  virtual ~ExportedBlockKeysProto();

  ExportedBlockKeysProto(const ExportedBlockKeysProto& from);
  ExportedBlockKeysProto(ExportedBlockKeysProto&& from) noexcept
    : ExportedBlockKeysProto() {
    *this = ::std::move(from);
  }

  inline ExportedBlockKeysProto& operator=(const ExportedBlockKeysProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedBlockKeysProto& operator=(ExportedBlockKeysProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExportedBlockKeysProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExportedBlockKeysProto* internal_default_instance() {
    return reinterpret_cast<const ExportedBlockKeysProto*>(
               &_ExportedBlockKeysProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ExportedBlockKeysProto& a, ExportedBlockKeysProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedBlockKeysProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExportedBlockKeysProto* New() const final {
    return CreateMaybeMessage<ExportedBlockKeysProto>(nullptr);
  }

  ExportedBlockKeysProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExportedBlockKeysProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExportedBlockKeysProto& from);
  void MergeFrom(const ExportedBlockKeysProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportedBlockKeysProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.ExportedBlockKeysProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllKeysFieldNumber = 5,
    kCurrentKeyFieldNumber = 4,
    kKeyUpdateIntervalFieldNumber = 2,
    kTokenLifeTimeFieldNumber = 3,
    kIsBlockTokenEnabledFieldNumber = 1,
  };
  // repeated .Hdfs.Internal.BlockKeyProto allKeys = 5;
  int allkeys_size() const;
  private:
  int _internal_allkeys_size() const;
  public:
  void clear_allkeys();
  ::Hdfs::Internal::BlockKeyProto* mutable_allkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockKeyProto >*
      mutable_allkeys();
  private:
  const ::Hdfs::Internal::BlockKeyProto& _internal_allkeys(int index) const;
  ::Hdfs::Internal::BlockKeyProto* _internal_add_allkeys();
  public:
  const ::Hdfs::Internal::BlockKeyProto& allkeys(int index) const;
  ::Hdfs::Internal::BlockKeyProto* add_allkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockKeyProto >&
      allkeys() const;

  // required .Hdfs.Internal.BlockKeyProto currentKey = 4;
  bool has_currentkey() const;
  private:
  bool _internal_has_currentkey() const;
  public:
  void clear_currentkey();
  const ::Hdfs::Internal::BlockKeyProto& currentkey() const;
  ::Hdfs::Internal::BlockKeyProto* release_currentkey();
  ::Hdfs::Internal::BlockKeyProto* mutable_currentkey();
  void set_allocated_currentkey(::Hdfs::Internal::BlockKeyProto* currentkey);
  private:
  const ::Hdfs::Internal::BlockKeyProto& _internal_currentkey() const;
  ::Hdfs::Internal::BlockKeyProto* _internal_mutable_currentkey();
  public:

  // required uint64 keyUpdateInterval = 2;
  bool has_keyupdateinterval() const;
  private:
  bool _internal_has_keyupdateinterval() const;
  public:
  void clear_keyupdateinterval();
  ::PROTOBUF_NAMESPACE_ID::uint64 keyupdateinterval() const;
  void set_keyupdateinterval(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_keyupdateinterval() const;
  void _internal_set_keyupdateinterval(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 tokenLifeTime = 3;
  bool has_tokenlifetime() const;
  private:
  bool _internal_has_tokenlifetime() const;
  public:
  void clear_tokenlifetime();
  ::PROTOBUF_NAMESPACE_ID::uint64 tokenlifetime() const;
  void set_tokenlifetime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tokenlifetime() const;
  void _internal_set_tokenlifetime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required bool isBlockTokenEnabled = 1;
  bool has_isblocktokenenabled() const;
  private:
  bool _internal_has_isblocktokenenabled() const;
  public:
  void clear_isblocktokenenabled();
  bool isblocktokenenabled() const;
  void set_isblocktokenenabled(bool value);
  private:
  bool _internal_isblocktokenenabled() const;
  void _internal_set_isblocktokenenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.ExportedBlockKeysProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockKeyProto > allkeys_;
  ::Hdfs::Internal::BlockKeyProto* currentkey_;
  ::PROTOBUF_NAMESPACE_ID::uint64 keyupdateinterval_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tokenlifetime_;
  bool isblocktokenenabled_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class RecoveringBlockProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.RecoveringBlockProto) */ {
 public:
  RecoveringBlockProto();
  virtual ~RecoveringBlockProto();

  RecoveringBlockProto(const RecoveringBlockProto& from);
  RecoveringBlockProto(RecoveringBlockProto&& from) noexcept
    : RecoveringBlockProto() {
    *this = ::std::move(from);
  }

  inline RecoveringBlockProto& operator=(const RecoveringBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveringBlockProto& operator=(RecoveringBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecoveringBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecoveringBlockProto* internal_default_instance() {
    return reinterpret_cast<const RecoveringBlockProto*>(
               &_RecoveringBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RecoveringBlockProto& a, RecoveringBlockProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveringBlockProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecoveringBlockProto* New() const final {
    return CreateMaybeMessage<RecoveringBlockProto>(nullptr);
  }

  RecoveringBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecoveringBlockProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecoveringBlockProto& from);
  void MergeFrom(const RecoveringBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoveringBlockProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.RecoveringBlockProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 2,
    kNewGenStampFieldNumber = 1,
  };
  // required .Hdfs.Internal.LocatedBlockProto block = 2;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Hdfs::Internal::LocatedBlockProto& block() const;
  ::Hdfs::Internal::LocatedBlockProto* release_block();
  ::Hdfs::Internal::LocatedBlockProto* mutable_block();
  void set_allocated_block(::Hdfs::Internal::LocatedBlockProto* block);
  private:
  const ::Hdfs::Internal::LocatedBlockProto& _internal_block() const;
  ::Hdfs::Internal::LocatedBlockProto* _internal_mutable_block();
  public:

  // required uint64 newGenStamp = 1;
  bool has_newgenstamp() const;
  private:
  bool _internal_has_newgenstamp() const;
  public:
  void clear_newgenstamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 newgenstamp() const;
  void set_newgenstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_newgenstamp() const;
  void _internal_set_newgenstamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.RecoveringBlockProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::LocatedBlockProto* block_;
  ::PROTOBUF_NAMESPACE_ID::uint64 newgenstamp_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class VersionRequestProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.VersionRequestProto) */ {
 public:
  VersionRequestProto();
  virtual ~VersionRequestProto();

  VersionRequestProto(const VersionRequestProto& from);
  VersionRequestProto(VersionRequestProto&& from) noexcept
    : VersionRequestProto() {
    *this = ::std::move(from);
  }

  inline VersionRequestProto& operator=(const VersionRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionRequestProto& operator=(VersionRequestProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionRequestProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionRequestProto* internal_default_instance() {
    return reinterpret_cast<const VersionRequestProto*>(
               &_VersionRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(VersionRequestProto& a, VersionRequestProto& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionRequestProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionRequestProto* New() const final {
    return CreateMaybeMessage<VersionRequestProto>(nullptr);
  }

  VersionRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionRequestProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionRequestProto& from);
  void MergeFrom(const VersionRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionRequestProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.VersionRequestProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.VersionRequestProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class VersionResponseProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.VersionResponseProto) */ {
 public:
  VersionResponseProto();
  virtual ~VersionResponseProto();

  VersionResponseProto(const VersionResponseProto& from);
  VersionResponseProto(VersionResponseProto&& from) noexcept
    : VersionResponseProto() {
    *this = ::std::move(from);
  }

  inline VersionResponseProto& operator=(const VersionResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionResponseProto& operator=(VersionResponseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionResponseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionResponseProto* internal_default_instance() {
    return reinterpret_cast<const VersionResponseProto*>(
               &_VersionResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(VersionResponseProto& a, VersionResponseProto& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionResponseProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionResponseProto* New() const final {
    return CreateMaybeMessage<VersionResponseProto>(nullptr);
  }

  VersionResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionResponseProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionResponseProto& from);
  void MergeFrom(const VersionResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionResponseProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.VersionResponseProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // required .Hdfs.Internal.NamespaceInfoProto info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Hdfs::Internal::NamespaceInfoProto& info() const;
  ::Hdfs::Internal::NamespaceInfoProto* release_info();
  ::Hdfs::Internal::NamespaceInfoProto* mutable_info();
  void set_allocated_info(::Hdfs::Internal::NamespaceInfoProto* info);
  private:
  const ::Hdfs::Internal::NamespaceInfoProto& _internal_info() const;
  ::Hdfs::Internal::NamespaceInfoProto* _internal_mutable_info();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.VersionResponseProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Hdfs::Internal::NamespaceInfoProto* info_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// -------------------------------------------------------------------

class SnapshotInfoProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Hdfs.Internal.SnapshotInfoProto) */ {
 public:
  SnapshotInfoProto();
  virtual ~SnapshotInfoProto();

  SnapshotInfoProto(const SnapshotInfoProto& from);
  SnapshotInfoProto(SnapshotInfoProto&& from) noexcept
    : SnapshotInfoProto() {
    *this = ::std::move(from);
  }

  inline SnapshotInfoProto& operator=(const SnapshotInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotInfoProto& operator=(SnapshotInfoProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshotInfoProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshotInfoProto* internal_default_instance() {
    return reinterpret_cast<const SnapshotInfoProto*>(
               &_SnapshotInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SnapshotInfoProto& a, SnapshotInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotInfoProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshotInfoProto* New() const final {
    return CreateMaybeMessage<SnapshotInfoProto>(nullptr);
  }

  SnapshotInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshotInfoProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshotInfoProto& from);
  void MergeFrom(const SnapshotInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotInfoProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Hdfs.Internal.SnapshotInfoProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hdfs_2eproto);
    return ::descriptor_table_hdfs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotNameFieldNumber = 1,
    kSnapshotRootFieldNumber = 2,
    kOwnerFieldNumber = 4,
    kGroupFieldNumber = 5,
    kCreateTimeFieldNumber = 6,
    kPermissionFieldNumber = 3,
  };
  // required string snapshotName = 1;
  bool has_snapshotname() const;
  private:
  bool _internal_has_snapshotname() const;
  public:
  void clear_snapshotname();
  const std::string& snapshotname() const;
  void set_snapshotname(const std::string& value);
  void set_snapshotname(std::string&& value);
  void set_snapshotname(const char* value);
  void set_snapshotname(const char* value, size_t size);
  std::string* mutable_snapshotname();
  std::string* release_snapshotname();
  void set_allocated_snapshotname(std::string* snapshotname);
  private:
  const std::string& _internal_snapshotname() const;
  void _internal_set_snapshotname(const std::string& value);
  std::string* _internal_mutable_snapshotname();
  public:

  // required string snapshotRoot = 2;
  bool has_snapshotroot() const;
  private:
  bool _internal_has_snapshotroot() const;
  public:
  void clear_snapshotroot();
  const std::string& snapshotroot() const;
  void set_snapshotroot(const std::string& value);
  void set_snapshotroot(std::string&& value);
  void set_snapshotroot(const char* value);
  void set_snapshotroot(const char* value, size_t size);
  std::string* mutable_snapshotroot();
  std::string* release_snapshotroot();
  void set_allocated_snapshotroot(std::string* snapshotroot);
  private:
  const std::string& _internal_snapshotroot() const;
  void _internal_set_snapshotroot(const std::string& value);
  std::string* _internal_mutable_snapshotroot();
  public:

  // required string owner = 4;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // required string group = 5;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // required string createTime = 6;
  bool has_createtime() const;
  private:
  bool _internal_has_createtime() const;
  public:
  void clear_createtime();
  const std::string& createtime() const;
  void set_createtime(const std::string& value);
  void set_createtime(std::string&& value);
  void set_createtime(const char* value);
  void set_createtime(const char* value, size_t size);
  std::string* mutable_createtime();
  std::string* release_createtime();
  void set_allocated_createtime(std::string* createtime);
  private:
  const std::string& _internal_createtime() const;
  void _internal_set_createtime(const std::string& value);
  std::string* _internal_mutable_createtime();
  public:

  // required .Hdfs.Internal.FsPermissionProto permission = 3;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Hdfs::Internal::FsPermissionProto& permission() const;
  ::Hdfs::Internal::FsPermissionProto* release_permission();
  ::Hdfs::Internal::FsPermissionProto* mutable_permission();
  void set_allocated_permission(::Hdfs::Internal::FsPermissionProto* permission);
  private:
  const ::Hdfs::Internal::FsPermissionProto& _internal_permission() const;
  ::Hdfs::Internal::FsPermissionProto* _internal_mutable_permission();
  public:

  // @@protoc_insertion_point(class_scope:Hdfs.Internal.SnapshotInfoProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshotname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshotroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr createtime_;
  ::Hdfs::Internal::FsPermissionProto* permission_;
  friend struct ::TableStruct_hdfs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExtendedBlockProto

// required string poolId = 1;
inline bool ExtendedBlockProto::_internal_has_poolid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtendedBlockProto::has_poolid() const {
  return _internal_has_poolid();
}
inline void ExtendedBlockProto::clear_poolid() {
  poolid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtendedBlockProto::poolid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExtendedBlockProto.poolId)
  return _internal_poolid();
}
inline void ExtendedBlockProto::set_poolid(const std::string& value) {
  _internal_set_poolid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExtendedBlockProto.poolId)
}
inline std::string* ExtendedBlockProto::mutable_poolid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ExtendedBlockProto.poolId)
  return _internal_mutable_poolid();
}
inline const std::string& ExtendedBlockProto::_internal_poolid() const {
  return poolid_.GetNoArena();
}
inline void ExtendedBlockProto::_internal_set_poolid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  poolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ExtendedBlockProto::set_poolid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  poolid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.ExtendedBlockProto.poolId)
}
inline void ExtendedBlockProto::set_poolid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  poolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.ExtendedBlockProto.poolId)
}
inline void ExtendedBlockProto::set_poolid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  poolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.ExtendedBlockProto.poolId)
}
inline std::string* ExtendedBlockProto::_internal_mutable_poolid() {
  _has_bits_[0] |= 0x00000001u;
  return poolid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ExtendedBlockProto::release_poolid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ExtendedBlockProto.poolId)
  if (!_internal_has_poolid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return poolid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ExtendedBlockProto::set_allocated_poolid(std::string* poolid) {
  if (poolid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  poolid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), poolid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ExtendedBlockProto.poolId)
}

// required uint64 blockId = 2;
inline bool ExtendedBlockProto::_internal_has_blockid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtendedBlockProto::has_blockid() const {
  return _internal_has_blockid();
}
inline void ExtendedBlockProto::clear_blockid() {
  blockid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::_internal_blockid() const {
  return blockid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::blockid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExtendedBlockProto.blockId)
  return _internal_blockid();
}
inline void ExtendedBlockProto::_internal_set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  blockid_ = value;
}
inline void ExtendedBlockProto::set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExtendedBlockProto.blockId)
}

// required uint64 generationStamp = 3;
inline bool ExtendedBlockProto::_internal_has_generationstamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtendedBlockProto::has_generationstamp() const {
  return _internal_has_generationstamp();
}
inline void ExtendedBlockProto::clear_generationstamp() {
  generationstamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::_internal_generationstamp() const {
  return generationstamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::generationstamp() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExtendedBlockProto.generationStamp)
  return _internal_generationstamp();
}
inline void ExtendedBlockProto::_internal_set_generationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  generationstamp_ = value;
}
inline void ExtendedBlockProto::set_generationstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_generationstamp(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExtendedBlockProto.generationStamp)
}

// optional uint64 numBytes = 4 [default = 0];
inline bool ExtendedBlockProto::_internal_has_numbytes() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtendedBlockProto::has_numbytes() const {
  return _internal_has_numbytes();
}
inline void ExtendedBlockProto::clear_numbytes() {
  numbytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::_internal_numbytes() const {
  return numbytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtendedBlockProto::numbytes() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExtendedBlockProto.numBytes)
  return _internal_numbytes();
}
inline void ExtendedBlockProto::_internal_set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  numbytes_ = value;
}
inline void ExtendedBlockProto::set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_numbytes(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExtendedBlockProto.numBytes)
}

// -------------------------------------------------------------------

// DatanodeIDProto

// required string ipAddr = 1;
inline bool DatanodeIDProto::_internal_has_ipaddr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_ipaddr() const {
  return _internal_has_ipaddr();
}
inline void DatanodeIDProto::clear_ipaddr() {
  ipaddr_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatanodeIDProto::ipaddr() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.ipAddr)
  return _internal_ipaddr();
}
inline void DatanodeIDProto::set_ipaddr(const std::string& value) {
  _internal_set_ipaddr(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.ipAddr)
}
inline std::string* DatanodeIDProto::mutable_ipaddr() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeIDProto.ipAddr)
  return _internal_mutable_ipaddr();
}
inline const std::string& DatanodeIDProto::_internal_ipaddr() const {
  return ipaddr_.GetNoArena();
}
inline void DatanodeIDProto::_internal_set_ipaddr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ipaddr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DatanodeIDProto::set_ipaddr(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ipaddr_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DatanodeIDProto.ipAddr)
}
inline void DatanodeIDProto::set_ipaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ipaddr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DatanodeIDProto.ipAddr)
}
inline void DatanodeIDProto::set_ipaddr(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ipaddr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DatanodeIDProto.ipAddr)
}
inline std::string* DatanodeIDProto::_internal_mutable_ipaddr() {
  _has_bits_[0] |= 0x00000001u;
  return ipaddr_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DatanodeIDProto::release_ipaddr() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DatanodeIDProto.ipAddr)
  if (!_internal_has_ipaddr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ipaddr_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_ipaddr(std::string* ipaddr) {
  if (ipaddr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ipaddr_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddr);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DatanodeIDProto.ipAddr)
}

// required string hostName = 2;
inline bool DatanodeIDProto::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_hostname() const {
  return _internal_has_hostname();
}
inline void DatanodeIDProto::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DatanodeIDProto::hostname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.hostName)
  return _internal_hostname();
}
inline void DatanodeIDProto::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.hostName)
}
inline std::string* DatanodeIDProto::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeIDProto.hostName)
  return _internal_mutable_hostname();
}
inline const std::string& DatanodeIDProto::_internal_hostname() const {
  return hostname_.GetNoArena();
}
inline void DatanodeIDProto::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DatanodeIDProto::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DatanodeIDProto.hostName)
}
inline void DatanodeIDProto::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  hostname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DatanodeIDProto.hostName)
}
inline void DatanodeIDProto::set_hostname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DatanodeIDProto.hostName)
}
inline std::string* DatanodeIDProto::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000002u;
  return hostname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DatanodeIDProto::release_hostname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DatanodeIDProto.hostName)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return hostname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hostname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DatanodeIDProto.hostName)
}

// required string datanodeUuid = 3;
inline bool DatanodeIDProto::_internal_has_datanodeuuid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_datanodeuuid() const {
  return _internal_has_datanodeuuid();
}
inline void DatanodeIDProto::clear_datanodeuuid() {
  datanodeuuid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DatanodeIDProto::datanodeuuid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
  return _internal_datanodeuuid();
}
inline void DatanodeIDProto::set_datanodeuuid(const std::string& value) {
  _internal_set_datanodeuuid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
}
inline std::string* DatanodeIDProto::mutable_datanodeuuid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
  return _internal_mutable_datanodeuuid();
}
inline const std::string& DatanodeIDProto::_internal_datanodeuuid() const {
  return datanodeuuid_.GetNoArena();
}
inline void DatanodeIDProto::_internal_set_datanodeuuid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  datanodeuuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DatanodeIDProto::set_datanodeuuid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  datanodeuuid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
}
inline void DatanodeIDProto::set_datanodeuuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  datanodeuuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
}
inline void DatanodeIDProto::set_datanodeuuid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  datanodeuuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
}
inline std::string* DatanodeIDProto::_internal_mutable_datanodeuuid() {
  _has_bits_[0] |= 0x00000004u;
  return datanodeuuid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DatanodeIDProto::release_datanodeuuid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
  if (!_internal_has_datanodeuuid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return datanodeuuid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_datanodeuuid(std::string* datanodeuuid) {
  if (datanodeuuid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  datanodeuuid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datanodeuuid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DatanodeIDProto.datanodeUuid)
}

// required uint32 xferPort = 4;
inline bool DatanodeIDProto::_internal_has_xferport() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_xferport() const {
  return _internal_has_xferport();
}
inline void DatanodeIDProto::clear_xferport() {
  xferport_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::_internal_xferport() const {
  return xferport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::xferport() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.xferPort)
  return _internal_xferport();
}
inline void DatanodeIDProto::_internal_set_xferport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  xferport_ = value;
}
inline void DatanodeIDProto::set_xferport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_xferport(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.xferPort)
}

// required uint32 infoPort = 5;
inline bool DatanodeIDProto::_internal_has_infoport() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_infoport() const {
  return _internal_has_infoport();
}
inline void DatanodeIDProto::clear_infoport() {
  infoport_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::_internal_infoport() const {
  return infoport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::infoport() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.infoPort)
  return _internal_infoport();
}
inline void DatanodeIDProto::_internal_set_infoport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  infoport_ = value;
}
inline void DatanodeIDProto::set_infoport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_infoport(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.infoPort)
}

// required uint32 ipcPort = 6;
inline bool DatanodeIDProto::_internal_has_ipcport() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_ipcport() const {
  return _internal_has_ipcport();
}
inline void DatanodeIDProto::clear_ipcport() {
  ipcport_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::_internal_ipcport() const {
  return ipcport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::ipcport() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.ipcPort)
  return _internal_ipcport();
}
inline void DatanodeIDProto::_internal_set_ipcport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  ipcport_ = value;
}
inline void DatanodeIDProto::set_ipcport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ipcport(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.ipcPort)
}

// optional uint32 infoSecurePort = 7 [default = 0];
inline bool DatanodeIDProto::_internal_has_infosecureport() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DatanodeIDProto::has_infosecureport() const {
  return _internal_has_infosecureport();
}
inline void DatanodeIDProto::clear_infosecureport() {
  infosecureport_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::_internal_infosecureport() const {
  return infosecureport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeIDProto::infosecureport() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeIDProto.infoSecurePort)
  return _internal_infosecureport();
}
inline void DatanodeIDProto::_internal_set_infosecureport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  infosecureport_ = value;
}
inline void DatanodeIDProto::set_infosecureport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_infosecureport(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeIDProto.infoSecurePort)
}

// -------------------------------------------------------------------

// DatanodeInfosProto

// repeated .Hdfs.Internal.DatanodeInfoProto datanodes = 1;
inline int DatanodeInfosProto::_internal_datanodes_size() const {
  return datanodes_.size();
}
inline int DatanodeInfosProto::datanodes_size() const {
  return _internal_datanodes_size();
}
inline void DatanodeInfosProto::clear_datanodes() {
  datanodes_.Clear();
}
inline ::Hdfs::Internal::DatanodeInfoProto* DatanodeInfosProto::mutable_datanodes(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeInfosProto.datanodes)
  return datanodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
DatanodeInfosProto::mutable_datanodes() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.DatanodeInfosProto.datanodes)
  return &datanodes_;
}
inline const ::Hdfs::Internal::DatanodeInfoProto& DatanodeInfosProto::_internal_datanodes(int index) const {
  return datanodes_.Get(index);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& DatanodeInfosProto::datanodes(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfosProto.datanodes)
  return _internal_datanodes(index);
}
inline ::Hdfs::Internal::DatanodeInfoProto* DatanodeInfosProto::_internal_add_datanodes() {
  return datanodes_.Add();
}
inline ::Hdfs::Internal::DatanodeInfoProto* DatanodeInfosProto::add_datanodes() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.DatanodeInfosProto.datanodes)
  return _internal_add_datanodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
DatanodeInfosProto::datanodes() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.DatanodeInfosProto.datanodes)
  return datanodes_;
}

// -------------------------------------------------------------------

// DatanodeInfoProto

// required .Hdfs.Internal.DatanodeIDProto id = 1;
inline bool DatanodeInfoProto::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool DatanodeInfoProto::has_id() const {
  return _internal_has_id();
}
inline void DatanodeInfoProto::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::DatanodeIDProto& DatanodeInfoProto::_internal_id() const {
  const ::Hdfs::Internal::DatanodeIDProto* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::DatanodeIDProto*>(
      &::Hdfs::Internal::_DatanodeIDProto_default_instance_);
}
inline const ::Hdfs::Internal::DatanodeIDProto& DatanodeInfoProto::id() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.id)
  return _internal_id();
}
inline ::Hdfs::Internal::DatanodeIDProto* DatanodeInfoProto::release_id() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DatanodeInfoProto.id)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::DatanodeIDProto* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::DatanodeIDProto* DatanodeInfoProto::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000002u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::DatanodeIDProto>(GetArenaNoVirtual());
    id_ = p;
  }
  return id_;
}
inline ::Hdfs::Internal::DatanodeIDProto* DatanodeInfoProto::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeInfoProto.id)
  return _internal_mutable_id();
}
inline void DatanodeInfoProto::set_allocated_id(::Hdfs::Internal::DatanodeIDProto* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DatanodeInfoProto.id)
}

// optional uint64 capacity = 2 [default = 0];
inline bool DatanodeInfoProto::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_capacity() const {
  return _internal_has_capacity();
}
inline void DatanodeInfoProto::clear_capacity() {
  capacity_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_capacity() const {
  return capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::capacity() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.capacity)
  return _internal_capacity();
}
inline void DatanodeInfoProto::_internal_set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  capacity_ = value;
}
inline void DatanodeInfoProto::set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.capacity)
}

// optional uint64 dfsUsed = 3 [default = 0];
inline bool DatanodeInfoProto::_internal_has_dfsused() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_dfsused() const {
  return _internal_has_dfsused();
}
inline void DatanodeInfoProto::clear_dfsused() {
  dfsused_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_dfsused() const {
  return dfsused_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::dfsused() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.dfsUsed)
  return _internal_dfsused();
}
inline void DatanodeInfoProto::_internal_set_dfsused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  dfsused_ = value;
}
inline void DatanodeInfoProto::set_dfsused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_dfsused(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.dfsUsed)
}

// optional uint64 remaining = 4 [default = 0];
inline bool DatanodeInfoProto::_internal_has_remaining() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_remaining() const {
  return _internal_has_remaining();
}
inline void DatanodeInfoProto::clear_remaining() {
  remaining_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_remaining() const {
  return remaining_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::remaining() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.remaining)
  return _internal_remaining();
}
inline void DatanodeInfoProto::_internal_set_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  remaining_ = value;
}
inline void DatanodeInfoProto::set_remaining(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_remaining(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.remaining)
}

// optional uint64 blockPoolUsed = 5 [default = 0];
inline bool DatanodeInfoProto::_internal_has_blockpoolused() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_blockpoolused() const {
  return _internal_has_blockpoolused();
}
inline void DatanodeInfoProto::clear_blockpoolused() {
  blockpoolused_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_blockpoolused() const {
  return blockpoolused_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::blockpoolused() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.blockPoolUsed)
  return _internal_blockpoolused();
}
inline void DatanodeInfoProto::_internal_set_blockpoolused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  blockpoolused_ = value;
}
inline void DatanodeInfoProto::set_blockpoolused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blockpoolused(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.blockPoolUsed)
}

// optional uint64 lastUpdate = 6 [default = 0];
inline bool DatanodeInfoProto::_internal_has_lastupdate() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_lastupdate() const {
  return _internal_has_lastupdate();
}
inline void DatanodeInfoProto::clear_lastupdate() {
  lastupdate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_lastupdate() const {
  return lastupdate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::lastupdate() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.lastUpdate)
  return _internal_lastupdate();
}
inline void DatanodeInfoProto::_internal_set_lastupdate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  lastupdate_ = value;
}
inline void DatanodeInfoProto::set_lastupdate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_lastupdate(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.lastUpdate)
}

// optional uint32 xceiverCount = 7 [default = 0];
inline bool DatanodeInfoProto::_internal_has_xceivercount() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_xceivercount() const {
  return _internal_has_xceivercount();
}
inline void DatanodeInfoProto::clear_xceivercount() {
  xceivercount_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeInfoProto::_internal_xceivercount() const {
  return xceivercount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DatanodeInfoProto::xceivercount() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.xceiverCount)
  return _internal_xceivercount();
}
inline void DatanodeInfoProto::_internal_set_xceivercount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  xceivercount_ = value;
}
inline void DatanodeInfoProto::set_xceivercount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_xceivercount(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.xceiverCount)
}

// optional string location = 8;
inline bool DatanodeInfoProto::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_location() const {
  return _internal_has_location();
}
inline void DatanodeInfoProto::clear_location() {
  location_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatanodeInfoProto::location() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.location)
  return _internal_location();
}
inline void DatanodeInfoProto::set_location(const std::string& value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.location)
}
inline std::string* DatanodeInfoProto::mutable_location() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DatanodeInfoProto.location)
  return _internal_mutable_location();
}
inline const std::string& DatanodeInfoProto::_internal_location() const {
  return location_.GetNoArena();
}
inline void DatanodeInfoProto::_internal_set_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DatanodeInfoProto::set_location(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DatanodeInfoProto.location)
}
inline void DatanodeInfoProto::set_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DatanodeInfoProto.location)
}
inline void DatanodeInfoProto::set_location(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DatanodeInfoProto.location)
}
inline std::string* DatanodeInfoProto::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  return location_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DatanodeInfoProto::release_location() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DatanodeInfoProto.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return location_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeInfoProto::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DatanodeInfoProto.location)
}

// optional .Hdfs.Internal.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
inline bool DatanodeInfoProto::_internal_has_adminstate() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_adminstate() const {
  return _internal_has_adminstate();
}
inline void DatanodeInfoProto::clear_adminstate() {
  adminstate_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::Hdfs::Internal::DatanodeInfoProto_AdminState DatanodeInfoProto::_internal_adminstate() const {
  return static_cast< ::Hdfs::Internal::DatanodeInfoProto_AdminState >(adminstate_);
}
inline ::Hdfs::Internal::DatanodeInfoProto_AdminState DatanodeInfoProto::adminstate() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.adminState)
  return _internal_adminstate();
}
inline void DatanodeInfoProto::_internal_set_adminstate(::Hdfs::Internal::DatanodeInfoProto_AdminState value) {
  assert(::Hdfs::Internal::DatanodeInfoProto_AdminState_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  adminstate_ = value;
}
inline void DatanodeInfoProto::set_adminstate(::Hdfs::Internal::DatanodeInfoProto_AdminState value) {
  _internal_set_adminstate(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.adminState)
}

// optional uint64 cacheCapacity = 11 [default = 0];
inline bool DatanodeInfoProto::_internal_has_cachecapacity() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_cachecapacity() const {
  return _internal_has_cachecapacity();
}
inline void DatanodeInfoProto::clear_cachecapacity() {
  cachecapacity_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_cachecapacity() const {
  return cachecapacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::cachecapacity() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.cacheCapacity)
  return _internal_cachecapacity();
}
inline void DatanodeInfoProto::_internal_set_cachecapacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  cachecapacity_ = value;
}
inline void DatanodeInfoProto::set_cachecapacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cachecapacity(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.cacheCapacity)
}

// optional uint64 cacheUsed = 12 [default = 0];
inline bool DatanodeInfoProto::_internal_has_cacheused() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DatanodeInfoProto::has_cacheused() const {
  return _internal_has_cacheused();
}
inline void DatanodeInfoProto::clear_cacheused() {
  cacheused_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::_internal_cacheused() const {
  return cacheused_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatanodeInfoProto::cacheused() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DatanodeInfoProto.cacheUsed)
  return _internal_cacheused();
}
inline void DatanodeInfoProto::_internal_set_cacheused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  cacheused_ = value;
}
inline void DatanodeInfoProto::set_cacheused(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cacheused(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DatanodeInfoProto.cacheUsed)
}

// -------------------------------------------------------------------

// ContentSummaryProto

// required uint64 length = 1;
inline bool ContentSummaryProto::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_length() const {
  return _internal_has_length();
}
inline void ContentSummaryProto::clear_length() {
  length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_length() const {
  return length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::length() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.length)
  return _internal_length();
}
inline void ContentSummaryProto::_internal_set_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  length_ = value;
}
inline void ContentSummaryProto::set_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.length)
}

// required uint64 fileCount = 2;
inline bool ContentSummaryProto::_internal_has_filecount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_filecount() const {
  return _internal_has_filecount();
}
inline void ContentSummaryProto::clear_filecount() {
  filecount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_filecount() const {
  return filecount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::filecount() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.fileCount)
  return _internal_filecount();
}
inline void ContentSummaryProto::_internal_set_filecount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  filecount_ = value;
}
inline void ContentSummaryProto::set_filecount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_filecount(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.fileCount)
}

// required uint64 directoryCount = 3;
inline bool ContentSummaryProto::_internal_has_directorycount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_directorycount() const {
  return _internal_has_directorycount();
}
inline void ContentSummaryProto::clear_directorycount() {
  directorycount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_directorycount() const {
  return directorycount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::directorycount() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.directoryCount)
  return _internal_directorycount();
}
inline void ContentSummaryProto::_internal_set_directorycount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  directorycount_ = value;
}
inline void ContentSummaryProto::set_directorycount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_directorycount(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.directoryCount)
}

// required uint64 quota = 4;
inline bool ContentSummaryProto::_internal_has_quota() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_quota() const {
  return _internal_has_quota();
}
inline void ContentSummaryProto::clear_quota() {
  quota_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_quota() const {
  return quota_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::quota() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.quota)
  return _internal_quota();
}
inline void ContentSummaryProto::_internal_set_quota(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  quota_ = value;
}
inline void ContentSummaryProto::set_quota(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_quota(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.quota)
}

// required uint64 spaceConsumed = 5;
inline bool ContentSummaryProto::_internal_has_spaceconsumed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_spaceconsumed() const {
  return _internal_has_spaceconsumed();
}
inline void ContentSummaryProto::clear_spaceconsumed() {
  spaceconsumed_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_spaceconsumed() const {
  return spaceconsumed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::spaceconsumed() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.spaceConsumed)
  return _internal_spaceconsumed();
}
inline void ContentSummaryProto::_internal_set_spaceconsumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  spaceconsumed_ = value;
}
inline void ContentSummaryProto::set_spaceconsumed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_spaceconsumed(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.spaceConsumed)
}

// required uint64 spaceQuota = 6;
inline bool ContentSummaryProto::_internal_has_spacequota() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContentSummaryProto::has_spacequota() const {
  return _internal_has_spacequota();
}
inline void ContentSummaryProto::clear_spacequota() {
  spacequota_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::_internal_spacequota() const {
  return spacequota_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ContentSummaryProto::spacequota() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ContentSummaryProto.spaceQuota)
  return _internal_spacequota();
}
inline void ContentSummaryProto::_internal_set_spacequota(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  spacequota_ = value;
}
inline void ContentSummaryProto::set_spacequota(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_spacequota(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ContentSummaryProto.spaceQuota)
}

// -------------------------------------------------------------------

// CorruptFileBlocksProto

// repeated string files = 1;
inline int CorruptFileBlocksProto::_internal_files_size() const {
  return files_.size();
}
inline int CorruptFileBlocksProto::files_size() const {
  return _internal_files_size();
}
inline void CorruptFileBlocksProto::clear_files() {
  files_.Clear();
}
inline std::string* CorruptFileBlocksProto::add_files() {
  // @@protoc_insertion_point(field_add_mutable:Hdfs.Internal.CorruptFileBlocksProto.files)
  return _internal_add_files();
}
inline const std::string& CorruptFileBlocksProto::_internal_files(int index) const {
  return files_.Get(index);
}
inline const std::string& CorruptFileBlocksProto::files(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CorruptFileBlocksProto.files)
  return _internal_files(index);
}
inline std::string* CorruptFileBlocksProto::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CorruptFileBlocksProto.files)
  return files_.Mutable(index);
}
inline void CorruptFileBlocksProto::set_files(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CorruptFileBlocksProto.files)
  files_.Mutable(index)->assign(value);
}
inline void CorruptFileBlocksProto::set_files(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CorruptFileBlocksProto.files)
  files_.Mutable(index)->assign(std::move(value));
}
inline void CorruptFileBlocksProto::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline void CorruptFileBlocksProto::set_files(int index, const char* value, size_t size) {
  files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline std::string* CorruptFileBlocksProto::_internal_add_files() {
  return files_.Add();
}
inline void CorruptFileBlocksProto::add_files(const std::string& value) {
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline void CorruptFileBlocksProto::add_files(std::string&& value) {
  files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline void CorruptFileBlocksProto::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline void CorruptFileBlocksProto::add_files(const char* value, size_t size) {
  files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hdfs.Internal.CorruptFileBlocksProto.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CorruptFileBlocksProto::files() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.CorruptFileBlocksProto.files)
  return files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CorruptFileBlocksProto::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.CorruptFileBlocksProto.files)
  return &files_;
}

// required string cookie = 2;
inline bool CorruptFileBlocksProto::_internal_has_cookie() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CorruptFileBlocksProto::has_cookie() const {
  return _internal_has_cookie();
}
inline void CorruptFileBlocksProto::clear_cookie() {
  cookie_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CorruptFileBlocksProto::cookie() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CorruptFileBlocksProto.cookie)
  return _internal_cookie();
}
inline void CorruptFileBlocksProto::set_cookie(const std::string& value) {
  _internal_set_cookie(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CorruptFileBlocksProto.cookie)
}
inline std::string* CorruptFileBlocksProto::mutable_cookie() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CorruptFileBlocksProto.cookie)
  return _internal_mutable_cookie();
}
inline const std::string& CorruptFileBlocksProto::_internal_cookie() const {
  return cookie_.GetNoArena();
}
inline void CorruptFileBlocksProto::_internal_set_cookie(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cookie_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CorruptFileBlocksProto::set_cookie(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cookie_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CorruptFileBlocksProto.cookie)
}
inline void CorruptFileBlocksProto::set_cookie(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cookie_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CorruptFileBlocksProto.cookie)
}
inline void CorruptFileBlocksProto::set_cookie(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cookie_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CorruptFileBlocksProto.cookie)
}
inline std::string* CorruptFileBlocksProto::_internal_mutable_cookie() {
  _has_bits_[0] |= 0x00000001u;
  return cookie_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CorruptFileBlocksProto::release_cookie() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CorruptFileBlocksProto.cookie)
  if (!_internal_has_cookie()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cookie_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CorruptFileBlocksProto::set_allocated_cookie(std::string* cookie) {
  if (cookie != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cookie_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cookie);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CorruptFileBlocksProto.cookie)
}

// -------------------------------------------------------------------

// FsPermissionProto

// required uint32 perm = 1;
inline bool FsPermissionProto::_internal_has_perm() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FsPermissionProto::has_perm() const {
  return _internal_has_perm();
}
inline void FsPermissionProto::clear_perm() {
  perm_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsPermissionProto::_internal_perm() const {
  return perm_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsPermissionProto::perm() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsPermissionProto.perm)
  return _internal_perm();
}
inline void FsPermissionProto::_internal_set_perm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  perm_ = value;
}
inline void FsPermissionProto::set_perm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsPermissionProto.perm)
}

// -------------------------------------------------------------------

// StorageUuidsProto

// repeated string storageUuids = 1;
inline int StorageUuidsProto::_internal_storageuuids_size() const {
  return storageuuids_.size();
}
inline int StorageUuidsProto::storageuuids_size() const {
  return _internal_storageuuids_size();
}
inline void StorageUuidsProto::clear_storageuuids() {
  storageuuids_.Clear();
}
inline std::string* StorageUuidsProto::add_storageuuids() {
  // @@protoc_insertion_point(field_add_mutable:Hdfs.Internal.StorageUuidsProto.storageUuids)
  return _internal_add_storageuuids();
}
inline const std::string& StorageUuidsProto::_internal_storageuuids(int index) const {
  return storageuuids_.Get(index);
}
inline const std::string& StorageUuidsProto::storageuuids(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.StorageUuidsProto.storageUuids)
  return _internal_storageuuids(index);
}
inline std::string* StorageUuidsProto::mutable_storageuuids(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.StorageUuidsProto.storageUuids)
  return storageuuids_.Mutable(index);
}
inline void StorageUuidsProto::set_storageuuids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageUuidsProto.storageUuids)
  storageuuids_.Mutable(index)->assign(value);
}
inline void StorageUuidsProto::set_storageuuids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageUuidsProto.storageUuids)
  storageuuids_.Mutable(index)->assign(std::move(value));
}
inline void StorageUuidsProto::set_storageuuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline void StorageUuidsProto::set_storageuuids(int index, const char* value, size_t size) {
  storageuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline std::string* StorageUuidsProto::_internal_add_storageuuids() {
  return storageuuids_.Add();
}
inline void StorageUuidsProto::add_storageuuids(const std::string& value) {
  storageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline void StorageUuidsProto::add_storageuuids(std::string&& value) {
  storageuuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline void StorageUuidsProto::add_storageuuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline void StorageUuidsProto::add_storageuuids(const char* value, size_t size) {
  storageuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hdfs.Internal.StorageUuidsProto.storageUuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StorageUuidsProto::storageuuids() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.StorageUuidsProto.storageUuids)
  return storageuuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StorageUuidsProto::mutable_storageuuids() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.StorageUuidsProto.storageUuids)
  return &storageuuids_;
}

// -------------------------------------------------------------------

// LocatedBlockProto

// required .Hdfs.Internal.ExtendedBlockProto b = 1;
inline bool LocatedBlockProto::_internal_has_b() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || b_ != nullptr);
  return value;
}
inline bool LocatedBlockProto::has_b() const {
  return _internal_has_b();
}
inline void LocatedBlockProto::clear_b() {
  if (b_ != nullptr) b_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::ExtendedBlockProto& LocatedBlockProto::_internal_b() const {
  const ::Hdfs::Internal::ExtendedBlockProto* p = b_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::ExtendedBlockProto*>(
      &::Hdfs::Internal::_ExtendedBlockProto_default_instance_);
}
inline const ::Hdfs::Internal::ExtendedBlockProto& LocatedBlockProto::b() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.b)
  return _internal_b();
}
inline ::Hdfs::Internal::ExtendedBlockProto* LocatedBlockProto::release_b() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.LocatedBlockProto.b)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::ExtendedBlockProto* temp = b_;
  b_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::ExtendedBlockProto* LocatedBlockProto::_internal_mutable_b() {
  _has_bits_[0] |= 0x00000001u;
  if (b_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::ExtendedBlockProto>(GetArenaNoVirtual());
    b_ = p;
  }
  return b_;
}
inline ::Hdfs::Internal::ExtendedBlockProto* LocatedBlockProto::mutable_b() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlockProto.b)
  return _internal_mutable_b();
}
inline void LocatedBlockProto::set_allocated_b(::Hdfs::Internal::ExtendedBlockProto* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete b_;
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  b_ = b;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.LocatedBlockProto.b)
}

// required uint64 offset = 2;
inline bool LocatedBlockProto::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocatedBlockProto::has_offset() const {
  return _internal_has_offset();
}
inline void LocatedBlockProto::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocatedBlockProto::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocatedBlockProto::offset() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.offset)
  return _internal_offset();
}
inline void LocatedBlockProto::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void LocatedBlockProto::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.offset)
}

// repeated .Hdfs.Internal.DatanodeInfoProto locs = 3;
inline int LocatedBlockProto::_internal_locs_size() const {
  return locs_.size();
}
inline int LocatedBlockProto::locs_size() const {
  return _internal_locs_size();
}
inline void LocatedBlockProto::clear_locs() {
  locs_.Clear();
}
inline ::Hdfs::Internal::DatanodeInfoProto* LocatedBlockProto::mutable_locs(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlockProto.locs)
  return locs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >*
LocatedBlockProto::mutable_locs() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.LocatedBlockProto.locs)
  return &locs_;
}
inline const ::Hdfs::Internal::DatanodeInfoProto& LocatedBlockProto::_internal_locs(int index) const {
  return locs_.Get(index);
}
inline const ::Hdfs::Internal::DatanodeInfoProto& LocatedBlockProto::locs(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.locs)
  return _internal_locs(index);
}
inline ::Hdfs::Internal::DatanodeInfoProto* LocatedBlockProto::_internal_add_locs() {
  return locs_.Add();
}
inline ::Hdfs::Internal::DatanodeInfoProto* LocatedBlockProto::add_locs() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlockProto.locs)
  return _internal_add_locs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::DatanodeInfoProto >&
LocatedBlockProto::locs() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.LocatedBlockProto.locs)
  return locs_;
}

// required bool corrupt = 4;
inline bool LocatedBlockProto::_internal_has_corrupt() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocatedBlockProto::has_corrupt() const {
  return _internal_has_corrupt();
}
inline void LocatedBlockProto::clear_corrupt() {
  corrupt_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool LocatedBlockProto::_internal_corrupt() const {
  return corrupt_;
}
inline bool LocatedBlockProto::corrupt() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.corrupt)
  return _internal_corrupt();
}
inline void LocatedBlockProto::_internal_set_corrupt(bool value) {
  _has_bits_[0] |= 0x00000008u;
  corrupt_ = value;
}
inline void LocatedBlockProto::set_corrupt(bool value) {
  _internal_set_corrupt(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.corrupt)
}

// required .Hdfs.Internal.TokenProto blockToken = 5;
inline bool LocatedBlockProto::_internal_has_blocktoken() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || blocktoken_ != nullptr);
  return value;
}
inline bool LocatedBlockProto::has_blocktoken() const {
  return _internal_has_blocktoken();
}
inline const ::Hdfs::Internal::TokenProto& LocatedBlockProto::_internal_blocktoken() const {
  const ::Hdfs::Internal::TokenProto* p = blocktoken_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::TokenProto*>(
      &::Hdfs::Internal::_TokenProto_default_instance_);
}
inline const ::Hdfs::Internal::TokenProto& LocatedBlockProto::blocktoken() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.blockToken)
  return _internal_blocktoken();
}
inline ::Hdfs::Internal::TokenProto* LocatedBlockProto::release_blocktoken() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.LocatedBlockProto.blockToken)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::TokenProto* temp = blocktoken_;
  blocktoken_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::TokenProto* LocatedBlockProto::_internal_mutable_blocktoken() {
  _has_bits_[0] |= 0x00000002u;
  if (blocktoken_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::TokenProto>(GetArenaNoVirtual());
    blocktoken_ = p;
  }
  return blocktoken_;
}
inline ::Hdfs::Internal::TokenProto* LocatedBlockProto::mutable_blocktoken() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlockProto.blockToken)
  return _internal_mutable_blocktoken();
}
inline void LocatedBlockProto::set_allocated_blocktoken(::Hdfs::Internal::TokenProto* blocktoken) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(blocktoken_);
  }
  if (blocktoken) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      blocktoken = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blocktoken, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blocktoken_ = blocktoken;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.LocatedBlockProto.blockToken)
}

// repeated bool isCached = 6 [packed = true];
inline int LocatedBlockProto::_internal_iscached_size() const {
  return iscached_.size();
}
inline int LocatedBlockProto::iscached_size() const {
  return _internal_iscached_size();
}
inline void LocatedBlockProto::clear_iscached() {
  iscached_.Clear();
}
inline bool LocatedBlockProto::_internal_iscached(int index) const {
  return iscached_.Get(index);
}
inline bool LocatedBlockProto::iscached(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.isCached)
  return _internal_iscached(index);
}
inline void LocatedBlockProto::set_iscached(int index, bool value) {
  iscached_.Set(index, value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.isCached)
}
inline void LocatedBlockProto::_internal_add_iscached(bool value) {
  iscached_.Add(value);
}
inline void LocatedBlockProto::add_iscached(bool value) {
  _internal_add_iscached(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlockProto.isCached)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
LocatedBlockProto::_internal_iscached() const {
  return iscached_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
LocatedBlockProto::iscached() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.LocatedBlockProto.isCached)
  return _internal_iscached();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
LocatedBlockProto::_internal_mutable_iscached() {
  return &iscached_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
LocatedBlockProto::mutable_iscached() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.LocatedBlockProto.isCached)
  return _internal_mutable_iscached();
}

// repeated .Hdfs.Internal.StorageTypeProto storageTypes = 7;
inline int LocatedBlockProto::_internal_storagetypes_size() const {
  return storagetypes_.size();
}
inline int LocatedBlockProto::storagetypes_size() const {
  return _internal_storagetypes_size();
}
inline void LocatedBlockProto::clear_storagetypes() {
  storagetypes_.Clear();
}
inline ::Hdfs::Internal::StorageTypeProto LocatedBlockProto::_internal_storagetypes(int index) const {
  return static_cast< ::Hdfs::Internal::StorageTypeProto >(storagetypes_.Get(index));
}
inline ::Hdfs::Internal::StorageTypeProto LocatedBlockProto::storagetypes(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.storageTypes)
  return _internal_storagetypes(index);
}
inline void LocatedBlockProto::set_storagetypes(int index, ::Hdfs::Internal::StorageTypeProto value) {
  assert(::Hdfs::Internal::StorageTypeProto_IsValid(value));
  storagetypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.storageTypes)
}
inline void LocatedBlockProto::_internal_add_storagetypes(::Hdfs::Internal::StorageTypeProto value) {
  assert(::Hdfs::Internal::StorageTypeProto_IsValid(value));
  storagetypes_.Add(value);
}
inline void LocatedBlockProto::add_storagetypes(::Hdfs::Internal::StorageTypeProto value) {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlockProto.storageTypes)
  _internal_add_storagetypes(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
LocatedBlockProto::storagetypes() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.LocatedBlockProto.storageTypes)
  return storagetypes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
LocatedBlockProto::_internal_mutable_storagetypes() {
  return &storagetypes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
LocatedBlockProto::mutable_storagetypes() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.LocatedBlockProto.storageTypes)
  return _internal_mutable_storagetypes();
}

// repeated string storageIDs = 8;
inline int LocatedBlockProto::_internal_storageids_size() const {
  return storageids_.size();
}
inline int LocatedBlockProto::storageids_size() const {
  return _internal_storageids_size();
}
inline void LocatedBlockProto::clear_storageids() {
  storageids_.Clear();
}
inline std::string* LocatedBlockProto::add_storageids() {
  // @@protoc_insertion_point(field_add_mutable:Hdfs.Internal.LocatedBlockProto.storageIDs)
  return _internal_add_storageids();
}
inline const std::string& LocatedBlockProto::_internal_storageids(int index) const {
  return storageids_.Get(index);
}
inline const std::string& LocatedBlockProto::storageids(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlockProto.storageIDs)
  return _internal_storageids(index);
}
inline std::string* LocatedBlockProto::mutable_storageids(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlockProto.storageIDs)
  return storageids_.Mutable(index);
}
inline void LocatedBlockProto::set_storageids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.storageIDs)
  storageids_.Mutable(index)->assign(value);
}
inline void LocatedBlockProto::set_storageids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlockProto.storageIDs)
  storageids_.Mutable(index)->assign(std::move(value));
}
inline void LocatedBlockProto::set_storageids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::set_storageids(int index, const char* value, size_t size) {
  storageids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline std::string* LocatedBlockProto::_internal_add_storageids() {
  return storageids_.Add();
}
inline void LocatedBlockProto::add_storageids(const std::string& value) {
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::add_storageids(std::string&& value) {
  storageids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::add_storageids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::add_storageids(const char* value, size_t size) {
  storageids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hdfs.Internal.LocatedBlockProto.storageIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LocatedBlockProto::storageids() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.LocatedBlockProto.storageIDs)
  return storageids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LocatedBlockProto::mutable_storageids() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.LocatedBlockProto.storageIDs)
  return &storageids_;
}

// -------------------------------------------------------------------

// DataEncryptionKeyProto

// required uint32 keyId = 1;
inline bool DataEncryptionKeyProto::_internal_has_keyid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_keyid() const {
  return _internal_has_keyid();
}
inline void DataEncryptionKeyProto::clear_keyid() {
  keyid_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataEncryptionKeyProto::_internal_keyid() const {
  return keyid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataEncryptionKeyProto::keyid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.keyId)
  return _internal_keyid();
}
inline void DataEncryptionKeyProto::_internal_set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  keyid_ = value;
}
inline void DataEncryptionKeyProto::set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_keyid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.keyId)
}

// required string blockPoolId = 2;
inline bool DataEncryptionKeyProto::_internal_has_blockpoolid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_blockpoolid() const {
  return _internal_has_blockpoolid();
}
inline void DataEncryptionKeyProto::clear_blockpoolid() {
  blockpoolid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataEncryptionKeyProto::blockpoolid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
  return _internal_blockpoolid();
}
inline void DataEncryptionKeyProto::set_blockpoolid(const std::string& value) {
  _internal_set_blockpoolid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
}
inline std::string* DataEncryptionKeyProto::mutable_blockpoolid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
  return _internal_mutable_blockpoolid();
}
inline const std::string& DataEncryptionKeyProto::_internal_blockpoolid() const {
  return blockpoolid_.GetNoArena();
}
inline void DataEncryptionKeyProto::_internal_set_blockpoolid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataEncryptionKeyProto::set_blockpoolid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
}
inline void DataEncryptionKeyProto::set_blockpoolid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
}
inline void DataEncryptionKeyProto::set_blockpoolid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
}
inline std::string* DataEncryptionKeyProto::_internal_mutable_blockpoolid() {
  _has_bits_[0] |= 0x00000001u;
  return blockpoolid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataEncryptionKeyProto::release_blockpoolid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
  if (!_internal_has_blockpoolid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return blockpoolid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataEncryptionKeyProto::set_allocated_blockpoolid(std::string* blockpoolid) {
  if (blockpoolid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blockpoolid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockpoolid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataEncryptionKeyProto.blockPoolId)
}

// required bytes nonce = 3;
inline bool DataEncryptionKeyProto::_internal_has_nonce() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_nonce() const {
  return _internal_has_nonce();
}
inline void DataEncryptionKeyProto::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataEncryptionKeyProto::nonce() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.nonce)
  return _internal_nonce();
}
inline void DataEncryptionKeyProto::set_nonce(const std::string& value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.nonce)
}
inline std::string* DataEncryptionKeyProto::mutable_nonce() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataEncryptionKeyProto.nonce)
  return _internal_mutable_nonce();
}
inline const std::string& DataEncryptionKeyProto::_internal_nonce() const {
  return nonce_.GetNoArena();
}
inline void DataEncryptionKeyProto::_internal_set_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataEncryptionKeyProto::set_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nonce_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataEncryptionKeyProto.nonce)
}
inline void DataEncryptionKeyProto::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataEncryptionKeyProto.nonce)
}
inline void DataEncryptionKeyProto::set_nonce(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataEncryptionKeyProto.nonce)
}
inline std::string* DataEncryptionKeyProto::_internal_mutable_nonce() {
  _has_bits_[0] |= 0x00000002u;
  return nonce_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataEncryptionKeyProto::release_nonce() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataEncryptionKeyProto.nonce)
  if (!_internal_has_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nonce_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataEncryptionKeyProto::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nonce_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataEncryptionKeyProto.nonce)
}

// required bytes encryptionKey = 4;
inline bool DataEncryptionKeyProto::_internal_has_encryptionkey() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_encryptionkey() const {
  return _internal_has_encryptionkey();
}
inline void DataEncryptionKeyProto::clear_encryptionkey() {
  encryptionkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataEncryptionKeyProto::encryptionkey() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
  return _internal_encryptionkey();
}
inline void DataEncryptionKeyProto::set_encryptionkey(const std::string& value) {
  _internal_set_encryptionkey(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
}
inline std::string* DataEncryptionKeyProto::mutable_encryptionkey() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
  return _internal_mutable_encryptionkey();
}
inline const std::string& DataEncryptionKeyProto::_internal_encryptionkey() const {
  return encryptionkey_.GetNoArena();
}
inline void DataEncryptionKeyProto::_internal_set_encryptionkey(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  encryptionkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataEncryptionKeyProto::set_encryptionkey(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  encryptionkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
}
inline void DataEncryptionKeyProto::set_encryptionkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  encryptionkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
}
inline void DataEncryptionKeyProto::set_encryptionkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  encryptionkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
}
inline std::string* DataEncryptionKeyProto::_internal_mutable_encryptionkey() {
  _has_bits_[0] |= 0x00000004u;
  return encryptionkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataEncryptionKeyProto::release_encryptionkey() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
  if (!_internal_has_encryptionkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return encryptionkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataEncryptionKeyProto::set_allocated_encryptionkey(std::string* encryptionkey) {
  if (encryptionkey != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encryptionkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryptionkey);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataEncryptionKeyProto.encryptionKey)
}

// required uint64 expiryDate = 5;
inline bool DataEncryptionKeyProto::_internal_has_expirydate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_expirydate() const {
  return _internal_has_expirydate();
}
inline void DataEncryptionKeyProto::clear_expirydate() {
  expirydate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DataEncryptionKeyProto::_internal_expirydate() const {
  return expirydate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DataEncryptionKeyProto::expirydate() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.expiryDate)
  return _internal_expirydate();
}
inline void DataEncryptionKeyProto::_internal_set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  expirydate_ = value;
}
inline void DataEncryptionKeyProto::set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_expirydate(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.expiryDate)
}

// optional string encryptionAlgorithm = 6;
inline bool DataEncryptionKeyProto::_internal_has_encryptionalgorithm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataEncryptionKeyProto::has_encryptionalgorithm() const {
  return _internal_has_encryptionalgorithm();
}
inline void DataEncryptionKeyProto::clear_encryptionalgorithm() {
  encryptionalgorithm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataEncryptionKeyProto::encryptionalgorithm() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
  return _internal_encryptionalgorithm();
}
inline void DataEncryptionKeyProto::set_encryptionalgorithm(const std::string& value) {
  _internal_set_encryptionalgorithm(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
}
inline std::string* DataEncryptionKeyProto::mutable_encryptionalgorithm() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
  return _internal_mutable_encryptionalgorithm();
}
inline const std::string& DataEncryptionKeyProto::_internal_encryptionalgorithm() const {
  return encryptionalgorithm_.GetNoArena();
}
inline void DataEncryptionKeyProto::_internal_set_encryptionalgorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encryptionalgorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DataEncryptionKeyProto::set_encryptionalgorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  encryptionalgorithm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
}
inline void DataEncryptionKeyProto::set_encryptionalgorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  encryptionalgorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
}
inline void DataEncryptionKeyProto::set_encryptionalgorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  encryptionalgorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
}
inline std::string* DataEncryptionKeyProto::_internal_mutable_encryptionalgorithm() {
  _has_bits_[0] |= 0x00000008u;
  return encryptionalgorithm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DataEncryptionKeyProto::release_encryptionalgorithm() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
  if (!_internal_has_encryptionalgorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return encryptionalgorithm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DataEncryptionKeyProto::set_allocated_encryptionalgorithm(std::string* encryptionalgorithm) {
  if (encryptionalgorithm != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encryptionalgorithm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryptionalgorithm);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm)
}

// -------------------------------------------------------------------

// FileEncryptionInfoProto

// required .Hdfs.Internal.CipherSuiteProto suite = 1;
inline bool FileEncryptionInfoProto::_internal_has_suite() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_suite() const {
  return _internal_has_suite();
}
inline void FileEncryptionInfoProto::clear_suite() {
  suite_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Hdfs::Internal::CipherSuiteProto FileEncryptionInfoProto::_internal_suite() const {
  return static_cast< ::Hdfs::Internal::CipherSuiteProto >(suite_);
}
inline ::Hdfs::Internal::CipherSuiteProto FileEncryptionInfoProto::suite() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.suite)
  return _internal_suite();
}
inline void FileEncryptionInfoProto::_internal_set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  assert(::Hdfs::Internal::CipherSuiteProto_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  suite_ = value;
}
inline void FileEncryptionInfoProto::set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  _internal_set_suite(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.suite)
}

// required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion = 2;
inline bool FileEncryptionInfoProto::_internal_has_cryptoprotocolversion() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_cryptoprotocolversion() const {
  return _internal_has_cryptoprotocolversion();
}
inline void FileEncryptionInfoProto::clear_cryptoprotocolversion() {
  cryptoprotocolversion_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::Hdfs::Internal::CryptoProtocolVersionProto FileEncryptionInfoProto::_internal_cryptoprotocolversion() const {
  return static_cast< ::Hdfs::Internal::CryptoProtocolVersionProto >(cryptoprotocolversion_);
}
inline ::Hdfs::Internal::CryptoProtocolVersionProto FileEncryptionInfoProto::cryptoprotocolversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.cryptoProtocolVersion)
  return _internal_cryptoprotocolversion();
}
inline void FileEncryptionInfoProto::_internal_set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value) {
  assert(::Hdfs::Internal::CryptoProtocolVersionProto_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  cryptoprotocolversion_ = value;
}
inline void FileEncryptionInfoProto::set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value) {
  _internal_set_cryptoprotocolversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.cryptoProtocolVersion)
}

// required bytes key = 3;
inline bool FileEncryptionInfoProto::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_key() const {
  return _internal_has_key();
}
inline void FileEncryptionInfoProto::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileEncryptionInfoProto::key() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.key)
  return _internal_key();
}
inline void FileEncryptionInfoProto::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.key)
}
inline std::string* FileEncryptionInfoProto::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.FileEncryptionInfoProto.key)
  return _internal_mutable_key();
}
inline const std::string& FileEncryptionInfoProto::_internal_key() const {
  return key_.GetNoArena();
}
inline void FileEncryptionInfoProto::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FileEncryptionInfoProto::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.FileEncryptionInfoProto.key)
}
inline void FileEncryptionInfoProto::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.FileEncryptionInfoProto.key)
}
inline void FileEncryptionInfoProto::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.FileEncryptionInfoProto.key)
}
inline std::string* FileEncryptionInfoProto::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileEncryptionInfoProto::release_key() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.FileEncryptionInfoProto.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.FileEncryptionInfoProto.key)
}

// required bytes iv = 4;
inline bool FileEncryptionInfoProto::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_iv() const {
  return _internal_has_iv();
}
inline void FileEncryptionInfoProto::clear_iv() {
  iv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileEncryptionInfoProto::iv() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.iv)
  return _internal_iv();
}
inline void FileEncryptionInfoProto::set_iv(const std::string& value) {
  _internal_set_iv(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.iv)
}
inline std::string* FileEncryptionInfoProto::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.FileEncryptionInfoProto.iv)
  return _internal_mutable_iv();
}
inline const std::string& FileEncryptionInfoProto::_internal_iv() const {
  return iv_.GetNoArena();
}
inline void FileEncryptionInfoProto::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FileEncryptionInfoProto::set_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.FileEncryptionInfoProto.iv)
}
inline void FileEncryptionInfoProto::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.FileEncryptionInfoProto.iv)
}
inline void FileEncryptionInfoProto::set_iv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.FileEncryptionInfoProto.iv)
}
inline std::string* FileEncryptionInfoProto::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000002u;
  return iv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileEncryptionInfoProto::release_iv() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.FileEncryptionInfoProto.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return iv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  iv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.FileEncryptionInfoProto.iv)
}

// required string keyName = 5;
inline bool FileEncryptionInfoProto::_internal_has_keyname() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_keyname() const {
  return _internal_has_keyname();
}
inline void FileEncryptionInfoProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileEncryptionInfoProto::keyname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.keyName)
  return _internal_keyname();
}
inline void FileEncryptionInfoProto::set_keyname(const std::string& value) {
  _internal_set_keyname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.keyName)
}
inline std::string* FileEncryptionInfoProto::mutable_keyname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.FileEncryptionInfoProto.keyName)
  return _internal_mutable_keyname();
}
inline const std::string& FileEncryptionInfoProto::_internal_keyname() const {
  return keyname_.GetNoArena();
}
inline void FileEncryptionInfoProto::_internal_set_keyname(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FileEncryptionInfoProto::set_keyname(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  keyname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.FileEncryptionInfoProto.keyName)
}
inline void FileEncryptionInfoProto::set_keyname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.FileEncryptionInfoProto.keyName)
}
inline void FileEncryptionInfoProto::set_keyname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.FileEncryptionInfoProto.keyName)
}
inline std::string* FileEncryptionInfoProto::_internal_mutable_keyname() {
  _has_bits_[0] |= 0x00000004u;
  return keyname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileEncryptionInfoProto::release_keyname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.FileEncryptionInfoProto.keyName)
  if (!_internal_has_keyname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return keyname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_keyname(std::string* keyname) {
  if (keyname != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  keyname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.FileEncryptionInfoProto.keyName)
}

// required string ezKeyVersionName = 6;
inline bool FileEncryptionInfoProto::_internal_has_ezkeyversionname() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileEncryptionInfoProto::has_ezkeyversionname() const {
  return _internal_has_ezkeyversionname();
}
inline void FileEncryptionInfoProto::clear_ezkeyversionname() {
  ezkeyversionname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FileEncryptionInfoProto::ezkeyversionname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
  return _internal_ezkeyversionname();
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const std::string& value) {
  _internal_set_ezkeyversionname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
}
inline std::string* FileEncryptionInfoProto::mutable_ezkeyversionname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
  return _internal_mutable_ezkeyversionname();
}
inline const std::string& FileEncryptionInfoProto::_internal_ezkeyversionname() const {
  return ezkeyversionname_.GetNoArena();
}
inline void FileEncryptionInfoProto::_internal_set_ezkeyversionname(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  ezkeyversionname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
}
inline std::string* FileEncryptionInfoProto::_internal_mutable_ezkeyversionname() {
  _has_bits_[0] |= 0x00000008u;
  return ezkeyversionname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileEncryptionInfoProto::release_ezkeyversionname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
  if (!_internal_has_ezkeyversionname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return ezkeyversionname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_ezkeyversionname(std::string* ezkeyversionname) {
  if (ezkeyversionname != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ezkeyversionname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ezkeyversionname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName)
}

// -------------------------------------------------------------------

// PerFileEncryptionInfoProto

// required bytes key = 1;
inline bool PerFileEncryptionInfoProto::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PerFileEncryptionInfoProto::has_key() const {
  return _internal_has_key();
}
inline void PerFileEncryptionInfoProto::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PerFileEncryptionInfoProto::key() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PerFileEncryptionInfoProto.key)
  return _internal_key();
}
inline void PerFileEncryptionInfoProto::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PerFileEncryptionInfoProto.key)
}
inline std::string* PerFileEncryptionInfoProto::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.PerFileEncryptionInfoProto.key)
  return _internal_mutable_key();
}
inline const std::string& PerFileEncryptionInfoProto::_internal_key() const {
  return key_.GetNoArena();
}
inline void PerFileEncryptionInfoProto::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PerFileEncryptionInfoProto::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.PerFileEncryptionInfoProto.key)
}
inline void PerFileEncryptionInfoProto::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.PerFileEncryptionInfoProto.key)
}
inline void PerFileEncryptionInfoProto::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.PerFileEncryptionInfoProto.key)
}
inline std::string* PerFileEncryptionInfoProto::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PerFileEncryptionInfoProto::release_key() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.PerFileEncryptionInfoProto.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PerFileEncryptionInfoProto::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.PerFileEncryptionInfoProto.key)
}

// required bytes iv = 2;
inline bool PerFileEncryptionInfoProto::_internal_has_iv() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PerFileEncryptionInfoProto::has_iv() const {
  return _internal_has_iv();
}
inline void PerFileEncryptionInfoProto::clear_iv() {
  iv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PerFileEncryptionInfoProto::iv() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
  return _internal_iv();
}
inline void PerFileEncryptionInfoProto::set_iv(const std::string& value) {
  _internal_set_iv(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
}
inline std::string* PerFileEncryptionInfoProto::mutable_iv() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
  return _internal_mutable_iv();
}
inline const std::string& PerFileEncryptionInfoProto::_internal_iv() const {
  return iv_.GetNoArena();
}
inline void PerFileEncryptionInfoProto::_internal_set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PerFileEncryptionInfoProto::set_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
}
inline void PerFileEncryptionInfoProto::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
}
inline void PerFileEncryptionInfoProto::set_iv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
}
inline std::string* PerFileEncryptionInfoProto::_internal_mutable_iv() {
  _has_bits_[0] |= 0x00000002u;
  return iv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PerFileEncryptionInfoProto::release_iv() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return iv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PerFileEncryptionInfoProto::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  iv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.PerFileEncryptionInfoProto.iv)
}

// required string ezKeyVersionName = 3;
inline bool PerFileEncryptionInfoProto::_internal_has_ezkeyversionname() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PerFileEncryptionInfoProto::has_ezkeyversionname() const {
  return _internal_has_ezkeyversionname();
}
inline void PerFileEncryptionInfoProto::clear_ezkeyversionname() {
  ezkeyversionname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PerFileEncryptionInfoProto::ezkeyversionname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
  return _internal_ezkeyversionname();
}
inline void PerFileEncryptionInfoProto::set_ezkeyversionname(const std::string& value) {
  _internal_set_ezkeyversionname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
}
inline std::string* PerFileEncryptionInfoProto::mutable_ezkeyversionname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
  return _internal_mutable_ezkeyversionname();
}
inline const std::string& PerFileEncryptionInfoProto::_internal_ezkeyversionname() const {
  return ezkeyversionname_.GetNoArena();
}
inline void PerFileEncryptionInfoProto::_internal_set_ezkeyversionname(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PerFileEncryptionInfoProto::set_ezkeyversionname(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ezkeyversionname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
}
inline void PerFileEncryptionInfoProto::set_ezkeyversionname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
}
inline void PerFileEncryptionInfoProto::set_ezkeyversionname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ezkeyversionname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
}
inline std::string* PerFileEncryptionInfoProto::_internal_mutable_ezkeyversionname() {
  _has_bits_[0] |= 0x00000004u;
  return ezkeyversionname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PerFileEncryptionInfoProto::release_ezkeyversionname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
  if (!_internal_has_ezkeyversionname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ezkeyversionname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PerFileEncryptionInfoProto::set_allocated_ezkeyversionname(std::string* ezkeyversionname) {
  if (ezkeyversionname != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ezkeyversionname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ezkeyversionname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName)
}

// -------------------------------------------------------------------

// ZoneEncryptionInfoProto

// required .Hdfs.Internal.CipherSuiteProto suite = 1;
inline bool ZoneEncryptionInfoProto::_internal_has_suite() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ZoneEncryptionInfoProto::has_suite() const {
  return _internal_has_suite();
}
inline void ZoneEncryptionInfoProto::clear_suite() {
  suite_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::Hdfs::Internal::CipherSuiteProto ZoneEncryptionInfoProto::_internal_suite() const {
  return static_cast< ::Hdfs::Internal::CipherSuiteProto >(suite_);
}
inline ::Hdfs::Internal::CipherSuiteProto ZoneEncryptionInfoProto::suite() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ZoneEncryptionInfoProto.suite)
  return _internal_suite();
}
inline void ZoneEncryptionInfoProto::_internal_set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  assert(::Hdfs::Internal::CipherSuiteProto_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  suite_ = value;
}
inline void ZoneEncryptionInfoProto::set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  _internal_set_suite(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ZoneEncryptionInfoProto.suite)
}

// required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion = 2;
inline bool ZoneEncryptionInfoProto::_internal_has_cryptoprotocolversion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ZoneEncryptionInfoProto::has_cryptoprotocolversion() const {
  return _internal_has_cryptoprotocolversion();
}
inline void ZoneEncryptionInfoProto::clear_cryptoprotocolversion() {
  cryptoprotocolversion_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Hdfs::Internal::CryptoProtocolVersionProto ZoneEncryptionInfoProto::_internal_cryptoprotocolversion() const {
  return static_cast< ::Hdfs::Internal::CryptoProtocolVersionProto >(cryptoprotocolversion_);
}
inline ::Hdfs::Internal::CryptoProtocolVersionProto ZoneEncryptionInfoProto::cryptoprotocolversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ZoneEncryptionInfoProto.cryptoProtocolVersion)
  return _internal_cryptoprotocolversion();
}
inline void ZoneEncryptionInfoProto::_internal_set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value) {
  assert(::Hdfs::Internal::CryptoProtocolVersionProto_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  cryptoprotocolversion_ = value;
}
inline void ZoneEncryptionInfoProto::set_cryptoprotocolversion(::Hdfs::Internal::CryptoProtocolVersionProto value) {
  _internal_set_cryptoprotocolversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ZoneEncryptionInfoProto.cryptoProtocolVersion)
}

// required string keyName = 3;
inline bool ZoneEncryptionInfoProto::_internal_has_keyname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ZoneEncryptionInfoProto::has_keyname() const {
  return _internal_has_keyname();
}
inline void ZoneEncryptionInfoProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ZoneEncryptionInfoProto::keyname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
  return _internal_keyname();
}
inline void ZoneEncryptionInfoProto::set_keyname(const std::string& value) {
  _internal_set_keyname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
}
inline std::string* ZoneEncryptionInfoProto::mutable_keyname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
  return _internal_mutable_keyname();
}
inline const std::string& ZoneEncryptionInfoProto::_internal_keyname() const {
  return keyname_.GetNoArena();
}
inline void ZoneEncryptionInfoProto::_internal_set_keyname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ZoneEncryptionInfoProto::set_keyname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  keyname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
}
inline void ZoneEncryptionInfoProto::set_keyname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
}
inline void ZoneEncryptionInfoProto::set_keyname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  keyname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
}
inline std::string* ZoneEncryptionInfoProto::_internal_mutable_keyname() {
  _has_bits_[0] |= 0x00000001u;
  return keyname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ZoneEncryptionInfoProto::release_keyname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
  if (!_internal_has_keyname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return keyname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ZoneEncryptionInfoProto::set_allocated_keyname(std::string* keyname) {
  if (keyname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keyname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ZoneEncryptionInfoProto.keyName)
}

// -------------------------------------------------------------------

// CipherOptionProto

// required .Hdfs.Internal.CipherSuiteProto suite = 1;
inline bool CipherOptionProto::_internal_has_suite() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CipherOptionProto::has_suite() const {
  return _internal_has_suite();
}
inline void CipherOptionProto::clear_suite() {
  suite_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Hdfs::Internal::CipherSuiteProto CipherOptionProto::_internal_suite() const {
  return static_cast< ::Hdfs::Internal::CipherSuiteProto >(suite_);
}
inline ::Hdfs::Internal::CipherSuiteProto CipherOptionProto::suite() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CipherOptionProto.suite)
  return _internal_suite();
}
inline void CipherOptionProto::_internal_set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  assert(::Hdfs::Internal::CipherSuiteProto_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  suite_ = value;
}
inline void CipherOptionProto::set_suite(::Hdfs::Internal::CipherSuiteProto value) {
  _internal_set_suite(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CipherOptionProto.suite)
}

// optional bytes inKey = 2;
inline bool CipherOptionProto::_internal_has_inkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CipherOptionProto::has_inkey() const {
  return _internal_has_inkey();
}
inline void CipherOptionProto::clear_inkey() {
  inkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CipherOptionProto::inkey() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CipherOptionProto.inKey)
  return _internal_inkey();
}
inline void CipherOptionProto::set_inkey(const std::string& value) {
  _internal_set_inkey(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CipherOptionProto.inKey)
}
inline std::string* CipherOptionProto::mutable_inkey() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CipherOptionProto.inKey)
  return _internal_mutable_inkey();
}
inline const std::string& CipherOptionProto::_internal_inkey() const {
  return inkey_.GetNoArena();
}
inline void CipherOptionProto::_internal_set_inkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  inkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CipherOptionProto::set_inkey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  inkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CipherOptionProto.inKey)
}
inline void CipherOptionProto::set_inkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  inkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CipherOptionProto.inKey)
}
inline void CipherOptionProto::set_inkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  inkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CipherOptionProto.inKey)
}
inline std::string* CipherOptionProto::_internal_mutable_inkey() {
  _has_bits_[0] |= 0x00000001u;
  return inkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CipherOptionProto::release_inkey() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CipherOptionProto.inKey)
  if (!_internal_has_inkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return inkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CipherOptionProto::set_allocated_inkey(std::string* inkey) {
  if (inkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  inkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inkey);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CipherOptionProto.inKey)
}

// optional bytes inIv = 3;
inline bool CipherOptionProto::_internal_has_iniv() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CipherOptionProto::has_iniv() const {
  return _internal_has_iniv();
}
inline void CipherOptionProto::clear_iniv() {
  iniv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CipherOptionProto::iniv() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CipherOptionProto.inIv)
  return _internal_iniv();
}
inline void CipherOptionProto::set_iniv(const std::string& value) {
  _internal_set_iniv(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CipherOptionProto.inIv)
}
inline std::string* CipherOptionProto::mutable_iniv() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CipherOptionProto.inIv)
  return _internal_mutable_iniv();
}
inline const std::string& CipherOptionProto::_internal_iniv() const {
  return iniv_.GetNoArena();
}
inline void CipherOptionProto::_internal_set_iniv(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  iniv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CipherOptionProto::set_iniv(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  iniv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CipherOptionProto.inIv)
}
inline void CipherOptionProto::set_iniv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  iniv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CipherOptionProto.inIv)
}
inline void CipherOptionProto::set_iniv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  iniv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CipherOptionProto.inIv)
}
inline std::string* CipherOptionProto::_internal_mutable_iniv() {
  _has_bits_[0] |= 0x00000002u;
  return iniv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CipherOptionProto::release_iniv() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CipherOptionProto.inIv)
  if (!_internal_has_iniv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return iniv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CipherOptionProto::set_allocated_iniv(std::string* iniv) {
  if (iniv != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  iniv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iniv);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CipherOptionProto.inIv)
}

// optional bytes outKey = 4;
inline bool CipherOptionProto::_internal_has_outkey() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CipherOptionProto::has_outkey() const {
  return _internal_has_outkey();
}
inline void CipherOptionProto::clear_outkey() {
  outkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CipherOptionProto::outkey() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CipherOptionProto.outKey)
  return _internal_outkey();
}
inline void CipherOptionProto::set_outkey(const std::string& value) {
  _internal_set_outkey(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CipherOptionProto.outKey)
}
inline std::string* CipherOptionProto::mutable_outkey() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CipherOptionProto.outKey)
  return _internal_mutable_outkey();
}
inline const std::string& CipherOptionProto::_internal_outkey() const {
  return outkey_.GetNoArena();
}
inline void CipherOptionProto::_internal_set_outkey(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  outkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CipherOptionProto::set_outkey(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  outkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CipherOptionProto.outKey)
}
inline void CipherOptionProto::set_outkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  outkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CipherOptionProto.outKey)
}
inline void CipherOptionProto::set_outkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  outkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CipherOptionProto.outKey)
}
inline std::string* CipherOptionProto::_internal_mutable_outkey() {
  _has_bits_[0] |= 0x00000004u;
  return outkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CipherOptionProto::release_outkey() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CipherOptionProto.outKey)
  if (!_internal_has_outkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return outkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CipherOptionProto::set_allocated_outkey(std::string* outkey) {
  if (outkey != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  outkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), outkey);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CipherOptionProto.outKey)
}

// optional bytes outIv = 5;
inline bool CipherOptionProto::_internal_has_outiv() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CipherOptionProto::has_outiv() const {
  return _internal_has_outiv();
}
inline void CipherOptionProto::clear_outiv() {
  outiv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CipherOptionProto::outiv() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CipherOptionProto.outIv)
  return _internal_outiv();
}
inline void CipherOptionProto::set_outiv(const std::string& value) {
  _internal_set_outiv(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CipherOptionProto.outIv)
}
inline std::string* CipherOptionProto::mutable_outiv() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CipherOptionProto.outIv)
  return _internal_mutable_outiv();
}
inline const std::string& CipherOptionProto::_internal_outiv() const {
  return outiv_.GetNoArena();
}
inline void CipherOptionProto::_internal_set_outiv(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  outiv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CipherOptionProto::set_outiv(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  outiv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CipherOptionProto.outIv)
}
inline void CipherOptionProto::set_outiv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  outiv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CipherOptionProto.outIv)
}
inline void CipherOptionProto::set_outiv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  outiv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CipherOptionProto.outIv)
}
inline std::string* CipherOptionProto::_internal_mutable_outiv() {
  _has_bits_[0] |= 0x00000008u;
  return outiv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CipherOptionProto::release_outiv() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CipherOptionProto.outIv)
  if (!_internal_has_outiv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return outiv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CipherOptionProto::set_allocated_outiv(std::string* outiv) {
  if (outiv != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  outiv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), outiv);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CipherOptionProto.outIv)
}

// -------------------------------------------------------------------

// LocatedBlocksProto

// required uint64 fileLength = 1;
inline bool LocatedBlocksProto::_internal_has_filelength() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocatedBlocksProto::has_filelength() const {
  return _internal_has_filelength();
}
inline void LocatedBlocksProto::clear_filelength() {
  filelength_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocatedBlocksProto::_internal_filelength() const {
  return filelength_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocatedBlocksProto::filelength() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlocksProto.fileLength)
  return _internal_filelength();
}
inline void LocatedBlocksProto::_internal_set_filelength(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  filelength_ = value;
}
inline void LocatedBlocksProto::set_filelength(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlocksProto.fileLength)
}

// repeated .Hdfs.Internal.LocatedBlockProto blocks = 2;
inline int LocatedBlocksProto::_internal_blocks_size() const {
  return blocks_.size();
}
inline int LocatedBlocksProto::blocks_size() const {
  return _internal_blocks_size();
}
inline void LocatedBlocksProto::clear_blocks() {
  blocks_.Clear();
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlocksProto.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::LocatedBlockProto >*
LocatedBlocksProto::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.LocatedBlocksProto.blocks)
  return &blocks_;
}
inline const ::Hdfs::Internal::LocatedBlockProto& LocatedBlocksProto::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::Hdfs::Internal::LocatedBlockProto& LocatedBlocksProto::blocks(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlocksProto.blocks)
  return _internal_blocks(index);
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::add_blocks() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.LocatedBlocksProto.blocks)
  return _internal_add_blocks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::LocatedBlockProto >&
LocatedBlocksProto::blocks() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.LocatedBlocksProto.blocks)
  return blocks_;
}

// required bool underConstruction = 3;
inline bool LocatedBlocksProto::_internal_has_underconstruction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocatedBlocksProto::has_underconstruction() const {
  return _internal_has_underconstruction();
}
inline void LocatedBlocksProto::clear_underconstruction() {
  underconstruction_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool LocatedBlocksProto::_internal_underconstruction() const {
  return underconstruction_;
}
inline bool LocatedBlocksProto::underconstruction() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlocksProto.underConstruction)
  return _internal_underconstruction();
}
inline void LocatedBlocksProto::_internal_set_underconstruction(bool value) {
  _has_bits_[0] |= 0x00000004u;
  underconstruction_ = value;
}
inline void LocatedBlocksProto::set_underconstruction(bool value) {
  _internal_set_underconstruction(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlocksProto.underConstruction)
}

// optional .Hdfs.Internal.LocatedBlockProto lastBlock = 4;
inline bool LocatedBlocksProto::_internal_has_lastblock() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || lastblock_ != nullptr);
  return value;
}
inline bool LocatedBlocksProto::has_lastblock() const {
  return _internal_has_lastblock();
}
inline void LocatedBlocksProto::clear_lastblock() {
  if (lastblock_ != nullptr) lastblock_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::LocatedBlockProto& LocatedBlocksProto::_internal_lastblock() const {
  const ::Hdfs::Internal::LocatedBlockProto* p = lastblock_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::LocatedBlockProto*>(
      &::Hdfs::Internal::_LocatedBlockProto_default_instance_);
}
inline const ::Hdfs::Internal::LocatedBlockProto& LocatedBlocksProto::lastblock() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlocksProto.lastBlock)
  return _internal_lastblock();
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::release_lastblock() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.LocatedBlocksProto.lastBlock)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::LocatedBlockProto* temp = lastblock_;
  lastblock_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::_internal_mutable_lastblock() {
  _has_bits_[0] |= 0x00000001u;
  if (lastblock_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::LocatedBlockProto>(GetArenaNoVirtual());
    lastblock_ = p;
  }
  return lastblock_;
}
inline ::Hdfs::Internal::LocatedBlockProto* LocatedBlocksProto::mutable_lastblock() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.LocatedBlocksProto.lastBlock)
  return _internal_mutable_lastblock();
}
inline void LocatedBlocksProto::set_allocated_lastblock(::Hdfs::Internal::LocatedBlockProto* lastblock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lastblock_;
  }
  if (lastblock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lastblock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lastblock, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lastblock_ = lastblock;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.LocatedBlocksProto.lastBlock)
}

// required bool isLastBlockComplete = 5;
inline bool LocatedBlocksProto::_internal_has_islastblockcomplete() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocatedBlocksProto::has_islastblockcomplete() const {
  return _internal_has_islastblockcomplete();
}
inline void LocatedBlocksProto::clear_islastblockcomplete() {
  islastblockcomplete_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool LocatedBlocksProto::_internal_islastblockcomplete() const {
  return islastblockcomplete_;
}
inline bool LocatedBlocksProto::islastblockcomplete() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.LocatedBlocksProto.isLastBlockComplete)
  return _internal_islastblockcomplete();
}
inline void LocatedBlocksProto::_internal_set_islastblockcomplete(bool value) {
  _has_bits_[0] |= 0x00000008u;
  islastblockcomplete_ = value;
}
inline void LocatedBlocksProto::set_islastblockcomplete(bool value) {
  _internal_set_islastblockcomplete(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.LocatedBlocksProto.isLastBlockComplete)
}

// -------------------------------------------------------------------

// HdfsFileStatusProto

// required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
inline bool HdfsFileStatusProto::_internal_has_filetype() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_filetype() const {
  return _internal_has_filetype();
}
inline void HdfsFileStatusProto::clear_filetype() {
  filetype_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::Hdfs::Internal::HdfsFileStatusProto_FileType HdfsFileStatusProto::_internal_filetype() const {
  return static_cast< ::Hdfs::Internal::HdfsFileStatusProto_FileType >(filetype_);
}
inline ::Hdfs::Internal::HdfsFileStatusProto_FileType HdfsFileStatusProto::filetype() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.fileType)
  return _internal_filetype();
}
inline void HdfsFileStatusProto::_internal_set_filetype(::Hdfs::Internal::HdfsFileStatusProto_FileType value) {
  assert(::Hdfs::Internal::HdfsFileStatusProto_FileType_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  filetype_ = value;
}
inline void HdfsFileStatusProto::set_filetype(::Hdfs::Internal::HdfsFileStatusProto_FileType value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.fileType)
}

// required bytes path = 2;
inline bool HdfsFileStatusProto::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_path() const {
  return _internal_has_path();
}
inline void HdfsFileStatusProto::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HdfsFileStatusProto::path() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.path)
  return _internal_path();
}
inline void HdfsFileStatusProto::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.path)
}
inline std::string* HdfsFileStatusProto::mutable_path() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.path)
  return _internal_mutable_path();
}
inline const std::string& HdfsFileStatusProto::_internal_path() const {
  return path_.GetNoArena();
}
inline void HdfsFileStatusProto::_internal_set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void HdfsFileStatusProto::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.HdfsFileStatusProto.path)
}
inline void HdfsFileStatusProto::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.HdfsFileStatusProto.path)
}
inline void HdfsFileStatusProto::set_path(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.HdfsFileStatusProto.path)
}
inline std::string* HdfsFileStatusProto::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000001u;
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HdfsFileStatusProto::release_path() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HdfsFileStatusProto::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.path)
}

// required uint64 length = 3;
inline bool HdfsFileStatusProto::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_length() const {
  return _internal_has_length();
}
inline void HdfsFileStatusProto::clear_length() {
  length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::_internal_length() const {
  return length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::length() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.length)
  return _internal_length();
}
inline void HdfsFileStatusProto::_internal_set_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  length_ = value;
}
inline void HdfsFileStatusProto::set_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.length)
}

// required .Hdfs.Internal.FsPermissionProto permission = 4;
inline bool HdfsFileStatusProto::_internal_has_permission() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || permission_ != nullptr);
  return value;
}
inline bool HdfsFileStatusProto::has_permission() const {
  return _internal_has_permission();
}
inline void HdfsFileStatusProto::clear_permission() {
  if (permission_ != nullptr) permission_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::Hdfs::Internal::FsPermissionProto& HdfsFileStatusProto::_internal_permission() const {
  const ::Hdfs::Internal::FsPermissionProto* p = permission_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::FsPermissionProto*>(
      &::Hdfs::Internal::_FsPermissionProto_default_instance_);
}
inline const ::Hdfs::Internal::FsPermissionProto& HdfsFileStatusProto::permission() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.permission)
  return _internal_permission();
}
inline ::Hdfs::Internal::FsPermissionProto* HdfsFileStatusProto::release_permission() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.permission)
  _has_bits_[0] &= ~0x00000010u;
  ::Hdfs::Internal::FsPermissionProto* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::FsPermissionProto* HdfsFileStatusProto::_internal_mutable_permission() {
  _has_bits_[0] |= 0x00000010u;
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::FsPermissionProto>(GetArenaNoVirtual());
    permission_ = p;
  }
  return permission_;
}
inline ::Hdfs::Internal::FsPermissionProto* HdfsFileStatusProto::mutable_permission() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.permission)
  return _internal_mutable_permission();
}
inline void HdfsFileStatusProto::set_allocated_permission(::Hdfs::Internal::FsPermissionProto* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.permission)
}

// required string owner = 5;
inline bool HdfsFileStatusProto::_internal_has_owner() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_owner() const {
  return _internal_has_owner();
}
inline void HdfsFileStatusProto::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HdfsFileStatusProto::owner() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.owner)
  return _internal_owner();
}
inline void HdfsFileStatusProto::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.owner)
}
inline std::string* HdfsFileStatusProto::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.owner)
  return _internal_mutable_owner();
}
inline const std::string& HdfsFileStatusProto::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void HdfsFileStatusProto::_internal_set_owner(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void HdfsFileStatusProto::set_owner(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.HdfsFileStatusProto.owner)
}
inline void HdfsFileStatusProto::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.HdfsFileStatusProto.owner)
}
inline void HdfsFileStatusProto::set_owner(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.HdfsFileStatusProto.owner)
}
inline std::string* HdfsFileStatusProto::_internal_mutable_owner() {
  _has_bits_[0] |= 0x00000002u;
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HdfsFileStatusProto::release_owner() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.owner)
  if (!_internal_has_owner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return owner_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HdfsFileStatusProto::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.owner)
}

// required string group = 6;
inline bool HdfsFileStatusProto::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_group() const {
  return _internal_has_group();
}
inline void HdfsFileStatusProto::clear_group() {
  group_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HdfsFileStatusProto::group() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.group)
  return _internal_group();
}
inline void HdfsFileStatusProto::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.group)
}
inline std::string* HdfsFileStatusProto::mutable_group() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.group)
  return _internal_mutable_group();
}
inline const std::string& HdfsFileStatusProto::_internal_group() const {
  return group_.GetNoArena();
}
inline void HdfsFileStatusProto::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void HdfsFileStatusProto::set_group(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  group_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.HdfsFileStatusProto.group)
}
inline void HdfsFileStatusProto::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.HdfsFileStatusProto.group)
}
inline void HdfsFileStatusProto::set_group(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.HdfsFileStatusProto.group)
}
inline std::string* HdfsFileStatusProto::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000004u;
  return group_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HdfsFileStatusProto::release_group() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return group_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HdfsFileStatusProto::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  group_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.group)
}

// required uint64 modification_time = 7;
inline bool HdfsFileStatusProto::_internal_has_modification_time() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_modification_time() const {
  return _internal_has_modification_time();
}
inline void HdfsFileStatusProto::clear_modification_time() {
  modification_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::_internal_modification_time() const {
  return modification_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::modification_time() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.modification_time)
  return _internal_modification_time();
}
inline void HdfsFileStatusProto::_internal_set_modification_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  modification_time_ = value;
}
inline void HdfsFileStatusProto::set_modification_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_modification_time(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.modification_time)
}

// required uint64 access_time = 8;
inline bool HdfsFileStatusProto::_internal_has_access_time() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_access_time() const {
  return _internal_has_access_time();
}
inline void HdfsFileStatusProto::clear_access_time() {
  access_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::_internal_access_time() const {
  return access_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::access_time() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.access_time)
  return _internal_access_time();
}
inline void HdfsFileStatusProto::_internal_set_access_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  access_time_ = value;
}
inline void HdfsFileStatusProto::set_access_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_access_time(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.access_time)
}

// optional bytes symlink = 9;
inline bool HdfsFileStatusProto::_internal_has_symlink() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_symlink() const {
  return _internal_has_symlink();
}
inline void HdfsFileStatusProto::clear_symlink() {
  symlink_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& HdfsFileStatusProto::symlink() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.symlink)
  return _internal_symlink();
}
inline void HdfsFileStatusProto::set_symlink(const std::string& value) {
  _internal_set_symlink(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.symlink)
}
inline std::string* HdfsFileStatusProto::mutable_symlink() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.symlink)
  return _internal_mutable_symlink();
}
inline const std::string& HdfsFileStatusProto::_internal_symlink() const {
  return symlink_.GetNoArena();
}
inline void HdfsFileStatusProto::_internal_set_symlink(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  symlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void HdfsFileStatusProto::set_symlink(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  symlink_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.HdfsFileStatusProto.symlink)
}
inline void HdfsFileStatusProto::set_symlink(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  symlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.HdfsFileStatusProto.symlink)
}
inline void HdfsFileStatusProto::set_symlink(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  symlink_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.HdfsFileStatusProto.symlink)
}
inline std::string* HdfsFileStatusProto::_internal_mutable_symlink() {
  _has_bits_[0] |= 0x00000008u;
  return symlink_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HdfsFileStatusProto::release_symlink() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.symlink)
  if (!_internal_has_symlink()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return symlink_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HdfsFileStatusProto::set_allocated_symlink(std::string* symlink) {
  if (symlink != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  symlink_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symlink);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.symlink)
}

// optional uint32 block_replication = 10 [default = 0];
inline bool HdfsFileStatusProto::_internal_has_block_replication() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_block_replication() const {
  return _internal_has_block_replication();
}
inline void HdfsFileStatusProto::clear_block_replication() {
  block_replication_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HdfsFileStatusProto::_internal_block_replication() const {
  return block_replication_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HdfsFileStatusProto::block_replication() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.block_replication)
  return _internal_block_replication();
}
inline void HdfsFileStatusProto::_internal_set_block_replication(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  block_replication_ = value;
}
inline void HdfsFileStatusProto::set_block_replication(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_block_replication(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.block_replication)
}

// optional uint64 blocksize = 11 [default = 0];
inline bool HdfsFileStatusProto::_internal_has_blocksize() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_blocksize() const {
  return _internal_has_blocksize();
}
inline void HdfsFileStatusProto::clear_blocksize() {
  blocksize_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::_internal_blocksize() const {
  return blocksize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::blocksize() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.blocksize)
  return _internal_blocksize();
}
inline void HdfsFileStatusProto::_internal_set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  blocksize_ = value;
}
inline void HdfsFileStatusProto::set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blocksize(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.blocksize)
}

// optional .Hdfs.Internal.LocatedBlocksProto locations = 12;
inline bool HdfsFileStatusProto::_internal_has_locations() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || locations_ != nullptr);
  return value;
}
inline bool HdfsFileStatusProto::has_locations() const {
  return _internal_has_locations();
}
inline void HdfsFileStatusProto::clear_locations() {
  if (locations_ != nullptr) locations_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::Hdfs::Internal::LocatedBlocksProto& HdfsFileStatusProto::_internal_locations() const {
  const ::Hdfs::Internal::LocatedBlocksProto* p = locations_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::LocatedBlocksProto*>(
      &::Hdfs::Internal::_LocatedBlocksProto_default_instance_);
}
inline const ::Hdfs::Internal::LocatedBlocksProto& HdfsFileStatusProto::locations() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.locations)
  return _internal_locations();
}
inline ::Hdfs::Internal::LocatedBlocksProto* HdfsFileStatusProto::release_locations() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.locations)
  _has_bits_[0] &= ~0x00000020u;
  ::Hdfs::Internal::LocatedBlocksProto* temp = locations_;
  locations_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::LocatedBlocksProto* HdfsFileStatusProto::_internal_mutable_locations() {
  _has_bits_[0] |= 0x00000020u;
  if (locations_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::LocatedBlocksProto>(GetArenaNoVirtual());
    locations_ = p;
  }
  return locations_;
}
inline ::Hdfs::Internal::LocatedBlocksProto* HdfsFileStatusProto::mutable_locations() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.locations)
  return _internal_mutable_locations();
}
inline void HdfsFileStatusProto::set_allocated_locations(::Hdfs::Internal::LocatedBlocksProto* locations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete locations_;
  }
  if (locations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      locations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locations, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  locations_ = locations;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.locations)
}

// optional uint64 fileId = 13 [default = 0];
inline bool HdfsFileStatusProto::_internal_has_fileid() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_fileid() const {
  return _internal_has_fileid();
}
inline void HdfsFileStatusProto::clear_fileid() {
  fileid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::_internal_fileid() const {
  return fileid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HdfsFileStatusProto::fileid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.fileId)
  return _internal_fileid();
}
inline void HdfsFileStatusProto::_internal_set_fileid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000800u;
  fileid_ = value;
}
inline void HdfsFileStatusProto::set_fileid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fileid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.fileId)
}

// optional int32 childrenNum = 14 [default = -1];
inline bool HdfsFileStatusProto::_internal_has_childrennum() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool HdfsFileStatusProto::has_childrennum() const {
  return _internal_has_childrennum();
}
inline void HdfsFileStatusProto::clear_childrennum() {
  childrennum_ = -1;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HdfsFileStatusProto::_internal_childrennum() const {
  return childrennum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HdfsFileStatusProto::childrennum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.childrenNum)
  return _internal_childrennum();
}
inline void HdfsFileStatusProto::_internal_set_childrennum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  childrennum_ = value;
}
inline void HdfsFileStatusProto::set_childrennum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_childrennum(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.HdfsFileStatusProto.childrenNum)
}

// optional .Hdfs.Internal.FileEncryptionInfoProto fileEncryptionInfo = 15;
inline bool HdfsFileStatusProto::_internal_has_fileencryptioninfo() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || fileencryptioninfo_ != nullptr);
  return value;
}
inline bool HdfsFileStatusProto::has_fileencryptioninfo() const {
  return _internal_has_fileencryptioninfo();
}
inline void HdfsFileStatusProto::clear_fileencryptioninfo() {
  if (fileencryptioninfo_ != nullptr) fileencryptioninfo_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::Hdfs::Internal::FileEncryptionInfoProto& HdfsFileStatusProto::_internal_fileencryptioninfo() const {
  const ::Hdfs::Internal::FileEncryptionInfoProto* p = fileencryptioninfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::FileEncryptionInfoProto*>(
      &::Hdfs::Internal::_FileEncryptionInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::FileEncryptionInfoProto& HdfsFileStatusProto::fileencryptioninfo() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.HdfsFileStatusProto.fileEncryptionInfo)
  return _internal_fileencryptioninfo();
}
inline ::Hdfs::Internal::FileEncryptionInfoProto* HdfsFileStatusProto::release_fileencryptioninfo() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.HdfsFileStatusProto.fileEncryptionInfo)
  _has_bits_[0] &= ~0x00000040u;
  ::Hdfs::Internal::FileEncryptionInfoProto* temp = fileencryptioninfo_;
  fileencryptioninfo_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::FileEncryptionInfoProto* HdfsFileStatusProto::_internal_mutable_fileencryptioninfo() {
  _has_bits_[0] |= 0x00000040u;
  if (fileencryptioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::FileEncryptionInfoProto>(GetArenaNoVirtual());
    fileencryptioninfo_ = p;
  }
  return fileencryptioninfo_;
}
inline ::Hdfs::Internal::FileEncryptionInfoProto* HdfsFileStatusProto::mutable_fileencryptioninfo() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.HdfsFileStatusProto.fileEncryptionInfo)
  return _internal_mutable_fileencryptioninfo();
}
inline void HdfsFileStatusProto::set_allocated_fileencryptioninfo(::Hdfs::Internal::FileEncryptionInfoProto* fileencryptioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fileencryptioninfo_;
  }
  if (fileencryptioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fileencryptioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileencryptioninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  fileencryptioninfo_ = fileencryptioninfo;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.HdfsFileStatusProto.fileEncryptionInfo)
}

// -------------------------------------------------------------------

// FsServerDefaultsProto

// required uint64 blockSize = 1;
inline bool FsServerDefaultsProto::_internal_has_blocksize() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_blocksize() const {
  return _internal_has_blocksize();
}
inline void FsServerDefaultsProto::clear_blocksize() {
  blocksize_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FsServerDefaultsProto::_internal_blocksize() const {
  return blocksize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FsServerDefaultsProto::blocksize() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.blockSize)
  return _internal_blocksize();
}
inline void FsServerDefaultsProto::_internal_set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  blocksize_ = value;
}
inline void FsServerDefaultsProto::set_blocksize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blocksize(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.blockSize)
}

// required uint32 bytesPerChecksum = 2;
inline bool FsServerDefaultsProto::_internal_has_bytesperchecksum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_bytesperchecksum() const {
  return _internal_has_bytesperchecksum();
}
inline void FsServerDefaultsProto::clear_bytesperchecksum() {
  bytesperchecksum_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::_internal_bytesperchecksum() const {
  return bytesperchecksum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::bytesperchecksum() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.bytesPerChecksum)
  return _internal_bytesperchecksum();
}
inline void FsServerDefaultsProto::_internal_set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  bytesperchecksum_ = value;
}
inline void FsServerDefaultsProto::set_bytesperchecksum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bytesperchecksum(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.bytesPerChecksum)
}

// required uint32 writePacketSize = 3;
inline bool FsServerDefaultsProto::_internal_has_writepacketsize() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_writepacketsize() const {
  return _internal_has_writepacketsize();
}
inline void FsServerDefaultsProto::clear_writepacketsize() {
  writepacketsize_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::_internal_writepacketsize() const {
  return writepacketsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::writepacketsize() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.writePacketSize)
  return _internal_writepacketsize();
}
inline void FsServerDefaultsProto::_internal_set_writepacketsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  writepacketsize_ = value;
}
inline void FsServerDefaultsProto::set_writepacketsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_writepacketsize(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.writePacketSize)
}

// required uint32 replication = 4;
inline bool FsServerDefaultsProto::_internal_has_replication() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_replication() const {
  return _internal_has_replication();
}
inline void FsServerDefaultsProto::clear_replication() {
  replication_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::_internal_replication() const {
  return replication_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::replication() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.replication)
  return _internal_replication();
}
inline void FsServerDefaultsProto::_internal_set_replication(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  replication_ = value;
}
inline void FsServerDefaultsProto::set_replication(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_replication(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.replication)
}

// required uint32 fileBufferSize = 5;
inline bool FsServerDefaultsProto::_internal_has_filebuffersize() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_filebuffersize() const {
  return _internal_has_filebuffersize();
}
inline void FsServerDefaultsProto::clear_filebuffersize() {
  filebuffersize_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::_internal_filebuffersize() const {
  return filebuffersize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FsServerDefaultsProto::filebuffersize() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.fileBufferSize)
  return _internal_filebuffersize();
}
inline void FsServerDefaultsProto::_internal_set_filebuffersize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  filebuffersize_ = value;
}
inline void FsServerDefaultsProto::set_filebuffersize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_filebuffersize(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.fileBufferSize)
}

// optional bool encryptDataTransfer = 6 [default = false];
inline bool FsServerDefaultsProto::_internal_has_encryptdatatransfer() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_encryptdatatransfer() const {
  return _internal_has_encryptdatatransfer();
}
inline void FsServerDefaultsProto::clear_encryptdatatransfer() {
  encryptdatatransfer_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool FsServerDefaultsProto::_internal_encryptdatatransfer() const {
  return encryptdatatransfer_;
}
inline bool FsServerDefaultsProto::encryptdatatransfer() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.encryptDataTransfer)
  return _internal_encryptdatatransfer();
}
inline void FsServerDefaultsProto::_internal_set_encryptdatatransfer(bool value) {
  _has_bits_[0] |= 0x00000040u;
  encryptdatatransfer_ = value;
}
inline void FsServerDefaultsProto::set_encryptdatatransfer(bool value) {
  _internal_set_encryptdatatransfer(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.encryptDataTransfer)
}

// optional uint64 trashInterval = 7 [default = 0];
inline bool FsServerDefaultsProto::_internal_has_trashinterval() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_trashinterval() const {
  return _internal_has_trashinterval();
}
inline void FsServerDefaultsProto::clear_trashinterval() {
  trashinterval_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FsServerDefaultsProto::_internal_trashinterval() const {
  return trashinterval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FsServerDefaultsProto::trashinterval() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.trashInterval)
  return _internal_trashinterval();
}
inline void FsServerDefaultsProto::_internal_set_trashinterval(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  trashinterval_ = value;
}
inline void FsServerDefaultsProto::set_trashinterval(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_trashinterval(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.trashInterval)
}

// optional .Hdfs.Internal.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
inline bool FsServerDefaultsProto::_internal_has_checksumtype() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FsServerDefaultsProto::has_checksumtype() const {
  return _internal_has_checksumtype();
}
inline void FsServerDefaultsProto::clear_checksumtype() {
  checksumtype_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::Hdfs::Internal::ChecksumTypeProto FsServerDefaultsProto::_internal_checksumtype() const {
  return static_cast< ::Hdfs::Internal::ChecksumTypeProto >(checksumtype_);
}
inline ::Hdfs::Internal::ChecksumTypeProto FsServerDefaultsProto::checksumtype() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.FsServerDefaultsProto.checksumType)
  return _internal_checksumtype();
}
inline void FsServerDefaultsProto::_internal_set_checksumtype(::Hdfs::Internal::ChecksumTypeProto value) {
  assert(::Hdfs::Internal::ChecksumTypeProto_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  checksumtype_ = value;
}
inline void FsServerDefaultsProto::set_checksumtype(::Hdfs::Internal::ChecksumTypeProto value) {
  _internal_set_checksumtype(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.FsServerDefaultsProto.checksumType)
}

// -------------------------------------------------------------------

// DirectoryListingProto

// repeated .Hdfs.Internal.HdfsFileStatusProto partialListing = 1;
inline int DirectoryListingProto::_internal_partiallisting_size() const {
  return partiallisting_.size();
}
inline int DirectoryListingProto::partiallisting_size() const {
  return _internal_partiallisting_size();
}
inline void DirectoryListingProto::clear_partiallisting() {
  partiallisting_.Clear();
}
inline ::Hdfs::Internal::HdfsFileStatusProto* DirectoryListingProto::mutable_partiallisting(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.DirectoryListingProto.partialListing)
  return partiallisting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::HdfsFileStatusProto >*
DirectoryListingProto::mutable_partiallisting() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.DirectoryListingProto.partialListing)
  return &partiallisting_;
}
inline const ::Hdfs::Internal::HdfsFileStatusProto& DirectoryListingProto::_internal_partiallisting(int index) const {
  return partiallisting_.Get(index);
}
inline const ::Hdfs::Internal::HdfsFileStatusProto& DirectoryListingProto::partiallisting(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DirectoryListingProto.partialListing)
  return _internal_partiallisting(index);
}
inline ::Hdfs::Internal::HdfsFileStatusProto* DirectoryListingProto::_internal_add_partiallisting() {
  return partiallisting_.Add();
}
inline ::Hdfs::Internal::HdfsFileStatusProto* DirectoryListingProto::add_partiallisting() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.DirectoryListingProto.partialListing)
  return _internal_add_partiallisting();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::HdfsFileStatusProto >&
DirectoryListingProto::partiallisting() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.DirectoryListingProto.partialListing)
  return partiallisting_;
}

// required uint32 remainingEntries = 2;
inline bool DirectoryListingProto::_internal_has_remainingentries() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectoryListingProto::has_remainingentries() const {
  return _internal_has_remainingentries();
}
inline void DirectoryListingProto::clear_remainingentries() {
  remainingentries_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectoryListingProto::_internal_remainingentries() const {
  return remainingentries_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectoryListingProto::remainingentries() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.DirectoryListingProto.remainingEntries)
  return _internal_remainingentries();
}
inline void DirectoryListingProto::_internal_set_remainingentries(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  remainingentries_ = value;
}
inline void DirectoryListingProto::set_remainingentries(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_remainingentries(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.DirectoryListingProto.remainingEntries)
}

// -------------------------------------------------------------------

// SnapshottableDirectoryStatusProto

// required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
inline bool SnapshottableDirectoryStatusProto::_internal_has_dirstatus() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dirstatus_ != nullptr);
  return value;
}
inline bool SnapshottableDirectoryStatusProto::has_dirstatus() const {
  return _internal_has_dirstatus();
}
inline void SnapshottableDirectoryStatusProto::clear_dirstatus() {
  if (dirstatus_ != nullptr) dirstatus_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::HdfsFileStatusProto& SnapshottableDirectoryStatusProto::_internal_dirstatus() const {
  const ::Hdfs::Internal::HdfsFileStatusProto* p = dirstatus_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::HdfsFileStatusProto*>(
      &::Hdfs::Internal::_HdfsFileStatusProto_default_instance_);
}
inline const ::Hdfs::Internal::HdfsFileStatusProto& SnapshottableDirectoryStatusProto::dirstatus() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshottableDirectoryStatusProto.dirStatus)
  return _internal_dirstatus();
}
inline ::Hdfs::Internal::HdfsFileStatusProto* SnapshottableDirectoryStatusProto::release_dirstatus() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshottableDirectoryStatusProto.dirStatus)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::HdfsFileStatusProto* temp = dirstatus_;
  dirstatus_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::HdfsFileStatusProto* SnapshottableDirectoryStatusProto::_internal_mutable_dirstatus() {
  _has_bits_[0] |= 0x00000002u;
  if (dirstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::HdfsFileStatusProto>(GetArenaNoVirtual());
    dirstatus_ = p;
  }
  return dirstatus_;
}
inline ::Hdfs::Internal::HdfsFileStatusProto* SnapshottableDirectoryStatusProto::mutable_dirstatus() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshottableDirectoryStatusProto.dirStatus)
  return _internal_mutable_dirstatus();
}
inline void SnapshottableDirectoryStatusProto::set_allocated_dirstatus(::Hdfs::Internal::HdfsFileStatusProto* dirstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dirstatus_;
  }
  if (dirstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dirstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirstatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dirstatus_ = dirstatus;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshottableDirectoryStatusProto.dirStatus)
}

// required uint32 snapshot_quota = 2;
inline bool SnapshottableDirectoryStatusProto::_internal_has_snapshot_quota() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SnapshottableDirectoryStatusProto::has_snapshot_quota() const {
  return _internal_has_snapshot_quota();
}
inline void SnapshottableDirectoryStatusProto::clear_snapshot_quota() {
  snapshot_quota_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SnapshottableDirectoryStatusProto::_internal_snapshot_quota() const {
  return snapshot_quota_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SnapshottableDirectoryStatusProto::snapshot_quota() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshottableDirectoryStatusProto.snapshot_quota)
  return _internal_snapshot_quota();
}
inline void SnapshottableDirectoryStatusProto::_internal_set_snapshot_quota(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  snapshot_quota_ = value;
}
inline void SnapshottableDirectoryStatusProto::set_snapshot_quota(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_snapshot_quota(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshottableDirectoryStatusProto.snapshot_quota)
}

// required uint32 snapshot_number = 3;
inline bool SnapshottableDirectoryStatusProto::_internal_has_snapshot_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SnapshottableDirectoryStatusProto::has_snapshot_number() const {
  return _internal_has_snapshot_number();
}
inline void SnapshottableDirectoryStatusProto::clear_snapshot_number() {
  snapshot_number_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SnapshottableDirectoryStatusProto::_internal_snapshot_number() const {
  return snapshot_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SnapshottableDirectoryStatusProto::snapshot_number() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshottableDirectoryStatusProto.snapshot_number)
  return _internal_snapshot_number();
}
inline void SnapshottableDirectoryStatusProto::_internal_set_snapshot_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  snapshot_number_ = value;
}
inline void SnapshottableDirectoryStatusProto::set_snapshot_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_snapshot_number(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshottableDirectoryStatusProto.snapshot_number)
}

// required bytes parent_fullpath = 4;
inline bool SnapshottableDirectoryStatusProto::_internal_has_parent_fullpath() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SnapshottableDirectoryStatusProto::has_parent_fullpath() const {
  return _internal_has_parent_fullpath();
}
inline void SnapshottableDirectoryStatusProto::clear_parent_fullpath() {
  parent_fullpath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnapshottableDirectoryStatusProto::parent_fullpath() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
  return _internal_parent_fullpath();
}
inline void SnapshottableDirectoryStatusProto::set_parent_fullpath(const std::string& value) {
  _internal_set_parent_fullpath(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
}
inline std::string* SnapshottableDirectoryStatusProto::mutable_parent_fullpath() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
  return _internal_mutable_parent_fullpath();
}
inline const std::string& SnapshottableDirectoryStatusProto::_internal_parent_fullpath() const {
  return parent_fullpath_.GetNoArena();
}
inline void SnapshottableDirectoryStatusProto::_internal_set_parent_fullpath(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshottableDirectoryStatusProto::set_parent_fullpath(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  parent_fullpath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
}
inline void SnapshottableDirectoryStatusProto::set_parent_fullpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  parent_fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
}
inline void SnapshottableDirectoryStatusProto::set_parent_fullpath(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  parent_fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
}
inline std::string* SnapshottableDirectoryStatusProto::_internal_mutable_parent_fullpath() {
  _has_bits_[0] |= 0x00000001u;
  return parent_fullpath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshottableDirectoryStatusProto::release_parent_fullpath() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
  if (!_internal_has_parent_fullpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return parent_fullpath_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshottableDirectoryStatusProto::set_allocated_parent_fullpath(std::string* parent_fullpath) {
  if (parent_fullpath != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parent_fullpath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_fullpath);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshottableDirectoryStatusProto.parent_fullpath)
}

// -------------------------------------------------------------------

// SnapshottableDirectoryListingProto

// repeated .Hdfs.Internal.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
inline int SnapshottableDirectoryListingProto::_internal_snapshottabledirlisting_size() const {
  return snapshottabledirlisting_.size();
}
inline int SnapshottableDirectoryListingProto::snapshottabledirlisting_size() const {
  return _internal_snapshottabledirlisting_size();
}
inline void SnapshottableDirectoryListingProto::clear_snapshottabledirlisting() {
  snapshottabledirlisting_.Clear();
}
inline ::Hdfs::Internal::SnapshottableDirectoryStatusProto* SnapshottableDirectoryListingProto::mutable_snapshottabledirlisting(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshottableDirectoryListingProto.snapshottableDirListing)
  return snapshottabledirlisting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshottableDirectoryStatusProto >*
SnapshottableDirectoryListingProto::mutable_snapshottabledirlisting() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.SnapshottableDirectoryListingProto.snapshottableDirListing)
  return &snapshottabledirlisting_;
}
inline const ::Hdfs::Internal::SnapshottableDirectoryStatusProto& SnapshottableDirectoryListingProto::_internal_snapshottabledirlisting(int index) const {
  return snapshottabledirlisting_.Get(index);
}
inline const ::Hdfs::Internal::SnapshottableDirectoryStatusProto& SnapshottableDirectoryListingProto::snapshottabledirlisting(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshottableDirectoryListingProto.snapshottableDirListing)
  return _internal_snapshottabledirlisting(index);
}
inline ::Hdfs::Internal::SnapshottableDirectoryStatusProto* SnapshottableDirectoryListingProto::_internal_add_snapshottabledirlisting() {
  return snapshottabledirlisting_.Add();
}
inline ::Hdfs::Internal::SnapshottableDirectoryStatusProto* SnapshottableDirectoryListingProto::add_snapshottabledirlisting() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.SnapshottableDirectoryListingProto.snapshottableDirListing)
  return _internal_add_snapshottabledirlisting();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshottableDirectoryStatusProto >&
SnapshottableDirectoryListingProto::snapshottabledirlisting() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.SnapshottableDirectoryListingProto.snapshottableDirListing)
  return snapshottabledirlisting_;
}

// -------------------------------------------------------------------

// SnapshotDiffReportEntryProto

// required bytes fullpath = 1;
inline bool SnapshotDiffReportEntryProto::_internal_has_fullpath() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SnapshotDiffReportEntryProto::has_fullpath() const {
  return _internal_has_fullpath();
}
inline void SnapshotDiffReportEntryProto::clear_fullpath() {
  fullpath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnapshotDiffReportEntryProto::fullpath() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
  return _internal_fullpath();
}
inline void SnapshotDiffReportEntryProto::set_fullpath(const std::string& value) {
  _internal_set_fullpath(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
}
inline std::string* SnapshotDiffReportEntryProto::mutable_fullpath() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
  return _internal_mutable_fullpath();
}
inline const std::string& SnapshotDiffReportEntryProto::_internal_fullpath() const {
  return fullpath_.GetNoArena();
}
inline void SnapshotDiffReportEntryProto::_internal_set_fullpath(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotDiffReportEntryProto::set_fullpath(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  fullpath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
}
inline void SnapshotDiffReportEntryProto::set_fullpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
}
inline void SnapshotDiffReportEntryProto::set_fullpath(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  fullpath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
}
inline std::string* SnapshotDiffReportEntryProto::_internal_mutable_fullpath() {
  _has_bits_[0] |= 0x00000001u;
  return fullpath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDiffReportEntryProto::release_fullpath() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
  if (!_internal_has_fullpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return fullpath_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDiffReportEntryProto::set_allocated_fullpath(std::string* fullpath) {
  if (fullpath != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fullpath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullpath);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotDiffReportEntryProto.fullpath)
}

// required string modificationLabel = 2;
inline bool SnapshotDiffReportEntryProto::_internal_has_modificationlabel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SnapshotDiffReportEntryProto::has_modificationlabel() const {
  return _internal_has_modificationlabel();
}
inline void SnapshotDiffReportEntryProto::clear_modificationlabel() {
  modificationlabel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SnapshotDiffReportEntryProto::modificationlabel() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
  return _internal_modificationlabel();
}
inline void SnapshotDiffReportEntryProto::set_modificationlabel(const std::string& value) {
  _internal_set_modificationlabel(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
}
inline std::string* SnapshotDiffReportEntryProto::mutable_modificationlabel() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
  return _internal_mutable_modificationlabel();
}
inline const std::string& SnapshotDiffReportEntryProto::_internal_modificationlabel() const {
  return modificationlabel_.GetNoArena();
}
inline void SnapshotDiffReportEntryProto::_internal_set_modificationlabel(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  modificationlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotDiffReportEntryProto::set_modificationlabel(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  modificationlabel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
}
inline void SnapshotDiffReportEntryProto::set_modificationlabel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  modificationlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
}
inline void SnapshotDiffReportEntryProto::set_modificationlabel(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  modificationlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
}
inline std::string* SnapshotDiffReportEntryProto::_internal_mutable_modificationlabel() {
  _has_bits_[0] |= 0x00000002u;
  return modificationlabel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDiffReportEntryProto::release_modificationlabel() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
  if (!_internal_has_modificationlabel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return modificationlabel_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDiffReportEntryProto::set_allocated_modificationlabel(std::string* modificationlabel) {
  if (modificationlabel != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  modificationlabel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modificationlabel);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel)
}

// -------------------------------------------------------------------

// SnapshotDiffReportProto

// required string snapshotRoot = 1;
inline bool SnapshotDiffReportProto::_internal_has_snapshotroot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SnapshotDiffReportProto::has_snapshotroot() const {
  return _internal_has_snapshotroot();
}
inline void SnapshotDiffReportProto::clear_snapshotroot() {
  snapshotroot_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnapshotDiffReportProto::snapshotroot() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
  return _internal_snapshotroot();
}
inline void SnapshotDiffReportProto::set_snapshotroot(const std::string& value) {
  _internal_set_snapshotroot(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
}
inline std::string* SnapshotDiffReportProto::mutable_snapshotroot() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
  return _internal_mutable_snapshotroot();
}
inline const std::string& SnapshotDiffReportProto::_internal_snapshotroot() const {
  return snapshotroot_.GetNoArena();
}
inline void SnapshotDiffReportProto::_internal_set_snapshotroot(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotDiffReportProto::set_snapshotroot(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  snapshotroot_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
}
inline void SnapshotDiffReportProto::set_snapshotroot(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
}
inline void SnapshotDiffReportProto::set_snapshotroot(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
}
inline std::string* SnapshotDiffReportProto::_internal_mutable_snapshotroot() {
  _has_bits_[0] |= 0x00000001u;
  return snapshotroot_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDiffReportProto::release_snapshotroot() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
  if (!_internal_has_snapshotroot()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return snapshotroot_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDiffReportProto::set_allocated_snapshotroot(std::string* snapshotroot) {
  if (snapshotroot != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snapshotroot_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshotroot);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot)
}

// required string fromSnapshot = 2;
inline bool SnapshotDiffReportProto::_internal_has_fromsnapshot() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SnapshotDiffReportProto::has_fromsnapshot() const {
  return _internal_has_fromsnapshot();
}
inline void SnapshotDiffReportProto::clear_fromsnapshot() {
  fromsnapshot_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SnapshotDiffReportProto::fromsnapshot() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
  return _internal_fromsnapshot();
}
inline void SnapshotDiffReportProto::set_fromsnapshot(const std::string& value) {
  _internal_set_fromsnapshot(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
}
inline std::string* SnapshotDiffReportProto::mutable_fromsnapshot() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
  return _internal_mutable_fromsnapshot();
}
inline const std::string& SnapshotDiffReportProto::_internal_fromsnapshot() const {
  return fromsnapshot_.GetNoArena();
}
inline void SnapshotDiffReportProto::_internal_set_fromsnapshot(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fromsnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotDiffReportProto::set_fromsnapshot(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  fromsnapshot_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
}
inline void SnapshotDiffReportProto::set_fromsnapshot(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  fromsnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
}
inline void SnapshotDiffReportProto::set_fromsnapshot(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  fromsnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
}
inline std::string* SnapshotDiffReportProto::_internal_mutable_fromsnapshot() {
  _has_bits_[0] |= 0x00000002u;
  return fromsnapshot_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDiffReportProto::release_fromsnapshot() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
  if (!_internal_has_fromsnapshot()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return fromsnapshot_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDiffReportProto::set_allocated_fromsnapshot(std::string* fromsnapshot) {
  if (fromsnapshot != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fromsnapshot_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fromsnapshot);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot)
}

// required string toSnapshot = 3;
inline bool SnapshotDiffReportProto::_internal_has_tosnapshot() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SnapshotDiffReportProto::has_tosnapshot() const {
  return _internal_has_tosnapshot();
}
inline void SnapshotDiffReportProto::clear_tosnapshot() {
  tosnapshot_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SnapshotDiffReportProto::tosnapshot() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
  return _internal_tosnapshot();
}
inline void SnapshotDiffReportProto::set_tosnapshot(const std::string& value) {
  _internal_set_tosnapshot(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
}
inline std::string* SnapshotDiffReportProto::mutable_tosnapshot() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
  return _internal_mutable_tosnapshot();
}
inline const std::string& SnapshotDiffReportProto::_internal_tosnapshot() const {
  return tosnapshot_.GetNoArena();
}
inline void SnapshotDiffReportProto::_internal_set_tosnapshot(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tosnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotDiffReportProto::set_tosnapshot(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  tosnapshot_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
}
inline void SnapshotDiffReportProto::set_tosnapshot(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  tosnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
}
inline void SnapshotDiffReportProto::set_tosnapshot(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  tosnapshot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
}
inline std::string* SnapshotDiffReportProto::_internal_mutable_tosnapshot() {
  _has_bits_[0] |= 0x00000004u;
  return tosnapshot_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDiffReportProto::release_tosnapshot() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
  if (!_internal_has_tosnapshot()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tosnapshot_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDiffReportProto::set_allocated_tosnapshot(std::string* tosnapshot) {
  if (tosnapshot != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tosnapshot_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tosnapshot);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotDiffReportProto.toSnapshot)
}

// repeated .Hdfs.Internal.SnapshotDiffReportEntryProto diffReportEntries = 4;
inline int SnapshotDiffReportProto::_internal_diffreportentries_size() const {
  return diffreportentries_.size();
}
inline int SnapshotDiffReportProto::diffreportentries_size() const {
  return _internal_diffreportentries_size();
}
inline void SnapshotDiffReportProto::clear_diffreportentries() {
  diffreportentries_.Clear();
}
inline ::Hdfs::Internal::SnapshotDiffReportEntryProto* SnapshotDiffReportProto::mutable_diffreportentries(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotDiffReportProto.diffReportEntries)
  return diffreportentries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshotDiffReportEntryProto >*
SnapshotDiffReportProto::mutable_diffreportentries() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.SnapshotDiffReportProto.diffReportEntries)
  return &diffreportentries_;
}
inline const ::Hdfs::Internal::SnapshotDiffReportEntryProto& SnapshotDiffReportProto::_internal_diffreportentries(int index) const {
  return diffreportentries_.Get(index);
}
inline const ::Hdfs::Internal::SnapshotDiffReportEntryProto& SnapshotDiffReportProto::diffreportentries(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotDiffReportProto.diffReportEntries)
  return _internal_diffreportentries(index);
}
inline ::Hdfs::Internal::SnapshotDiffReportEntryProto* SnapshotDiffReportProto::_internal_add_diffreportentries() {
  return diffreportentries_.Add();
}
inline ::Hdfs::Internal::SnapshotDiffReportEntryProto* SnapshotDiffReportProto::add_diffreportentries() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.SnapshotDiffReportProto.diffReportEntries)
  return _internal_add_diffreportentries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::SnapshotDiffReportEntryProto >&
SnapshotDiffReportProto::diffreportentries() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.SnapshotDiffReportProto.diffReportEntries)
  return diffreportentries_;
}

// -------------------------------------------------------------------

// StorageInfoProto

// required uint32 layoutVersion = 1;
inline bool StorageInfoProto::_internal_has_layoutversion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StorageInfoProto::has_layoutversion() const {
  return _internal_has_layoutversion();
}
inline void StorageInfoProto::clear_layoutversion() {
  layoutversion_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StorageInfoProto::_internal_layoutversion() const {
  return layoutversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StorageInfoProto::layoutversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.StorageInfoProto.layoutVersion)
  return _internal_layoutversion();
}
inline void StorageInfoProto::_internal_set_layoutversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  layoutversion_ = value;
}
inline void StorageInfoProto::set_layoutversion(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_layoutversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageInfoProto.layoutVersion)
}

// required uint32 namespceID = 2;
inline bool StorageInfoProto::_internal_has_namespceid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StorageInfoProto::has_namespceid() const {
  return _internal_has_namespceid();
}
inline void StorageInfoProto::clear_namespceid() {
  namespceid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StorageInfoProto::_internal_namespceid() const {
  return namespceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StorageInfoProto::namespceid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.StorageInfoProto.namespceID)
  return _internal_namespceid();
}
inline void StorageInfoProto::_internal_set_namespceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  namespceid_ = value;
}
inline void StorageInfoProto::set_namespceid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_namespceid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageInfoProto.namespceID)
}

// required string clusterID = 3;
inline bool StorageInfoProto::_internal_has_clusterid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StorageInfoProto::has_clusterid() const {
  return _internal_has_clusterid();
}
inline void StorageInfoProto::clear_clusterid() {
  clusterid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StorageInfoProto::clusterid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.StorageInfoProto.clusterID)
  return _internal_clusterid();
}
inline void StorageInfoProto::set_clusterid(const std::string& value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageInfoProto.clusterID)
}
inline std::string* StorageInfoProto::mutable_clusterid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.StorageInfoProto.clusterID)
  return _internal_mutable_clusterid();
}
inline const std::string& StorageInfoProto::_internal_clusterid() const {
  return clusterid_.GetNoArena();
}
inline void StorageInfoProto::_internal_set_clusterid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clusterid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StorageInfoProto::set_clusterid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  clusterid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.StorageInfoProto.clusterID)
}
inline void StorageInfoProto::set_clusterid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  clusterid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.StorageInfoProto.clusterID)
}
inline void StorageInfoProto::set_clusterid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  clusterid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.StorageInfoProto.clusterID)
}
inline std::string* StorageInfoProto::_internal_mutable_clusterid() {
  _has_bits_[0] |= 0x00000001u;
  return clusterid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StorageInfoProto::release_clusterid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.StorageInfoProto.clusterID)
  if (!_internal_has_clusterid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clusterid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StorageInfoProto::set_allocated_clusterid(std::string* clusterid) {
  if (clusterid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clusterid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clusterid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.StorageInfoProto.clusterID)
}

// required uint64 cTime = 4;
inline bool StorageInfoProto::_internal_has_ctime() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StorageInfoProto::has_ctime() const {
  return _internal_has_ctime();
}
inline void StorageInfoProto::clear_ctime() {
  ctime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StorageInfoProto::_internal_ctime() const {
  return ctime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StorageInfoProto::ctime() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.StorageInfoProto.cTime)
  return _internal_ctime();
}
inline void StorageInfoProto::_internal_set_ctime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ctime_ = value;
}
inline void StorageInfoProto::set_ctime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ctime(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.StorageInfoProto.cTime)
}

// -------------------------------------------------------------------

// NamenodeRegistrationProto

// required string rpcAddress = 1;
inline bool NamenodeRegistrationProto::_internal_has_rpcaddress() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NamenodeRegistrationProto::has_rpcaddress() const {
  return _internal_has_rpcaddress();
}
inline void NamenodeRegistrationProto::clear_rpcaddress() {
  rpcaddress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamenodeRegistrationProto::rpcaddress() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
  return _internal_rpcaddress();
}
inline void NamenodeRegistrationProto::set_rpcaddress(const std::string& value) {
  _internal_set_rpcaddress(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
}
inline std::string* NamenodeRegistrationProto::mutable_rpcaddress() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
  return _internal_mutable_rpcaddress();
}
inline const std::string& NamenodeRegistrationProto::_internal_rpcaddress() const {
  return rpcaddress_.GetNoArena();
}
inline void NamenodeRegistrationProto::_internal_set_rpcaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rpcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NamenodeRegistrationProto::set_rpcaddress(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rpcaddress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
}
inline void NamenodeRegistrationProto::set_rpcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rpcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
}
inline void NamenodeRegistrationProto::set_rpcaddress(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rpcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
}
inline std::string* NamenodeRegistrationProto::_internal_mutable_rpcaddress() {
  _has_bits_[0] |= 0x00000001u;
  return rpcaddress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamenodeRegistrationProto::release_rpcaddress() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
  if (!_internal_has_rpcaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rpcaddress_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamenodeRegistrationProto::set_allocated_rpcaddress(std::string* rpcaddress) {
  if (rpcaddress != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rpcaddress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rpcaddress);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamenodeRegistrationProto.rpcAddress)
}

// required string httpAddress = 2;
inline bool NamenodeRegistrationProto::_internal_has_httpaddress() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NamenodeRegistrationProto::has_httpaddress() const {
  return _internal_has_httpaddress();
}
inline void NamenodeRegistrationProto::clear_httpaddress() {
  httpaddress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NamenodeRegistrationProto::httpaddress() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
  return _internal_httpaddress();
}
inline void NamenodeRegistrationProto::set_httpaddress(const std::string& value) {
  _internal_set_httpaddress(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
}
inline std::string* NamenodeRegistrationProto::mutable_httpaddress() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
  return _internal_mutable_httpaddress();
}
inline const std::string& NamenodeRegistrationProto::_internal_httpaddress() const {
  return httpaddress_.GetNoArena();
}
inline void NamenodeRegistrationProto::_internal_set_httpaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  httpaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NamenodeRegistrationProto::set_httpaddress(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  httpaddress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
}
inline void NamenodeRegistrationProto::set_httpaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  httpaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
}
inline void NamenodeRegistrationProto::set_httpaddress(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  httpaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
}
inline std::string* NamenodeRegistrationProto::_internal_mutable_httpaddress() {
  _has_bits_[0] |= 0x00000002u;
  return httpaddress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamenodeRegistrationProto::release_httpaddress() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
  if (!_internal_has_httpaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return httpaddress_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamenodeRegistrationProto::set_allocated_httpaddress(std::string* httpaddress) {
  if (httpaddress != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  httpaddress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), httpaddress);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamenodeRegistrationProto.httpAddress)
}

// required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
inline bool NamenodeRegistrationProto::_internal_has_storageinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || storageinfo_ != nullptr);
  return value;
}
inline bool NamenodeRegistrationProto::has_storageinfo() const {
  return _internal_has_storageinfo();
}
inline void NamenodeRegistrationProto::clear_storageinfo() {
  if (storageinfo_ != nullptr) storageinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Hdfs::Internal::StorageInfoProto& NamenodeRegistrationProto::_internal_storageinfo() const {
  const ::Hdfs::Internal::StorageInfoProto* p = storageinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::StorageInfoProto*>(
      &::Hdfs::Internal::_StorageInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::StorageInfoProto& NamenodeRegistrationProto::storageinfo() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeRegistrationProto.storageInfo)
  return _internal_storageinfo();
}
inline ::Hdfs::Internal::StorageInfoProto* NamenodeRegistrationProto::release_storageinfo() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamenodeRegistrationProto.storageInfo)
  _has_bits_[0] &= ~0x00000004u;
  ::Hdfs::Internal::StorageInfoProto* temp = storageinfo_;
  storageinfo_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::StorageInfoProto* NamenodeRegistrationProto::_internal_mutable_storageinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (storageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::StorageInfoProto>(GetArenaNoVirtual());
    storageinfo_ = p;
  }
  return storageinfo_;
}
inline ::Hdfs::Internal::StorageInfoProto* NamenodeRegistrationProto::mutable_storageinfo() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamenodeRegistrationProto.storageInfo)
  return _internal_mutable_storageinfo();
}
inline void NamenodeRegistrationProto::set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete storageinfo_;
  }
  if (storageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      storageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storageinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  storageinfo_ = storageinfo;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamenodeRegistrationProto.storageInfo)
}

// optional .Hdfs.Internal.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
inline bool NamenodeRegistrationProto::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NamenodeRegistrationProto::has_role() const {
  return _internal_has_role();
}
inline void NamenodeRegistrationProto::clear_role() {
  role_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::_internal_role() const {
  return static_cast< ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto >(role_);
}
inline ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::role() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeRegistrationProto.role)
  return _internal_role();
}
inline void NamenodeRegistrationProto::_internal_set_role(::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto value) {
  assert(::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  role_ = value;
}
inline void NamenodeRegistrationProto::set_role(::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamenodeRegistrationProto.role)
}

// -------------------------------------------------------------------

// CheckpointSignatureProto

// required string blockPoolId = 1;
inline bool CheckpointSignatureProto::_internal_has_blockpoolid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckpointSignatureProto::has_blockpoolid() const {
  return _internal_has_blockpoolid();
}
inline void CheckpointSignatureProto::clear_blockpoolid() {
  blockpoolid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckpointSignatureProto::blockpoolid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
  return _internal_blockpoolid();
}
inline void CheckpointSignatureProto::set_blockpoolid(const std::string& value) {
  _internal_set_blockpoolid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
}
inline std::string* CheckpointSignatureProto::mutable_blockpoolid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
  return _internal_mutable_blockpoolid();
}
inline const std::string& CheckpointSignatureProto::_internal_blockpoolid() const {
  return blockpoolid_.GetNoArena();
}
inline void CheckpointSignatureProto::_internal_set_blockpoolid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CheckpointSignatureProto::set_blockpoolid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
}
inline void CheckpointSignatureProto::set_blockpoolid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
}
inline void CheckpointSignatureProto::set_blockpoolid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
}
inline std::string* CheckpointSignatureProto::_internal_mutable_blockpoolid() {
  _has_bits_[0] |= 0x00000001u;
  return blockpoolid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckpointSignatureProto::release_blockpoolid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
  if (!_internal_has_blockpoolid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return blockpoolid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckpointSignatureProto::set_allocated_blockpoolid(std::string* blockpoolid) {
  if (blockpoolid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blockpoolid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockpoolid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CheckpointSignatureProto.blockPoolId)
}

// required uint64 mostRecentCheckpointTxId = 2;
inline bool CheckpointSignatureProto::_internal_has_mostrecentcheckpointtxid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CheckpointSignatureProto::has_mostrecentcheckpointtxid() const {
  return _internal_has_mostrecentcheckpointtxid();
}
inline void CheckpointSignatureProto::clear_mostrecentcheckpointtxid() {
  mostrecentcheckpointtxid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CheckpointSignatureProto::_internal_mostrecentcheckpointtxid() const {
  return mostrecentcheckpointtxid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CheckpointSignatureProto::mostrecentcheckpointtxid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointSignatureProto.mostRecentCheckpointTxId)
  return _internal_mostrecentcheckpointtxid();
}
inline void CheckpointSignatureProto::_internal_set_mostrecentcheckpointtxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  mostrecentcheckpointtxid_ = value;
}
inline void CheckpointSignatureProto::set_mostrecentcheckpointtxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_mostrecentcheckpointtxid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CheckpointSignatureProto.mostRecentCheckpointTxId)
}

// required uint64 curSegmentTxId = 3;
inline bool CheckpointSignatureProto::_internal_has_cursegmenttxid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CheckpointSignatureProto::has_cursegmenttxid() const {
  return _internal_has_cursegmenttxid();
}
inline void CheckpointSignatureProto::clear_cursegmenttxid() {
  cursegmenttxid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CheckpointSignatureProto::_internal_cursegmenttxid() const {
  return cursegmenttxid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CheckpointSignatureProto::cursegmenttxid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointSignatureProto.curSegmentTxId)
  return _internal_cursegmenttxid();
}
inline void CheckpointSignatureProto::_internal_set_cursegmenttxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  cursegmenttxid_ = value;
}
inline void CheckpointSignatureProto::set_cursegmenttxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cursegmenttxid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CheckpointSignatureProto.curSegmentTxId)
}

// required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
inline bool CheckpointSignatureProto::_internal_has_storageinfo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || storageinfo_ != nullptr);
  return value;
}
inline bool CheckpointSignatureProto::has_storageinfo() const {
  return _internal_has_storageinfo();
}
inline void CheckpointSignatureProto::clear_storageinfo() {
  if (storageinfo_ != nullptr) storageinfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Hdfs::Internal::StorageInfoProto& CheckpointSignatureProto::_internal_storageinfo() const {
  const ::Hdfs::Internal::StorageInfoProto* p = storageinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::StorageInfoProto*>(
      &::Hdfs::Internal::_StorageInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::StorageInfoProto& CheckpointSignatureProto::storageinfo() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointSignatureProto.storageInfo)
  return _internal_storageinfo();
}
inline ::Hdfs::Internal::StorageInfoProto* CheckpointSignatureProto::release_storageinfo() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CheckpointSignatureProto.storageInfo)
  _has_bits_[0] &= ~0x00000002u;
  ::Hdfs::Internal::StorageInfoProto* temp = storageinfo_;
  storageinfo_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::StorageInfoProto* CheckpointSignatureProto::_internal_mutable_storageinfo() {
  _has_bits_[0] |= 0x00000002u;
  if (storageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::StorageInfoProto>(GetArenaNoVirtual());
    storageinfo_ = p;
  }
  return storageinfo_;
}
inline ::Hdfs::Internal::StorageInfoProto* CheckpointSignatureProto::mutable_storageinfo() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CheckpointSignatureProto.storageInfo)
  return _internal_mutable_storageinfo();
}
inline void CheckpointSignatureProto::set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete storageinfo_;
  }
  if (storageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      storageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storageinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  storageinfo_ = storageinfo;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CheckpointSignatureProto.storageInfo)
}

// -------------------------------------------------------------------

// NamenodeCommandProto

// required uint32 action = 1;
inline bool NamenodeCommandProto::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NamenodeCommandProto::has_action() const {
  return _internal_has_action();
}
inline void NamenodeCommandProto::clear_action() {
  action_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NamenodeCommandProto::_internal_action() const {
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NamenodeCommandProto::action() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeCommandProto.action)
  return _internal_action();
}
inline void NamenodeCommandProto::_internal_set_action(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void NamenodeCommandProto::set_action(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamenodeCommandProto.action)
}

// required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
inline bool NamenodeCommandProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NamenodeCommandProto::has_type() const {
  return _internal_has_type();
}
inline void NamenodeCommandProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Hdfs::Internal::NamenodeCommandProto_Type NamenodeCommandProto::_internal_type() const {
  return static_cast< ::Hdfs::Internal::NamenodeCommandProto_Type >(type_);
}
inline ::Hdfs::Internal::NamenodeCommandProto_Type NamenodeCommandProto::type() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeCommandProto.type)
  return _internal_type();
}
inline void NamenodeCommandProto::_internal_set_type(::Hdfs::Internal::NamenodeCommandProto_Type value) {
  assert(::Hdfs::Internal::NamenodeCommandProto_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void NamenodeCommandProto::set_type(::Hdfs::Internal::NamenodeCommandProto_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamenodeCommandProto.type)
}

// optional .Hdfs.Internal.CheckpointCommandProto checkpointCmd = 3;
inline bool NamenodeCommandProto::_internal_has_checkpointcmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || checkpointcmd_ != nullptr);
  return value;
}
inline bool NamenodeCommandProto::has_checkpointcmd() const {
  return _internal_has_checkpointcmd();
}
inline void NamenodeCommandProto::clear_checkpointcmd() {
  if (checkpointcmd_ != nullptr) checkpointcmd_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::CheckpointCommandProto& NamenodeCommandProto::_internal_checkpointcmd() const {
  const ::Hdfs::Internal::CheckpointCommandProto* p = checkpointcmd_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::CheckpointCommandProto*>(
      &::Hdfs::Internal::_CheckpointCommandProto_default_instance_);
}
inline const ::Hdfs::Internal::CheckpointCommandProto& NamenodeCommandProto::checkpointcmd() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamenodeCommandProto.checkpointCmd)
  return _internal_checkpointcmd();
}
inline ::Hdfs::Internal::CheckpointCommandProto* NamenodeCommandProto::release_checkpointcmd() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamenodeCommandProto.checkpointCmd)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::CheckpointCommandProto* temp = checkpointcmd_;
  checkpointcmd_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::CheckpointCommandProto* NamenodeCommandProto::_internal_mutable_checkpointcmd() {
  _has_bits_[0] |= 0x00000001u;
  if (checkpointcmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::CheckpointCommandProto>(GetArenaNoVirtual());
    checkpointcmd_ = p;
  }
  return checkpointcmd_;
}
inline ::Hdfs::Internal::CheckpointCommandProto* NamenodeCommandProto::mutable_checkpointcmd() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamenodeCommandProto.checkpointCmd)
  return _internal_mutable_checkpointcmd();
}
inline void NamenodeCommandProto::set_allocated_checkpointcmd(::Hdfs::Internal::CheckpointCommandProto* checkpointcmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete checkpointcmd_;
  }
  if (checkpointcmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      checkpointcmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checkpointcmd, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  checkpointcmd_ = checkpointcmd;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamenodeCommandProto.checkpointCmd)
}

// -------------------------------------------------------------------

// CheckpointCommandProto

// required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
inline bool CheckpointCommandProto::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || signature_ != nullptr);
  return value;
}
inline bool CheckpointCommandProto::has_signature() const {
  return _internal_has_signature();
}
inline void CheckpointCommandProto::clear_signature() {
  if (signature_ != nullptr) signature_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::CheckpointSignatureProto& CheckpointCommandProto::_internal_signature() const {
  const ::Hdfs::Internal::CheckpointSignatureProto* p = signature_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::CheckpointSignatureProto*>(
      &::Hdfs::Internal::_CheckpointSignatureProto_default_instance_);
}
inline const ::Hdfs::Internal::CheckpointSignatureProto& CheckpointCommandProto::signature() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointCommandProto.signature)
  return _internal_signature();
}
inline ::Hdfs::Internal::CheckpointSignatureProto* CheckpointCommandProto::release_signature() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.CheckpointCommandProto.signature)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::CheckpointSignatureProto* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::CheckpointSignatureProto* CheckpointCommandProto::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::CheckpointSignatureProto>(GetArenaNoVirtual());
    signature_ = p;
  }
  return signature_;
}
inline ::Hdfs::Internal::CheckpointSignatureProto* CheckpointCommandProto::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.CheckpointCommandProto.signature)
  return _internal_mutable_signature();
}
inline void CheckpointCommandProto::set_allocated_signature(::Hdfs::Internal::CheckpointSignatureProto* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signature_;
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.CheckpointCommandProto.signature)
}

// required bool needToReturnImage = 2;
inline bool CheckpointCommandProto::_internal_has_needtoreturnimage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CheckpointCommandProto::has_needtoreturnimage() const {
  return _internal_has_needtoreturnimage();
}
inline void CheckpointCommandProto::clear_needtoreturnimage() {
  needtoreturnimage_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CheckpointCommandProto::_internal_needtoreturnimage() const {
  return needtoreturnimage_;
}
inline bool CheckpointCommandProto::needtoreturnimage() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.CheckpointCommandProto.needToReturnImage)
  return _internal_needtoreturnimage();
}
inline void CheckpointCommandProto::_internal_set_needtoreturnimage(bool value) {
  _has_bits_[0] |= 0x00000002u;
  needtoreturnimage_ = value;
}
inline void CheckpointCommandProto::set_needtoreturnimage(bool value) {
  _internal_set_needtoreturnimage(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.CheckpointCommandProto.needToReturnImage)
}

// -------------------------------------------------------------------

// BlockProto

// required uint64 blockId = 1;
inline bool BlockProto::_internal_has_blockid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockProto::has_blockid() const {
  return _internal_has_blockid();
}
inline void BlockProto::clear_blockid() {
  blockid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::_internal_blockid() const {
  return blockid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::blockid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockProto.blockId)
  return _internal_blockid();
}
inline void BlockProto::_internal_set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  blockid_ = value;
}
inline void BlockProto::set_blockid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockProto.blockId)
}

// required uint64 genStamp = 2;
inline bool BlockProto::_internal_has_genstamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockProto::has_genstamp() const {
  return _internal_has_genstamp();
}
inline void BlockProto::clear_genstamp() {
  genstamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::_internal_genstamp() const {
  return genstamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::genstamp() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockProto.genStamp)
  return _internal_genstamp();
}
inline void BlockProto::_internal_set_genstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  genstamp_ = value;
}
inline void BlockProto::set_genstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_genstamp(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockProto.genStamp)
}

// optional uint64 numBytes = 3 [default = 0];
inline bool BlockProto::_internal_has_numbytes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlockProto::has_numbytes() const {
  return _internal_has_numbytes();
}
inline void BlockProto::clear_numbytes() {
  numbytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::_internal_numbytes() const {
  return numbytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockProto::numbytes() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockProto.numBytes)
  return _internal_numbytes();
}
inline void BlockProto::_internal_set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  numbytes_ = value;
}
inline void BlockProto::set_numbytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_numbytes(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockProto.numBytes)
}

// -------------------------------------------------------------------

// BlockWithLocationsProto

// required .Hdfs.Internal.BlockProto block = 1;
inline bool BlockWithLocationsProto::_internal_has_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || block_ != nullptr);
  return value;
}
inline bool BlockWithLocationsProto::has_block() const {
  return _internal_has_block();
}
inline void BlockWithLocationsProto::clear_block() {
  if (block_ != nullptr) block_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::BlockProto& BlockWithLocationsProto::_internal_block() const {
  const ::Hdfs::Internal::BlockProto* p = block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BlockProto*>(
      &::Hdfs::Internal::_BlockProto_default_instance_);
}
inline const ::Hdfs::Internal::BlockProto& BlockWithLocationsProto::block() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockWithLocationsProto.block)
  return _internal_block();
}
inline ::Hdfs::Internal::BlockProto* BlockWithLocationsProto::release_block() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockWithLocationsProto.block)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::BlockProto* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BlockProto* BlockWithLocationsProto::_internal_mutable_block() {
  _has_bits_[0] |= 0x00000001u;
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BlockProto>(GetArenaNoVirtual());
    block_ = p;
  }
  return block_;
}
inline ::Hdfs::Internal::BlockProto* BlockWithLocationsProto::mutable_block() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockWithLocationsProto.block)
  return _internal_mutable_block();
}
inline void BlockWithLocationsProto::set_allocated_block(::Hdfs::Internal::BlockProto* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockWithLocationsProto.block)
}

// repeated string datanodeUuids = 2;
inline int BlockWithLocationsProto::_internal_datanodeuuids_size() const {
  return datanodeuuids_.size();
}
inline int BlockWithLocationsProto::datanodeuuids_size() const {
  return _internal_datanodeuuids_size();
}
inline void BlockWithLocationsProto::clear_datanodeuuids() {
  datanodeuuids_.Clear();
}
inline std::string* BlockWithLocationsProto::add_datanodeuuids() {
  // @@protoc_insertion_point(field_add_mutable:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  return _internal_add_datanodeuuids();
}
inline const std::string& BlockWithLocationsProto::_internal_datanodeuuids(int index) const {
  return datanodeuuids_.Get(index);
}
inline const std::string& BlockWithLocationsProto::datanodeuuids(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  return _internal_datanodeuuids(index);
}
inline std::string* BlockWithLocationsProto::mutable_datanodeuuids(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  return datanodeuuids_.Mutable(index);
}
inline void BlockWithLocationsProto::set_datanodeuuids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  datanodeuuids_.Mutable(index)->assign(value);
}
inline void BlockWithLocationsProto::set_datanodeuuids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  datanodeuuids_.Mutable(index)->assign(std::move(value));
}
inline void BlockWithLocationsProto::set_datanodeuuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  datanodeuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline void BlockWithLocationsProto::set_datanodeuuids(int index, const char* value, size_t size) {
  datanodeuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline std::string* BlockWithLocationsProto::_internal_add_datanodeuuids() {
  return datanodeuuids_.Add();
}
inline void BlockWithLocationsProto::add_datanodeuuids(const std::string& value) {
  datanodeuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline void BlockWithLocationsProto::add_datanodeuuids(std::string&& value) {
  datanodeuuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline void BlockWithLocationsProto::add_datanodeuuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  datanodeuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline void BlockWithLocationsProto::add_datanodeuuids(const char* value, size_t size) {
  datanodeuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockWithLocationsProto::datanodeuuids() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  return datanodeuuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockWithLocationsProto::mutable_datanodeuuids() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.BlockWithLocationsProto.datanodeUuids)
  return &datanodeuuids_;
}

// repeated string storageUuids = 3;
inline int BlockWithLocationsProto::_internal_storageuuids_size() const {
  return storageuuids_.size();
}
inline int BlockWithLocationsProto::storageuuids_size() const {
  return _internal_storageuuids_size();
}
inline void BlockWithLocationsProto::clear_storageuuids() {
  storageuuids_.Clear();
}
inline std::string* BlockWithLocationsProto::add_storageuuids() {
  // @@protoc_insertion_point(field_add_mutable:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  return _internal_add_storageuuids();
}
inline const std::string& BlockWithLocationsProto::_internal_storageuuids(int index) const {
  return storageuuids_.Get(index);
}
inline const std::string& BlockWithLocationsProto::storageuuids(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  return _internal_storageuuids(index);
}
inline std::string* BlockWithLocationsProto::mutable_storageuuids(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  return storageuuids_.Mutable(index);
}
inline void BlockWithLocationsProto::set_storageuuids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  storageuuids_.Mutable(index)->assign(value);
}
inline void BlockWithLocationsProto::set_storageuuids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  storageuuids_.Mutable(index)->assign(std::move(value));
}
inline void BlockWithLocationsProto::set_storageuuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline void BlockWithLocationsProto::set_storageuuids(int index, const char* value, size_t size) {
  storageuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline std::string* BlockWithLocationsProto::_internal_add_storageuuids() {
  return storageuuids_.Add();
}
inline void BlockWithLocationsProto::add_storageuuids(const std::string& value) {
  storageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline void BlockWithLocationsProto::add_storageuuids(std::string&& value) {
  storageuuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline void BlockWithLocationsProto::add_storageuuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  storageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline void BlockWithLocationsProto::add_storageuuids(const char* value, size_t size) {
  storageuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockWithLocationsProto::storageuuids() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  return storageuuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockWithLocationsProto::mutable_storageuuids() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.BlockWithLocationsProto.storageUuids)
  return &storageuuids_;
}

// -------------------------------------------------------------------

// BlocksWithLocationsProto

// repeated .Hdfs.Internal.BlockWithLocationsProto blocks = 1;
inline int BlocksWithLocationsProto::_internal_blocks_size() const {
  return blocks_.size();
}
inline int BlocksWithLocationsProto::blocks_size() const {
  return _internal_blocks_size();
}
inline void BlocksWithLocationsProto::clear_blocks() {
  blocks_.Clear();
}
inline ::Hdfs::Internal::BlockWithLocationsProto* BlocksWithLocationsProto::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlocksWithLocationsProto.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockWithLocationsProto >*
BlocksWithLocationsProto::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.BlocksWithLocationsProto.blocks)
  return &blocks_;
}
inline const ::Hdfs::Internal::BlockWithLocationsProto& BlocksWithLocationsProto::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::Hdfs::Internal::BlockWithLocationsProto& BlocksWithLocationsProto::blocks(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlocksWithLocationsProto.blocks)
  return _internal_blocks(index);
}
inline ::Hdfs::Internal::BlockWithLocationsProto* BlocksWithLocationsProto::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::Hdfs::Internal::BlockWithLocationsProto* BlocksWithLocationsProto::add_blocks() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.BlocksWithLocationsProto.blocks)
  return _internal_add_blocks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockWithLocationsProto >&
BlocksWithLocationsProto::blocks() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.BlocksWithLocationsProto.blocks)
  return blocks_;
}

// -------------------------------------------------------------------

// RemoteEditLogProto

// required uint64 startTxId = 1;
inline bool RemoteEditLogProto::_internal_has_starttxid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoteEditLogProto::has_starttxid() const {
  return _internal_has_starttxid();
}
inline void RemoteEditLogProto::clear_starttxid() {
  starttxid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoteEditLogProto::_internal_starttxid() const {
  return starttxid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoteEditLogProto::starttxid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RemoteEditLogProto.startTxId)
  return _internal_starttxid();
}
inline void RemoteEditLogProto::_internal_set_starttxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  starttxid_ = value;
}
inline void RemoteEditLogProto::set_starttxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_starttxid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RemoteEditLogProto.startTxId)
}

// required uint64 endTxId = 2;
inline bool RemoteEditLogProto::_internal_has_endtxid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoteEditLogProto::has_endtxid() const {
  return _internal_has_endtxid();
}
inline void RemoteEditLogProto::clear_endtxid() {
  endtxid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoteEditLogProto::_internal_endtxid() const {
  return endtxid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RemoteEditLogProto::endtxid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RemoteEditLogProto.endTxId)
  return _internal_endtxid();
}
inline void RemoteEditLogProto::_internal_set_endtxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  endtxid_ = value;
}
inline void RemoteEditLogProto::set_endtxid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_endtxid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RemoteEditLogProto.endTxId)
}

// optional bool isInProgress = 3 [default = false];
inline bool RemoteEditLogProto::_internal_has_isinprogress() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoteEditLogProto::has_isinprogress() const {
  return _internal_has_isinprogress();
}
inline void RemoteEditLogProto::clear_isinprogress() {
  isinprogress_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RemoteEditLogProto::_internal_isinprogress() const {
  return isinprogress_;
}
inline bool RemoteEditLogProto::isinprogress() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RemoteEditLogProto.isInProgress)
  return _internal_isinprogress();
}
inline void RemoteEditLogProto::_internal_set_isinprogress(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isinprogress_ = value;
}
inline void RemoteEditLogProto::set_isinprogress(bool value) {
  _internal_set_isinprogress(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RemoteEditLogProto.isInProgress)
}

// -------------------------------------------------------------------

// RemoteEditLogManifestProto

// repeated .Hdfs.Internal.RemoteEditLogProto logs = 1;
inline int RemoteEditLogManifestProto::_internal_logs_size() const {
  return logs_.size();
}
inline int RemoteEditLogManifestProto::logs_size() const {
  return _internal_logs_size();
}
inline void RemoteEditLogManifestProto::clear_logs() {
  logs_.Clear();
}
inline ::Hdfs::Internal::RemoteEditLogProto* RemoteEditLogManifestProto::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RemoteEditLogManifestProto.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RemoteEditLogProto >*
RemoteEditLogManifestProto::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.RemoteEditLogManifestProto.logs)
  return &logs_;
}
inline const ::Hdfs::Internal::RemoteEditLogProto& RemoteEditLogManifestProto::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::Hdfs::Internal::RemoteEditLogProto& RemoteEditLogManifestProto::logs(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RemoteEditLogManifestProto.logs)
  return _internal_logs(index);
}
inline ::Hdfs::Internal::RemoteEditLogProto* RemoteEditLogManifestProto::_internal_add_logs() {
  return logs_.Add();
}
inline ::Hdfs::Internal::RemoteEditLogProto* RemoteEditLogManifestProto::add_logs() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.RemoteEditLogManifestProto.logs)
  return _internal_add_logs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::RemoteEditLogProto >&
RemoteEditLogManifestProto::logs() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.RemoteEditLogManifestProto.logs)
  return logs_;
}

// -------------------------------------------------------------------

// NamespaceInfoProto

// required string buildVersion = 1;
inline bool NamespaceInfoProto::_internal_has_buildversion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NamespaceInfoProto::has_buildversion() const {
  return _internal_has_buildversion();
}
inline void NamespaceInfoProto::clear_buildversion() {
  buildversion_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespaceInfoProto::buildversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamespaceInfoProto.buildVersion)
  return _internal_buildversion();
}
inline void NamespaceInfoProto::set_buildversion(const std::string& value) {
  _internal_set_buildversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamespaceInfoProto.buildVersion)
}
inline std::string* NamespaceInfoProto::mutable_buildversion() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamespaceInfoProto.buildVersion)
  return _internal_mutable_buildversion();
}
inline const std::string& NamespaceInfoProto::_internal_buildversion() const {
  return buildversion_.GetNoArena();
}
inline void NamespaceInfoProto::_internal_set_buildversion(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  buildversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NamespaceInfoProto::set_buildversion(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  buildversion_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.NamespaceInfoProto.buildVersion)
}
inline void NamespaceInfoProto::set_buildversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  buildversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.NamespaceInfoProto.buildVersion)
}
inline void NamespaceInfoProto::set_buildversion(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  buildversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.NamespaceInfoProto.buildVersion)
}
inline std::string* NamespaceInfoProto::_internal_mutable_buildversion() {
  _has_bits_[0] |= 0x00000001u;
  return buildversion_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespaceInfoProto::release_buildversion() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamespaceInfoProto.buildVersion)
  if (!_internal_has_buildversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return buildversion_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespaceInfoProto::set_allocated_buildversion(std::string* buildversion) {
  if (buildversion != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buildversion_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buildversion);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamespaceInfoProto.buildVersion)
}

// required uint32 unused = 2;
inline bool NamespaceInfoProto::_internal_has_unused() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NamespaceInfoProto::has_unused() const {
  return _internal_has_unused();
}
inline void NamespaceInfoProto::clear_unused() {
  unused_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NamespaceInfoProto::_internal_unused() const {
  return unused_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NamespaceInfoProto::unused() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamespaceInfoProto.unused)
  return _internal_unused();
}
inline void NamespaceInfoProto::_internal_set_unused(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  unused_ = value;
}
inline void NamespaceInfoProto::set_unused(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unused(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamespaceInfoProto.unused)
}

// required string blockPoolID = 3;
inline bool NamespaceInfoProto::_internal_has_blockpoolid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NamespaceInfoProto::has_blockpoolid() const {
  return _internal_has_blockpoolid();
}
inline void NamespaceInfoProto::clear_blockpoolid() {
  blockpoolid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NamespaceInfoProto::blockpoolid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
  return _internal_blockpoolid();
}
inline void NamespaceInfoProto::set_blockpoolid(const std::string& value) {
  _internal_set_blockpoolid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
}
inline std::string* NamespaceInfoProto::mutable_blockpoolid() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
  return _internal_mutable_blockpoolid();
}
inline const std::string& NamespaceInfoProto::_internal_blockpoolid() const {
  return blockpoolid_.GetNoArena();
}
inline void NamespaceInfoProto::_internal_set_blockpoolid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NamespaceInfoProto::set_blockpoolid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  blockpoolid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
}
inline void NamespaceInfoProto::set_blockpoolid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
}
inline void NamespaceInfoProto::set_blockpoolid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  blockpoolid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
}
inline std::string* NamespaceInfoProto::_internal_mutable_blockpoolid() {
  _has_bits_[0] |= 0x00000002u;
  return blockpoolid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespaceInfoProto::release_blockpoolid() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
  if (!_internal_has_blockpoolid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return blockpoolid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespaceInfoProto::set_allocated_blockpoolid(std::string* blockpoolid) {
  if (blockpoolid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blockpoolid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockpoolid);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamespaceInfoProto.blockPoolID)
}

// required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
inline bool NamespaceInfoProto::_internal_has_storageinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || storageinfo_ != nullptr);
  return value;
}
inline bool NamespaceInfoProto::has_storageinfo() const {
  return _internal_has_storageinfo();
}
inline void NamespaceInfoProto::clear_storageinfo() {
  if (storageinfo_ != nullptr) storageinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Hdfs::Internal::StorageInfoProto& NamespaceInfoProto::_internal_storageinfo() const {
  const ::Hdfs::Internal::StorageInfoProto* p = storageinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::StorageInfoProto*>(
      &::Hdfs::Internal::_StorageInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::StorageInfoProto& NamespaceInfoProto::storageinfo() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamespaceInfoProto.storageInfo)
  return _internal_storageinfo();
}
inline ::Hdfs::Internal::StorageInfoProto* NamespaceInfoProto::release_storageinfo() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamespaceInfoProto.storageInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::Hdfs::Internal::StorageInfoProto* temp = storageinfo_;
  storageinfo_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::StorageInfoProto* NamespaceInfoProto::_internal_mutable_storageinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (storageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::StorageInfoProto>(GetArenaNoVirtual());
    storageinfo_ = p;
  }
  return storageinfo_;
}
inline ::Hdfs::Internal::StorageInfoProto* NamespaceInfoProto::mutable_storageinfo() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamespaceInfoProto.storageInfo)
  return _internal_mutable_storageinfo();
}
inline void NamespaceInfoProto::set_allocated_storageinfo(::Hdfs::Internal::StorageInfoProto* storageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete storageinfo_;
  }
  if (storageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      storageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storageinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  storageinfo_ = storageinfo;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamespaceInfoProto.storageInfo)
}

// required string softwareVersion = 5;
inline bool NamespaceInfoProto::_internal_has_softwareversion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NamespaceInfoProto::has_softwareversion() const {
  return _internal_has_softwareversion();
}
inline void NamespaceInfoProto::clear_softwareversion() {
  softwareversion_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NamespaceInfoProto::softwareversion() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
  return _internal_softwareversion();
}
inline void NamespaceInfoProto::set_softwareversion(const std::string& value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
}
inline std::string* NamespaceInfoProto::mutable_softwareversion() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
  return _internal_mutable_softwareversion();
}
inline const std::string& NamespaceInfoProto::_internal_softwareversion() const {
  return softwareversion_.GetNoArena();
}
inline void NamespaceInfoProto::_internal_set_softwareversion(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  softwareversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void NamespaceInfoProto::set_softwareversion(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  softwareversion_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
}
inline void NamespaceInfoProto::set_softwareversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  softwareversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
}
inline void NamespaceInfoProto::set_softwareversion(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  softwareversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
}
inline std::string* NamespaceInfoProto::_internal_mutable_softwareversion() {
  _has_bits_[0] |= 0x00000004u;
  return softwareversion_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespaceInfoProto::release_softwareversion() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
  if (!_internal_has_softwareversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return softwareversion_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespaceInfoProto::set_allocated_softwareversion(std::string* softwareversion) {
  if (softwareversion != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  softwareversion_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softwareversion);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.NamespaceInfoProto.softwareVersion)
}

// -------------------------------------------------------------------

// BlockKeyProto

// required uint32 keyId = 1;
inline bool BlockKeyProto::_internal_has_keyid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlockKeyProto::has_keyid() const {
  return _internal_has_keyid();
}
inline void BlockKeyProto::clear_keyid() {
  keyid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockKeyProto::_internal_keyid() const {
  return keyid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BlockKeyProto::keyid() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockKeyProto.keyId)
  return _internal_keyid();
}
inline void BlockKeyProto::_internal_set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  keyid_ = value;
}
inline void BlockKeyProto::set_keyid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_keyid(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockKeyProto.keyId)
}

// required uint64 expiryDate = 2;
inline bool BlockKeyProto::_internal_has_expirydate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockKeyProto::has_expirydate() const {
  return _internal_has_expirydate();
}
inline void BlockKeyProto::clear_expirydate() {
  expirydate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockKeyProto::_internal_expirydate() const {
  return expirydate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockKeyProto::expirydate() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockKeyProto.expiryDate)
  return _internal_expirydate();
}
inline void BlockKeyProto::_internal_set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  expirydate_ = value;
}
inline void BlockKeyProto::set_expirydate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_expirydate(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockKeyProto.expiryDate)
}

// optional bytes keyBytes = 3;
inline bool BlockKeyProto::_internal_has_keybytes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockKeyProto::has_keybytes() const {
  return _internal_has_keybytes();
}
inline void BlockKeyProto::clear_keybytes() {
  keybytes_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockKeyProto::keybytes() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.BlockKeyProto.keyBytes)
  return _internal_keybytes();
}
inline void BlockKeyProto::set_keybytes(const std::string& value) {
  _internal_set_keybytes(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.BlockKeyProto.keyBytes)
}
inline std::string* BlockKeyProto::mutable_keybytes() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.BlockKeyProto.keyBytes)
  return _internal_mutable_keybytes();
}
inline const std::string& BlockKeyProto::_internal_keybytes() const {
  return keybytes_.GetNoArena();
}
inline void BlockKeyProto::_internal_set_keybytes(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  keybytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BlockKeyProto::set_keybytes(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  keybytes_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.BlockKeyProto.keyBytes)
}
inline void BlockKeyProto::set_keybytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  keybytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.BlockKeyProto.keyBytes)
}
inline void BlockKeyProto::set_keybytes(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  keybytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.BlockKeyProto.keyBytes)
}
inline std::string* BlockKeyProto::_internal_mutable_keybytes() {
  _has_bits_[0] |= 0x00000001u;
  return keybytes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BlockKeyProto::release_keybytes() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.BlockKeyProto.keyBytes)
  if (!_internal_has_keybytes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return keybytes_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BlockKeyProto::set_allocated_keybytes(std::string* keybytes) {
  if (keybytes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keybytes_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keybytes);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.BlockKeyProto.keyBytes)
}

// -------------------------------------------------------------------

// ExportedBlockKeysProto

// required bool isBlockTokenEnabled = 1;
inline bool ExportedBlockKeysProto::_internal_has_isblocktokenenabled() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExportedBlockKeysProto::has_isblocktokenenabled() const {
  return _internal_has_isblocktokenenabled();
}
inline void ExportedBlockKeysProto::clear_isblocktokenenabled() {
  isblocktokenenabled_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ExportedBlockKeysProto::_internal_isblocktokenenabled() const {
  return isblocktokenenabled_;
}
inline bool ExportedBlockKeysProto::isblocktokenenabled() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExportedBlockKeysProto.isBlockTokenEnabled)
  return _internal_isblocktokenenabled();
}
inline void ExportedBlockKeysProto::_internal_set_isblocktokenenabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  isblocktokenenabled_ = value;
}
inline void ExportedBlockKeysProto::set_isblocktokenenabled(bool value) {
  _internal_set_isblocktokenenabled(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExportedBlockKeysProto.isBlockTokenEnabled)
}

// required uint64 keyUpdateInterval = 2;
inline bool ExportedBlockKeysProto::_internal_has_keyupdateinterval() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExportedBlockKeysProto::has_keyupdateinterval() const {
  return _internal_has_keyupdateinterval();
}
inline void ExportedBlockKeysProto::clear_keyupdateinterval() {
  keyupdateinterval_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExportedBlockKeysProto::_internal_keyupdateinterval() const {
  return keyupdateinterval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExportedBlockKeysProto::keyupdateinterval() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExportedBlockKeysProto.keyUpdateInterval)
  return _internal_keyupdateinterval();
}
inline void ExportedBlockKeysProto::_internal_set_keyupdateinterval(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  keyupdateinterval_ = value;
}
inline void ExportedBlockKeysProto::set_keyupdateinterval(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_keyupdateinterval(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExportedBlockKeysProto.keyUpdateInterval)
}

// required uint64 tokenLifeTime = 3;
inline bool ExportedBlockKeysProto::_internal_has_tokenlifetime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExportedBlockKeysProto::has_tokenlifetime() const {
  return _internal_has_tokenlifetime();
}
inline void ExportedBlockKeysProto::clear_tokenlifetime() {
  tokenlifetime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExportedBlockKeysProto::_internal_tokenlifetime() const {
  return tokenlifetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExportedBlockKeysProto::tokenlifetime() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExportedBlockKeysProto.tokenLifeTime)
  return _internal_tokenlifetime();
}
inline void ExportedBlockKeysProto::_internal_set_tokenlifetime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  tokenlifetime_ = value;
}
inline void ExportedBlockKeysProto::set_tokenlifetime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tokenlifetime(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.ExportedBlockKeysProto.tokenLifeTime)
}

// required .Hdfs.Internal.BlockKeyProto currentKey = 4;
inline bool ExportedBlockKeysProto::_internal_has_currentkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || currentkey_ != nullptr);
  return value;
}
inline bool ExportedBlockKeysProto::has_currentkey() const {
  return _internal_has_currentkey();
}
inline void ExportedBlockKeysProto::clear_currentkey() {
  if (currentkey_ != nullptr) currentkey_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::BlockKeyProto& ExportedBlockKeysProto::_internal_currentkey() const {
  const ::Hdfs::Internal::BlockKeyProto* p = currentkey_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::BlockKeyProto*>(
      &::Hdfs::Internal::_BlockKeyProto_default_instance_);
}
inline const ::Hdfs::Internal::BlockKeyProto& ExportedBlockKeysProto::currentkey() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExportedBlockKeysProto.currentKey)
  return _internal_currentkey();
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::release_currentkey() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.ExportedBlockKeysProto.currentKey)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::BlockKeyProto* temp = currentkey_;
  currentkey_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::_internal_mutable_currentkey() {
  _has_bits_[0] |= 0x00000001u;
  if (currentkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::BlockKeyProto>(GetArenaNoVirtual());
    currentkey_ = p;
  }
  return currentkey_;
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::mutable_currentkey() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ExportedBlockKeysProto.currentKey)
  return _internal_mutable_currentkey();
}
inline void ExportedBlockKeysProto::set_allocated_currentkey(::Hdfs::Internal::BlockKeyProto* currentkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete currentkey_;
  }
  if (currentkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      currentkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentkey, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  currentkey_ = currentkey;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.ExportedBlockKeysProto.currentKey)
}

// repeated .Hdfs.Internal.BlockKeyProto allKeys = 5;
inline int ExportedBlockKeysProto::_internal_allkeys_size() const {
  return allkeys_.size();
}
inline int ExportedBlockKeysProto::allkeys_size() const {
  return _internal_allkeys_size();
}
inline void ExportedBlockKeysProto::clear_allkeys() {
  allkeys_.Clear();
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::mutable_allkeys(int index) {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.ExportedBlockKeysProto.allKeys)
  return allkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockKeyProto >*
ExportedBlockKeysProto::mutable_allkeys() {
  // @@protoc_insertion_point(field_mutable_list:Hdfs.Internal.ExportedBlockKeysProto.allKeys)
  return &allkeys_;
}
inline const ::Hdfs::Internal::BlockKeyProto& ExportedBlockKeysProto::_internal_allkeys(int index) const {
  return allkeys_.Get(index);
}
inline const ::Hdfs::Internal::BlockKeyProto& ExportedBlockKeysProto::allkeys(int index) const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.ExportedBlockKeysProto.allKeys)
  return _internal_allkeys(index);
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::_internal_add_allkeys() {
  return allkeys_.Add();
}
inline ::Hdfs::Internal::BlockKeyProto* ExportedBlockKeysProto::add_allkeys() {
  // @@protoc_insertion_point(field_add:Hdfs.Internal.ExportedBlockKeysProto.allKeys)
  return _internal_add_allkeys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Hdfs::Internal::BlockKeyProto >&
ExportedBlockKeysProto::allkeys() const {
  // @@protoc_insertion_point(field_list:Hdfs.Internal.ExportedBlockKeysProto.allKeys)
  return allkeys_;
}

// -------------------------------------------------------------------

// RecoveringBlockProto

// required uint64 newGenStamp = 1;
inline bool RecoveringBlockProto::_internal_has_newgenstamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RecoveringBlockProto::has_newgenstamp() const {
  return _internal_has_newgenstamp();
}
inline void RecoveringBlockProto::clear_newgenstamp() {
  newgenstamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveringBlockProto::_internal_newgenstamp() const {
  return newgenstamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveringBlockProto::newgenstamp() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RecoveringBlockProto.newGenStamp)
  return _internal_newgenstamp();
}
inline void RecoveringBlockProto::_internal_set_newgenstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  newgenstamp_ = value;
}
inline void RecoveringBlockProto::set_newgenstamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_newgenstamp(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.RecoveringBlockProto.newGenStamp)
}

// required .Hdfs.Internal.LocatedBlockProto block = 2;
inline bool RecoveringBlockProto::_internal_has_block() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || block_ != nullptr);
  return value;
}
inline bool RecoveringBlockProto::has_block() const {
  return _internal_has_block();
}
inline void RecoveringBlockProto::clear_block() {
  if (block_ != nullptr) block_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::LocatedBlockProto& RecoveringBlockProto::_internal_block() const {
  const ::Hdfs::Internal::LocatedBlockProto* p = block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::LocatedBlockProto*>(
      &::Hdfs::Internal::_LocatedBlockProto_default_instance_);
}
inline const ::Hdfs::Internal::LocatedBlockProto& RecoveringBlockProto::block() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.RecoveringBlockProto.block)
  return _internal_block();
}
inline ::Hdfs::Internal::LocatedBlockProto* RecoveringBlockProto::release_block() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.RecoveringBlockProto.block)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::LocatedBlockProto* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::LocatedBlockProto* RecoveringBlockProto::_internal_mutable_block() {
  _has_bits_[0] |= 0x00000001u;
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::LocatedBlockProto>(GetArenaNoVirtual());
    block_ = p;
  }
  return block_;
}
inline ::Hdfs::Internal::LocatedBlockProto* RecoveringBlockProto::mutable_block() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.RecoveringBlockProto.block)
  return _internal_mutable_block();
}
inline void RecoveringBlockProto::set_allocated_block(::Hdfs::Internal::LocatedBlockProto* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.RecoveringBlockProto.block)
}

// -------------------------------------------------------------------

// VersionRequestProto

// -------------------------------------------------------------------

// VersionResponseProto

// required .Hdfs.Internal.NamespaceInfoProto info = 1;
inline bool VersionResponseProto::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool VersionResponseProto::has_info() const {
  return _internal_has_info();
}
inline void VersionResponseProto::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Hdfs::Internal::NamespaceInfoProto& VersionResponseProto::_internal_info() const {
  const ::Hdfs::Internal::NamespaceInfoProto* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::NamespaceInfoProto*>(
      &::Hdfs::Internal::_NamespaceInfoProto_default_instance_);
}
inline const ::Hdfs::Internal::NamespaceInfoProto& VersionResponseProto::info() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.VersionResponseProto.info)
  return _internal_info();
}
inline ::Hdfs::Internal::NamespaceInfoProto* VersionResponseProto::release_info() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.VersionResponseProto.info)
  _has_bits_[0] &= ~0x00000001u;
  ::Hdfs::Internal::NamespaceInfoProto* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::NamespaceInfoProto* VersionResponseProto::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::NamespaceInfoProto>(GetArenaNoVirtual());
    info_ = p;
  }
  return info_;
}
inline ::Hdfs::Internal::NamespaceInfoProto* VersionResponseProto::mutable_info() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.VersionResponseProto.info)
  return _internal_mutable_info();
}
inline void VersionResponseProto::set_allocated_info(::Hdfs::Internal::NamespaceInfoProto* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.VersionResponseProto.info)
}

// -------------------------------------------------------------------

// SnapshotInfoProto

// required string snapshotName = 1;
inline bool SnapshotInfoProto::_internal_has_snapshotname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SnapshotInfoProto::has_snapshotname() const {
  return _internal_has_snapshotname();
}
inline void SnapshotInfoProto::clear_snapshotname() {
  snapshotname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnapshotInfoProto::snapshotname() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.snapshotName)
  return _internal_snapshotname();
}
inline void SnapshotInfoProto::set_snapshotname(const std::string& value) {
  _internal_set_snapshotname(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotInfoProto.snapshotName)
}
inline std::string* SnapshotInfoProto::mutable_snapshotname() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.snapshotName)
  return _internal_mutable_snapshotname();
}
inline const std::string& SnapshotInfoProto::_internal_snapshotname() const {
  return snapshotname_.GetNoArena();
}
inline void SnapshotInfoProto::_internal_set_snapshotname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  snapshotname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotInfoProto::set_snapshotname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  snapshotname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotInfoProto.snapshotName)
}
inline void SnapshotInfoProto::set_snapshotname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  snapshotname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotInfoProto.snapshotName)
}
inline void SnapshotInfoProto::set_snapshotname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  snapshotname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotInfoProto.snapshotName)
}
inline std::string* SnapshotInfoProto::_internal_mutable_snapshotname() {
  _has_bits_[0] |= 0x00000001u;
  return snapshotname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotInfoProto::release_snapshotname() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.snapshotName)
  if (!_internal_has_snapshotname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return snapshotname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotInfoProto::set_allocated_snapshotname(std::string* snapshotname) {
  if (snapshotname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snapshotname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshotname);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.snapshotName)
}

// required string snapshotRoot = 2;
inline bool SnapshotInfoProto::_internal_has_snapshotroot() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SnapshotInfoProto::has_snapshotroot() const {
  return _internal_has_snapshotroot();
}
inline void SnapshotInfoProto::clear_snapshotroot() {
  snapshotroot_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SnapshotInfoProto::snapshotroot() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
  return _internal_snapshotroot();
}
inline void SnapshotInfoProto::set_snapshotroot(const std::string& value) {
  _internal_set_snapshotroot(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
}
inline std::string* SnapshotInfoProto::mutable_snapshotroot() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
  return _internal_mutable_snapshotroot();
}
inline const std::string& SnapshotInfoProto::_internal_snapshotroot() const {
  return snapshotroot_.GetNoArena();
}
inline void SnapshotInfoProto::_internal_set_snapshotroot(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotInfoProto::set_snapshotroot(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  snapshotroot_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
}
inline void SnapshotInfoProto::set_snapshotroot(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
}
inline void SnapshotInfoProto::set_snapshotroot(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  snapshotroot_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
}
inline std::string* SnapshotInfoProto::_internal_mutable_snapshotroot() {
  _has_bits_[0] |= 0x00000002u;
  return snapshotroot_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotInfoProto::release_snapshotroot() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
  if (!_internal_has_snapshotroot()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return snapshotroot_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotInfoProto::set_allocated_snapshotroot(std::string* snapshotroot) {
  if (snapshotroot != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  snapshotroot_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshotroot);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.snapshotRoot)
}

// required .Hdfs.Internal.FsPermissionProto permission = 3;
inline bool SnapshotInfoProto::_internal_has_permission() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || permission_ != nullptr);
  return value;
}
inline bool SnapshotInfoProto::has_permission() const {
  return _internal_has_permission();
}
inline void SnapshotInfoProto::clear_permission() {
  if (permission_ != nullptr) permission_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::Hdfs::Internal::FsPermissionProto& SnapshotInfoProto::_internal_permission() const {
  const ::Hdfs::Internal::FsPermissionProto* p = permission_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Hdfs::Internal::FsPermissionProto*>(
      &::Hdfs::Internal::_FsPermissionProto_default_instance_);
}
inline const ::Hdfs::Internal::FsPermissionProto& SnapshotInfoProto::permission() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.permission)
  return _internal_permission();
}
inline ::Hdfs::Internal::FsPermissionProto* SnapshotInfoProto::release_permission() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.permission)
  _has_bits_[0] &= ~0x00000020u;
  ::Hdfs::Internal::FsPermissionProto* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::Hdfs::Internal::FsPermissionProto* SnapshotInfoProto::_internal_mutable_permission() {
  _has_bits_[0] |= 0x00000020u;
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Hdfs::Internal::FsPermissionProto>(GetArenaNoVirtual());
    permission_ = p;
  }
  return permission_;
}
inline ::Hdfs::Internal::FsPermissionProto* SnapshotInfoProto::mutable_permission() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.permission)
  return _internal_mutable_permission();
}
inline void SnapshotInfoProto::set_allocated_permission(::Hdfs::Internal::FsPermissionProto* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.permission)
}

// required string owner = 4;
inline bool SnapshotInfoProto::_internal_has_owner() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SnapshotInfoProto::has_owner() const {
  return _internal_has_owner();
}
inline void SnapshotInfoProto::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SnapshotInfoProto::owner() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.owner)
  return _internal_owner();
}
inline void SnapshotInfoProto::set_owner(const std::string& value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotInfoProto.owner)
}
inline std::string* SnapshotInfoProto::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.owner)
  return _internal_mutable_owner();
}
inline const std::string& SnapshotInfoProto::_internal_owner() const {
  return owner_.GetNoArena();
}
inline void SnapshotInfoProto::_internal_set_owner(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotInfoProto::set_owner(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotInfoProto.owner)
}
inline void SnapshotInfoProto::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotInfoProto.owner)
}
inline void SnapshotInfoProto::set_owner(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotInfoProto.owner)
}
inline std::string* SnapshotInfoProto::_internal_mutable_owner() {
  _has_bits_[0] |= 0x00000004u;
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotInfoProto::release_owner() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.owner)
  if (!_internal_has_owner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return owner_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotInfoProto::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.owner)
}

// required string group = 5;
inline bool SnapshotInfoProto::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SnapshotInfoProto::has_group() const {
  return _internal_has_group();
}
inline void SnapshotInfoProto::clear_group() {
  group_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SnapshotInfoProto::group() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.group)
  return _internal_group();
}
inline void SnapshotInfoProto::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotInfoProto.group)
}
inline std::string* SnapshotInfoProto::mutable_group() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.group)
  return _internal_mutable_group();
}
inline const std::string& SnapshotInfoProto::_internal_group() const {
  return group_.GetNoArena();
}
inline void SnapshotInfoProto::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotInfoProto::set_group(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  group_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotInfoProto.group)
}
inline void SnapshotInfoProto::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotInfoProto.group)
}
inline void SnapshotInfoProto::set_group(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotInfoProto.group)
}
inline std::string* SnapshotInfoProto::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000008u;
  return group_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotInfoProto::release_group() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return group_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotInfoProto::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  group_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.group)
}

// required string createTime = 6;
inline bool SnapshotInfoProto::_internal_has_createtime() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SnapshotInfoProto::has_createtime() const {
  return _internal_has_createtime();
}
inline void SnapshotInfoProto::clear_createtime() {
  createtime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SnapshotInfoProto::createtime() const {
  // @@protoc_insertion_point(field_get:Hdfs.Internal.SnapshotInfoProto.createTime)
  return _internal_createtime();
}
inline void SnapshotInfoProto::set_createtime(const std::string& value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:Hdfs.Internal.SnapshotInfoProto.createTime)
}
inline std::string* SnapshotInfoProto::mutable_createtime() {
  // @@protoc_insertion_point(field_mutable:Hdfs.Internal.SnapshotInfoProto.createTime)
  return _internal_mutable_createtime();
}
inline const std::string& SnapshotInfoProto::_internal_createtime() const {
  return createtime_.GetNoArena();
}
inline void SnapshotInfoProto::_internal_set_createtime(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  createtime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SnapshotInfoProto::set_createtime(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  createtime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Hdfs.Internal.SnapshotInfoProto.createTime)
}
inline void SnapshotInfoProto::set_createtime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  createtime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Hdfs.Internal.SnapshotInfoProto.createTime)
}
inline void SnapshotInfoProto::set_createtime(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  createtime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Hdfs.Internal.SnapshotInfoProto.createTime)
}
inline std::string* SnapshotInfoProto::_internal_mutable_createtime() {
  _has_bits_[0] |= 0x00000010u;
  return createtime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotInfoProto::release_createtime() {
  // @@protoc_insertion_point(field_release:Hdfs.Internal.SnapshotInfoProto.createTime)
  if (!_internal_has_createtime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return createtime_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotInfoProto::set_allocated_createtime(std::string* createtime) {
  if (createtime != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  createtime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), createtime);
  // @@protoc_insertion_point(field_set_allocated:Hdfs.Internal.SnapshotInfoProto.createTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Internal
}  // namespace Hdfs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Hdfs::Internal::DatanodeInfoProto_AdminState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::DatanodeInfoProto_AdminState>() {
  return ::Hdfs::Internal::DatanodeInfoProto_AdminState_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::HdfsFileStatusProto_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::HdfsFileStatusProto_FileType>() {
  return ::Hdfs::Internal::HdfsFileStatusProto_FileType_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto>() {
  return ::Hdfs::Internal::NamenodeRegistrationProto_NamenodeRoleProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::NamenodeCommandProto_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::NamenodeCommandProto_Type>() {
  return ::Hdfs::Internal::NamenodeCommandProto_Type_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::StorageTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::StorageTypeProto>() {
  return ::Hdfs::Internal::StorageTypeProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::CipherSuiteProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::CipherSuiteProto>() {
  return ::Hdfs::Internal::CipherSuiteProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::CryptoProtocolVersionProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::CryptoProtocolVersionProto>() {
  return ::Hdfs::Internal::CryptoProtocolVersionProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::ChecksumTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::ChecksumTypeProto>() {
  return ::Hdfs::Internal::ChecksumTypeProto_descriptor();
}
template <> struct is_proto_enum< ::Hdfs::Internal::ReplicaStateProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Hdfs::Internal::ReplicaStateProto>() {
  return ::Hdfs::Internal::ReplicaStateProto_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hdfs_2eproto
